# Lecture 35

> `04-04-22`

We shall discuss a series of concepts in isolation now.

### Recoverable Schedules

If a transaction $$T_i$$ reads a data item previously written by a transaction $$T_j$$, then the commit operation of $$T_j$$ appears before the commit operation of $$T_i$$.  These schedules are recoverable.

### Cascading rollbacks

A single transaction failure leads to a series of transaction rollbacks. That is, uncommitted transactions must be rolled back. 

### Cascadeless Schedules

Cascading rollbacks cannot occur in these schedules. For each pair of transactions $$T_i$$ and $$T_j$$ such that $$T_j$$ reads a data item previously written by $$T_i$$, the commit operation $$T_i$$ appears before the read operation of $$T_j$$. That is, they allow reading of committed values only and disallow *dirty reads*. Every cascadeless schedule is recoverable.

### Weak levels of Isolation

Some applications can tolerate schedules that are not serialisable. For example, in statistics we only want approximations. Ideally, we’d like serialisable, recoverable and preferably cascadable.

There are levels of isolation defined in SQL-92 like - read committed, read uncommitted, repeatable read, and serialisable. Most often, databases run in read committed mode. 

### Concurrency Control Mechanisms

We have a ton of theory for implementing whatever we have discussed. There are locking schemes, timestamp schemes, optimistic/lazy schemes and multi-versions (similar to master-slave mechanism in parallel cores of architecture).

## Transactions in SQL

We have predicate operations in SQL. A tuple might fail a predicate before a transaction, but passes it after the transaction has completed. Some databases lock the matched tuples for consistency, but that does not always work. That is, we need “predicate locking”, not just key-based locks that locks all *possible* matching tuples. Phantom reads refer to not matching tuples that are just added.

In SQL, a transaction begins implicitly. **commit work** commits current transaction and begins a new one. **rollback work** causes current transaction to abort. Isolation levels can be set at database level or at the start of a transaction.

# ~Chapter 18: Concurrency Control

## Lock based protocols

A lock is a mechanism to control concurrent access to a data item. Items can be locked in two modes

- **exclusive** (X) mode - Data item can be both read as well as written. `lock-X`
- **shared** (S) mode - Data item can only be read. `lock-S`

These requests are made implicitly using a concurrency control manager. Not that X lock can’t be obtained when a S lock is held on an item. 

A **locking protocol** is a set of rules followed by all transactions while requesting and releasing locks. They enforce serialisability by restricting the set of possible schedules. To handle **deadlocks**, we need to roll back some transactions. **Starvation** is also possible if concurrency control manager is badly designed. This occurs because X-locks can’t be granted when S-lock is being used. 

### Two-Phase Locking Protocol

This protocol ensures conflict-serialisable schedules. We have two phases 

- Phase 1: Growing phase. A transaction can obtain locks but not release them
- Phase 2: Shrinking phase. It’s the opposite of the above.

The transactions can be serialised in the order of their lock points (the point where a transaction has acquired its final lock). However, this protocol does not ensure protection from deadlocks. It also does not ensure recoverability. There are extensions that ensure recoverability from cascading roll-back.

- **Strict two-phase locking** - A transaction must hold all its exclusive locks till it commits/aborts. 
- **Rigorous two-phase locking** - A transaction must hold all locks till commit/abort.  

We mostly use the second protocol. 

Two-phase locking is not necessary condition for serialisability. That is, there are conflict serialisable schedules that cannot be obtained if the two-phase locking protocol is used.

Given a locking protocol, a schedule $$S$$ is **legal** under a locking protocol if it can be generated by a set of transactions that follow the protocol. A protocol **ensures** serialisability if all legal schedules under that protocol are serialisable. 

In the two-phase locking protocol. we can upgrade (S to X) in the growing phase and downgrade (X to S) in the shrinking phase.



