<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Numerical Analysis Notes | Sudhansh</title> <meta name="author" content="Sudhansh Peddabomma"> <meta name="description" content="A course disucssing interpolation theory, numerical intergration, numerical solutions to ordinary differential equations, numerical solutions to system of linear equations and roots of non-linear equations."> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%91%BE&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://sudhansh6.github.io/blog/NumAn/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?6185d15ea1982787ad7f435576553d64"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Sudhansh</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">Articles</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"></a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/challenges/">Challenges</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/misc/">Miscellaneous</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">Numerical Analysis Notes</h1> <p class="post-meta">January 10, 2022</p> <p class="post-tags"> <a href="/blog/2022"> <i class="fa-solid fa-calendar fa-sm"></i> 2022 </a>   ·   <a href="/blog/category/notes"> <i class="fa-solid fa-tag fa-sm"></i> Notes</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <h1 id="lecture-1">Lecture 1</h1> <p><em>Numerical Analysis</em> is the study of various methods</p> <ul> <li>to solve <ul> <li>differential equations,</li> <li>systems of linear equations,</li> <li>\(f(x) = \alpha\).</li> </ul> </li> <li>to approximate functions and</li> <li>to study the corresponding errors.</li> </ul> <p><strong>Example.</strong> \(e = \lim_{n \to \inf} (1 + 1/n)^n)\). How do we approximate \(e\) to an arbitrary accuracy? Since, the \(exp\) function is infinitely many times differentiable, we can approximate the function using Taylor’s theorem to any degree of precision we want.</p> <div style="text-align: center;"> $$ \text{Taylor's theorem} \\ f(x) = f(a) + f'(a)(x - a) + \cdots + \\ \frac{f^{(k)}(a)}{k!}(x - a)^k + \frac{f^{(k + 1)}(c)}{k!}(x - a)^{k + 1} $$ </div> <p>Using this, we get</p> <div style="text-align: center;"> $$ e = 1 + \frac{1}{1!} + \frac{1}{2!} + \cdots + \\ \frac{1}{n!} + \frac{e^c}{(n + 1)!} $$ </div> <p>where \(c\) is some real number between 0 and 1. Here, the error term at the \(n\)-th approximation is the term \(e^c/(n + 1)!\). We know that \(e^c\) is less than 3 so we can compute \(n\) where the error term is less than the prescribed error!</p> <p>For example, suppose we want the error to be less than \(10^{-10}\), then we use \(e^c/(n + 1)! &lt; 10^{-10}\).</p> <p><strong>Note.</strong> The last term is not the error in our approximation! We are choosing \(e^c = 3\) for no particular reason. It can be any value greater than the true value of \(e^c\). For instance, we can take \(e^c = 1000\) too. If we want our calculated value \(e\) value to be precise till the 10th decimal, then we ensure that \(1000/(n + 1)! &lt; 10^{-10}\) by tuning \(n\) appropriately.</p> <h2 id="aspects-of-numerical-analysis">Aspects of numerical analysis</h2> <ul> <li>The theory behind the calculation, and</li> <li>The computation.</li> </ul> <p>Some calculators have a loss of information due to limits in precision. This is due to the round-off error. We need to be able to detect and deal with such cases.</p> <h1 id="lecture-2">Lecture 2</h1> <h2 id="finite-digit-arithmetic">Finite digit arithmetic</h2> <p>When we do arithmetic, we allow for infinitely many digits. However, in the computational world, each representable number has only a fixed and finite number of digits. In most cases, the machine arithmetic is satisfactory, but at times problems arise because of this discrepancy. The error that is produced due to this issue is called the <strong>round-off</strong> error.</p> <p>A 64-bit representation is used for a real number. The first bit is a <strong>sign indicator</strong>, denoted by <em>s</em>. This is followed by an 11-bit exponent, <em>c</em>, called the <strong>characteristic</strong>, and a 52-bit binary fraction, <em>f</em>, called the <strong>mantissa</strong>. To ensure that numbers with small magnitude are equally representable, 1023 is subtracted from the characteristic, so the range of the exponent is actually from -1023 to 1024.</p> <p>Thus, the system gives a floating-point number of the form</p> <div style="text-align:center;"> $$ (-1)^s\cdot2^{c - 1023}\cdot(1 + f) $$ </div> <p>Since 52 binary digits correspond to between 16 and 17 decimal digits, we can assume that a number represented in this system is accurate till the 16th decimal.</p> <blockquote> <p>Can’t a single number be represented in many ways through this representation? Think about 1 for instance.</p> </blockquote> <p>The smallest positive number that can be represented is with \(s = 0, c = 1, f = 0\), so it is</p> <div style="text-align:center;"> $$ 2^{-1022}\cdot(1 + 0) \approx 0.22251 \times 10^{-307} $$ </div> <p>Numbers occurring in calculations that have a magnitude less than this number result in <strong>underflow</strong> and are generally set to 0.</p> <p>The largest positive number is</p> <div style="text-align:center;"> $$ 2^{1023}\cdot (2 - 2^{-52}) $$ </div> <p>Numbers above this would result in an <strong>overflow</strong>.</p> <h2 id="floating-point-representation">Floating-point representation</h2> <p>We will use numbers of the form</p> <div style="text-align:center;"> $$ \pm 0.d_1d_2\dots d_kd_{k + 1} \times 10^n $$ </div> <p>with \(1 \leq d_1 \leq 9\). There are two ways to get the floating-point representations \(fl(p)\) of a positive number \(p\)</p> <ul> <li> <strong>Chopping.</strong> We simply chop off the \(d_{k + 1}, d_{k + 2}, \dots\) and write \(0.d_1d_2\dots d_k \times 10^n\)</li> <li> <strong>Rounding.</strong> We add \(5 \times 10^{n - (k + 1)}\) to the number and then chop the result to obtain \(0.\delta_1\delta_2\dots \delta_k \times 10^n\)</li> </ul> <h2 id="errors">Errors</h2> <p>This approximate way of writing numbers is bound to create errors. If \(p\) is a real number and if \(p^*\) is its approximation then the <strong>absolute error</strong> is \(\|p - p ^*\|\) while the <strong>relative error</strong> is \(\|p - p ^*\|/p\) whenever \(p \neq 0\). Relative error is more meaningful as it takes into account the size of the number \(p\).</p> <p><strong>Note.</strong> Relative error can be negative as we take the value of \(p\) in the denominator!</p> <h2 id="significant-digits">Significant digits</h2> <p>We say that the number \(p^*\) approximates \(p\) to \(t\) significant digits if \(t\) is the largest non-negative integer for which</p> <div style="text-align:center;"> $$ \frac{\|p - p^*\|}{p} &lt; 5 \times 10^{-t} $$ </div> <h2 id="finite-digit-arithmetic-1">Finite Digit Arithmetic</h2> <p>The arithmetic in machines in defined by the following -</p> <div style="text-align:center;"> $$ x \oplus y := fl(fl(x) + fl(y)) $$ </div> <h1 id="lecture-3">Lecture 3</h1> <h2 id="major-sources-of-errors">Major sources of errors</h2> <p>One of the major sources of errors is cancellation of two nearly equal numbers. Suppose we have</p> <div style="text-align:center"> $$ fl(x) = 0.d_1d_2\dots d_p\alpha_{p + 1}\dots\alpha_k \times 10^n \\ fl(y) = 0.d_1d_2\dots d_p\beta_{p + 1}\dots\beta_k \times 10^n \\ fl(fl(x) - fl(y)) = 0.\gamma_{p + 1}\dots\gamma_k \times 10^{n - p} $$ </div> <p>In the above set of equations, the difference \(x \ominus y\) has \(k - p\) digits of significance compared to the \(k\) digits of significance of \(x\) and \(y\). The number of significant digits have reduced which leads to errors in further calculations.</p> <p>Another way the errors creep in is when we divide by number of small magnitude or multiply by numbers of large magnitude. This is because the error gets multiplied by a factor which increases its absolute value.</p> <p>Consider the expression \(-b \pm \sqrt{b^2 - 4ac}/2a\). By default, we consider positive square roots. Here, if \(b^2\) is large compared to \(4ac\) then the machine is likely to treat \(4ac\) as zero. How do we get around this error? <strong>Rationalization</strong></p> <div style="text-align:center"> $$ \frac{-b + \sqrt{b^2 - 4ac}}{2a} \times \frac{-b - \sqrt{b^2 - 4ac}}{-b - \sqrt{b^2 - 4ac}} = \frac{-2c}{b + \sqrt{b^2 - 4ac}} $$ </div> <p>​ Notice what happened here. Previously, the roots would have become zero because \(4ac\) could have been approximated as zero. However, this does not happen after rationalization! Also, do note that this won’t work when \(b&lt;0\) as we are considering positive square roots. If \(b&lt;0\), we can use the formula without rationalization. Think about the other root using such cases. Thus, the cancellation error can come in two major ways:</p> <ul> <li>when we cancel two nearly equal numbers, and</li> <li>when we subtract a small number from a big number</li> </ul> <h3 id="errors-propagate">Errors propagate</h3> <p>Once an error is introduced in a calculation, any further operation is likely to contain the same or a higher error.</p> <h2 id="can-we-avoid-errors">Can we avoid errors?</h2> <p>Errors are inevitable in finite arithmetic. There are some measures that we can take to try to avoid errors, or minimize them. For example, a general degree 3 polynomial can be written as a nested polynomial.</p> <div style="text-align:center"> $$ ax^3 + bx^2 + cx + d - x(x(ax + b) + c) + d $$ </div> <p>Computations done using this form will typically have a smaller error as the number of operations has reduced (from 5 to 3). Now, we are done with the first theme of our course - <strong><em>Machine arithmetic</em></strong>.</p> <h1 id="lecture-4">Lecture 4</h1> <h2 id="roots-of-equations">Roots of equations</h2> <p>The zeros of a function can give us a lot of information regarding the function. Why specifically zero? Division is in general more difficult to implement in comparison to multiplication. Division is implemented via the solution to roots of an equation in computers. There are other reasons such as eigenvalue decomposition. We shall see all of this later in the course.</p> <p><strong><em>Theorem.</em></strong> <em>Intermediate Value Theorem</em>. If \(f: [a, b] \to \mathbb R\) is a continuous function with \(f(a)\cdot f(b) &lt; 0\) then there is a \(c \in [a, b]\) such that \(f(x) = 0\).</p> <h3 id="bisection-method">Bisection method</h3> <p>The bisection method is implemented using the above theorem. To begin, we set \(a_1 = a\) and \(b_1 = b\), and let \(p_1\) be the midpoint of \([a, b]\);</p> <ul> <li>If \(f(p_1) = 0\), then we are done</li> <li>If \(f(p_1)f(a_1)&gt;0\), then the subinterval \([p_1, b_1]\) contains a root of \(f\), we then set \(a_2 = p_1\) and \(b_2 = b_1\)</li> <li>If \(f(p_1)f(b_1)&gt;0\), then the subinterval \([a_1, p_1]\) contains a root of \(f\), we then set \(a_2 = a_1\) and \(b_2 = p_1\)</li> </ul> <p>We continue this process until we obtain the root. Each iteration reduces the size of the interval by half. Therefore, it is beneficial to choose a small interval in the beginning. The sequence of \(\{p_i\}\) is a Cauchy sequence. IT may happen that none of the \(p_i\) is a root. For instance, the root may be an irrational number and \(a_1, b_1\) may be rational numbers. There are three criteria to decide to stop the bisection process.</p> <ul> <li>\(\|f(p_n)\| &lt; \epsilon\) - not very good because it may take a long time to achieve it, or that it may be achieved easily and yet \(p_n\) is significantly many steps away from a root of \(f\)</li> <li>\(\|p_n - p_{n-1}\| &lt;\epsilon\) is not good because it does not take the function \(f\) into account. While \(p_n\) and \(p_{n-1}\) may be close enough but the actual root may still be many steps away.</li> <li>\(p_n \neq 0 \text{ and } \frac{\|p_n - p_{n-1}\|}{\|p_n\|} &lt; \epsilon\) looks enticing as it mimics the relative error but again it does not take \(f\) into account.</li> </ul> <p>The bisection method has significant drawbacks - It is relatively slow to converge, and a good intermediate approximation might be inadvertently discarded. However, the method has the important property that is always converges to a solution.</p> <h1 id="lecture-5">Lecture 5</h1> <h2 id="fixed-points-and-roots">Fixed points and roots</h2> <p>A <em>fixed point</em> of \(f : [a,b] \to \mathbb R\) is \(p \in [a,b]\) such that \(f(p) = p\). Finding a fixed point of the function \(f\) is equivalent to finding the root of the function \(g(x) = f(x) - x\). We can create many such functions which give fixed points of \(f\) on solving for the roots of the function.</p> <p><strong><em>Theorem.</em></strong> <em>Fixed Point Theorem</em>. If \(f: [a,b] \to [a,b]\) is continuous then \(f\) has a fixed point. If, in addition, \(f’(x)\) exists on \((a, b)\) and \(\vert f’(x)\vert \leq k &lt; 1\) for all \(x \in (a, b)\) then \(f\) has a unique fixed point in \([a, b]\).</p> <p>The hypothesis is sufficient but not necessary!</p> <h3 id="fixed-point-iteration">Fixed point iteration</h3> <p>We start with a continuous \(f: [a,b] \to [a,b]\). Take any initial approximation \(p_0 \in [a,b]\) and generate a sequence \(p_n = f(p_{n - 1})\). If the sequence \(\{p_n\}\) converges to \(p \in [a, b]\) then</p> <div style="text-align:center"> $$ \begin{align} f(p) &amp;= f(\lim_n p_n) \\ &amp;= \lim_n f(p_n) = \lim_n p_{n + 1}\\ &amp;= p \end{align} $$ </div> <p>This method is called the <em>fixed point iteration method</em>. It’s convergence is not guaranteed.</p> <p>For instance, consider the roots of the equation \(x^3 + 4x^2 - 10 = 0\). The following functions can be used to find the roots using the fixed points.</p> <div style="text-align:center"> $$ \begin{align} x &amp;= g_1(x) = x - (x^3 + 4x^2 - 10)\\ x &amp;= g_2(x) = (\frac{10}{x} - 4x)^{1/2} \\ x &amp;= g_3(x) = \frac{1}{2}(10 - x^3)^{1/2} \end{align} $$ </div> <p>The results using different \(g\)’s in the Fixed Point Iteration method are surprising. The first two functions diverge, and the last one converges. This problem is because the hypothesis of the FPT does not hold in the first two functions. While the derivative \(g’(x)\) fails to satisfy in the FPT, a closer look tells us that it is enough to work on the interval \([1, 1.5]\) where the function \(g_3\) is strictly decreasing.</p> <p>So now we have the question - How can we find a fixed point problem that produces a sequence that reliably and rapidly converges to a solution to a given root-finding problem?</p> <h1 id="lecture-6">Lecture 6</h1> <h2 id="newton-raphson-method">Newton-Raphson method</h2> <p>This is a particular fixed point iteration method. Assume that \(f: [a, b] \to \mathbb R\) is twice differentiable. Let \(p \in [a, b]\) be a solution of the equation \(f(x) = 0\). If \(p_0\) is another point in \([a, b]\) then Taylor’s theorem gives</p> \[\begin{align} 0 &amp;= f(p) \\ &amp;= f(p_0) + (p - p_0)f'(p_0) + \frac{(p - p_0)^2}{2}f''(\xi) \end{align}\] <p>for some \(\xi\) between \(p\) and \(p_0\). We assume that \(\vert p - p_0 \vert\) is very small. Therefore, \(0 \approx f(p_0) + (p - p_0)f’(p_0)\). This sets the stage for the Newton-Raphson method, which starts with an initial approximation \(p_0\) and generate the sequence \(\{p_n\}\) by</p> \[p_n = p_{n - 1} - \frac{f(p_{n - 1})}{f'(p_{n - 1})}\] <p>What is the geometric interpretation of this method? It approximates successive tangents. The Newton-Raphson method is evidently better than the fixed point iteration method. However, it is important to note that \(\vert p - p_0 \vert\) is need to be small so the third term in the Taylor’s polynomial can be dropped.</p> <p><strong><em>Theorem.</em></strong> Let \(f: [a, b] \to \mathbb R\) be twice differentiable. If \(p \in (a, b)\) is such that \(f(p) = 0\) and \(f’(p) \neq 0\), then there exists a \(\delta &gt; 0\) such that for any \(p_0 \in [p - \delta, p + \delta]\), the Newton-Raphson method generates a sequence \(\{p_n\}\) converging to \(p\).</p> <p>This theorem is seldom applied in practice, as it does not tell us how to determine the constant \(\delta\). In a practical application, an initial approximation is selected and successive approximations are generated by the method. These will generally either converge quickly to the root, or it will be clear that convergence is unlikely.</p> <h1 id="lecture-7">Lecture 7</h1> <h3 id="problems-with-the-newton-raphson-method">Problems with the Newton-Raphson method</h3> <p>We have</p> \[p_n = p_{n - 1} - \frac{f(p_{n - 1})}{f'(p_{n - 1})}\] <p>One major problem with this is that we need to compute the value of \(f’\) at each step. Typically, \(f'\) is far more difficult to compute and needs more arithmetic operations to calculate than \(f\).</p> <h2 id="secant-method">Secant method</h2> <p>This method is a slight variation to NR to circumvent the above problem. By definition,</p> \[f'(a) = \lim_{x \to a} \frac{f(a) - f(x)}{a - x}\] <p>If we assume that \(p_{n - 2}\) is reasonable close to \(p_{n - 1}\) then</p> \[f'(p_{n - 1}) \approx \frac{f(p_{n - 1}) - f(p_{n - 2})}{p_{n - 1} - p_{n - 2}}\] <p>This adjustment is called as the <em>secant method</em>. The geometric interpretation is that we use successive secants instead of tangents. Note that we can use the values of \(f(p_{n - 2})\) from the previous calculations to prevent redundant steps. We need two initial guesses in this method.</p> <p>Secant method is efficient in comparison to Newton-Raphson as it requires only a single calculation in each iteration whereas NR requires 2 calculations in each step.</p> <h2 id="the-method-of-false-position">The method of false position</h2> <p>The NR or the Secant method may give successive approximations which are on one side of the root. That is \(f(p_{n - 1}) \cdot f(p_n)\) need not be negative. We can modify this by taking the pair of approximations which are on both sides of the root. This gives the <strong><em>regula falso method</em></strong> or the <em>method of false position</em>.</p> <p>We choose initial approximations \(p_0\) and \(p_1\) with \(f(p_0)\cdot f(p_1) &lt; 0\). We then use Secant method for successive updates. If in any iteration, we have \(f(p_{n - 1})\cdot f(p_n) &gt; 0\), then we replace \(p_{n - 1}\) by \(p_{n - 2}\).</p> <p>The added requirement of the regula falsi method results in more calculations than the Secant method.</p> <h2 id="comparison-of-all-the-root-finding-methods">Comparison of all the root finding methods</h2> <ul> <li>The bisection method guarantees a sequence converging to the root but it is a slow method.</li> <li>The other methods are sure to work, once the sequence is convergent. The convergence typically depends on the initial approximations being very close to the root.</li> <li>Therefore, in general, bisection method is used to get the initial guess, and then NR or the Secant method is used to get the exact root.</li> </ul> <h1 id="lecture-8">Lecture 8</h1> <p>We are reaching the end of the <em>equations in one variable</em> theme.</p> <h2 id="order-of-convergence">Order of convergence</h2> <p>Let \(\{p_n\}\) be a sequence that converges to \(p\) with \(p_n \neq p\) for any \(n\). If there are positive constants \(\lambda\) and \(\alpha\) such that</p> \[\lim_n \frac{\vert p_{n + 1} - p \vert}{\vert p_n - p \vert^\alpha} = \lambda\] <p>then the <strong>order of convergence</strong> of \(\{p_n\}\) to \(p\) is \(\alpha\) with <em>asymptomatic error</em> \(\lambda\). An iterative technique of the form \(p_n = g(p_{n - 1})\) is said to be of order \(\alpha\) if the sequence \(\{p_n\}\) converges to the solution \(p = g(p)\) with order \(\alpha\).</p> <p>In general, a sequence with a high order of convergence converges more rapidly than a sequence with a lower order. The asymptotic constant affects the speed of convergence but not to the extent of the order.</p> <p>Two cases of order are given special attention</p> <ul> <li>If \(\alpha = 1\) and \(\lambda &lt; 1\), the sequence is <strong>linearly convergent</strong>.</li> <li>If \(\alpha = 2\), the sequence is <strong>quadratically convergent</strong>.</li> </ul> <h3 id="order-of-convergence-of-fixed-point-iteration-method">Order of convergence of fixed point iteration method?</h3> <p>Consider the fixed point iteration \(p_{n + 1} = f(p_n)\). The Mean Value Theorem gives</p> \[\begin{align} p_{n + 1} - p &amp;= f(p_n) - f(p) \\ &amp;= f'(\xi_n)(p_n - p) \end{align}\] <p>where \(\xi_n\) lies between \(p_n\) and \(p\), hence \(\lim_n\xi_n = p\). Therefore,</p> \[\lim_n \frac{\vert p_{n + 1} - p \vert}{\vert p_n - p \vert} = \lim_n \vert f'(\xi_n)\vert = \vert f'(p)\vert\] <p>The convergence of a fixed point iteration method is thus <strong>linear</strong> if \(f’(p) \neq 0\) and \(f’(p) &lt; 1\).</p> <p>We need to have \(f’(p) = 0\) for a higher order of convergence.</p> <blockquote> <p>why?</p> </blockquote> <p><strong><em>Theorem.</em></strong> Let \(p\) be a solution of the equation \(x = f(x)\). Let \(f’(p) = 0\) and \(f’'\) be continuous with \(\vert f''(x) \vert &lt; M\) nearby \(p\). Then there exists a \(\delta &gt; 0\) such that, for \(p_0 \in [p - \delta, p + \delta]\), the sequence defined \(p_n = f(p_{n - 1})\) converges at least quadratically to \(p\). Moreover, for sufficiently large values of \(n\)</p> \[\vert p_{n+1} - p \vert &lt; \frac{M}{2}\vert p_n - p \vert^2\] <p>For quadratically convergent fixed point methods, we should search for functions whose derivatives are zero at the fixed point. If we have the root-finding problem for \(g(x) = 0\), then the easiest way to construct a fixed-point problem would be</p> \[\begin{align} f(x) &amp;= x - \phi(x)g(x)\\ f'(x) &amp;= 1 - \phi'(x)g(x) - \phi(x)g'(x) \\ 0 &amp;= f'(p) = 1 - \phi(p)g'(p) \\ &amp; \implies \phi(p) = {g'(p)}^{-1} \end{align}\] <p>where \(\phi\) is a differentiable function, to be chosen later. Therefore, define \(phi(x) = {g’(x)}^{-1}\) which gives</p> \[p_{n + 1} = f(p_n) = p_n - \frac{g(p_n)}{g'(p_n)}\] <p>This is the Newton-Raphson method! We have assumed that \(g’(p) \neq 0\) in the above analysis. The NR/Secant method will not work if this assumption fails.</p> <h2 id="multiplicity-of-a-zero">Multiplicity of a zero</h2> <p>Let \(g: [a, b] \to \mathbb R\) be a function and let \(p \in [a, b]\) be a zero of \(g\). We say that \(p\) is a <strong>zero of multiplicity</strong> \(m\) of \(g\) if for \(x \neq p\), we can write \(g(x) = (x - p)^mq(x)\) with \(\lim_{x \to p}q(x) \neq 0\).</p> <p>Whenever \(g\) has a simple zero (\(m = 1\)) at \(p\), then the NR method works well for \(g\). However, NR does not give a quadratic convergence if the order of the zero is more than 1.</p> <h1 id="lecture-9">Lecture 9</h1> <p><strong>Note.</strong> \(n\)-digit arithmetic deals with \(n\) significant digits and not \(n\) places after the decimal.</p> <h2 id="order-of-the-fixed-point-iteration-method">Order of the fixed point iteration method</h2> <p>Summarizing the last lecture we have</p> <ul> <li>If we have a function \(g(x)\) whose roots are to be found, we can convert it to a fixed point problem by appropriately constructing a \(f(x)\).</li> <li>If we construct \(f(x)\) such that it’s derivative is non-zero at the root, then the fixed point iteration method is <u>linear</u>.</li> <li>Otherwise, if the derivative is zero, then the fixed point iteration method is quadratic or higher. For example, we constructed such a \(f(x)\) which mirrored the Newton-Raphson method.</li> <li>In the Newton-Raphson method itself, if the root is a simple zero of \(g\), the method has quadratic convergence. However, if it is not a simple zero if \(g\) then the method may not have a quadratic convergence.</li> </ul> <p>Can we modify NR to overcome the limitation of multiplicity of the zero?</p> <h2 id="modified-newton-raphson">Modified Newton-Raphson</h2> <p>For a given \(g(x)\), we define a function \(\mu\)</p> \[\mu(x) = \frac{g(x)}{g'(x)}\] <p>If \(x = p\) is a xero of \(g\) with multiplicity \(m\), we have</p> \[\mu(x) = (x - p)\frac{q(x)}{mq(x) + (x - p)q'(x)}\] <p>Notice that \(x = p\) is a simple root of \(\mu\). Further, assume \(g, q\) are continuous. Then, if \(g(x)\) has no other zero in a neighborhood of \(x = p\) then \(\mu(x)\) will also not have any other zero in that neighborhood. We can now apply Newton-Raphson method to \(\mu(x)\).</p> <p>The fixed point iteration is given by</p> \[\begin{align} f(x) &amp;= x - \frac{\mu(x)}{\mu'(x)} \\ &amp;= x - \frac{g(x)/g'(x)}{(g'(x)^2 - g(xg''(x)))/g'(x)^2} \\ &amp;= x - \frac{g(x)g'(x)}{g'(x)^2 - g(x)g''(x)} \end{align}\] <p>This iteration will converge to \(p\) with at least the quadratic order of convergence. The only theoretical drawback with this method is that we now need to compute \(g’’(x)\) at each step. Computationally, the denominator of the formula involves cancelling two nearly equal terms (\(x = p\) is a root of both \(g, g’\)).</p> <p>Note that if \(x = p\) is a simple zero, the modified Newton-Raphson still bodes well. It’s just that there are a lot more calculations in the modified NR method.</p> <h2 id="an-other-methods">An other methods?</h2> <p>There are many methods other than the 4 we considered so far. Suppose that \(\{p_n\}\) converges to \(p\) linearly. For large enough \(n\), we have \((p_{n + 1} - p)^2 \approx (p_n - p)(p_{n + 2} - p)\) which further gives</p> \[p \approx p_n - \frac{(p_{n + 1} - p_n)^2}{p_{n + 2} - 2p_{n + 1} + p_n} = \hat p_n\] <p>This is called <strong>Aitken’s</strong> \(\mathbf{\Delta^2}\)<strong>-method</strong> of accelerating convergence. So, if we have a sequence \(\{p_n\}\) converging to \(p\) linearly, we can come up with an alternate sequence \(\{\hat p_n\}\) using the original sequence that converges faster.</p> <p>This brings us to the end of the second theme of our course - <em>Equations in one variable</em>.</p> <h1 id="lecture-10">Lecture 10</h1> <p>We begin the third theme of our course - <em>Interpolation</em></p> <p>Polynomials are very well studied functions. They have the form \(P(x) = a_nx^n + \cdots + a_1x + a_0\). Given any continuous function \(f: [a, b] \to \mathbb R\), there exists a polynomial that is as close to the given function as desired. In other words, we can construct a polynomial which exactly matches the function in a finite interval. This is known as <strong><em>Weierstrass approximation theorem</em></strong>. Another reason to prefer polynomials is that the derivatives of polynomials are also polynomials.</p> <h2 id="taylor-polynomials">Taylor polynomials</h2> <p>We can consider the polynomials formed by Taylor’s theorem. However, these polynomials approximate the function only at a single point. The advantage of using these polynomials is that the error between the function and the polynomial can be determined accurately. For ordinary computational purposes it is more efficient to use methods that include information at various points.</p> <h2 id="lagrange-interpolating-polynomials">Lagrange interpolating polynomials</h2> <p>Let \(f\) be a function with \(f(x_0) = y_0\). Is there a polynomial \(P(x)\) with \(P(x_0) = y_0\).</p> <p>The simplest case is \(P(x) = y_0\). If we have two points \(x_0\) and \(x_1\), then we can have \(P(x) = y_0\frac{x - x_1}{x_0 - x_1} + y_1\frac{x - x_0}{x_1 - x_0}\) . We can generalize this for more number of points.</p> <p>Let \(x_0, x_1, \dots, x_n\) be distinct \((n + 1)\)-points and let \(f\) be a function with \(f(x_i) = y_i, \forall i \in [n]\). We want to find a polynomial \(P\) that equals \(f\) at these points. To do this, we first solve \(n + 1\) special problems, where \(y_i = \delta_{i, n + 1}\). We find polynomials \(L_{n, i}\) with</p> \[L_{n, i}(x_j) = \delta_{i, j} = \cases{0 &amp; i $\neq$ j \\ 1 &amp; i = j}\] <p>For a fixed \(i\), \(L_{n, i}(x_j) = 0\) for \(j \neq i\). So \((x - x_j)\) divides \(L_{n, i}(x)\) for each \(j \neq i\). Since the points \(x_i\) are all distinct, we have that the product of all such \((x - x_j)\)‘s divides \(L_{n, i}(x)\). We define \(L_{n, i}(x)\) as</p> \[L_{n, i}(x) = \frac{(x - x_0)\dots(x - x_{i - 1})(x - x_{i + 1})\dots (x - x_n)}{(x_i - x_0)\dots(x_i - x_{i - 1})(x_i - x_{i + 1})\dots(x_i - x_n)}\] <p>then \(L_{n, i}(x_j) = \delta_{i, j}\). Now, \(P\) can be constructed as</p> \[P(x) = y_0L_{n, 0}(x) + \dots + y_nL_{n, n}(x)\] <p>The validity of this polynomial can be checked easily.</p> <h1 id="lecture-11">Lecture 11</h1> <blockquote> <p>What if you take a linear function and use \(n &gt;2\) points for Lagrange interpolation? Will the final function be linear? It should be.</p> <p>For example, in class we considered \(f(1) = 1\) and \(f(2) = 1\). These values gave a constant polynomial.</p> </blockquote> <p>In general, for \((n + 1)\)-points, the interpolating polynomial will have degree <strong>at most</strong> \(n\).</p> <h2 id="uniqueness-of-the-interpolating-polynomial">Uniqueness of the interpolating polynomial</h2> <p>For a given set of \((n + 1)\) points, we can have infinitely many polynomials which interpolate it. However, there exists a <strong>unique polynomial with degree</strong> \(\mathbf {\leq n}\). This result follows from the well-known theorem -</p> <p><strong><em>Theorem.</em></strong> A polynomial of degree \(n\) has at most \(n\) distinct zeroes.</p> <p><strong>Corollary.</strong> A polynomial with degree \(\leq n\) with \((n + 1)\) zeroes is the zero polynomial.</p> <h2 id="error-of-the-interpolating-polynomial">Error of the interpolating polynomial</h2> <p><strong><em>Theorem.</em></strong> Let \(f:[a,b] \to \mathbb R\) be \((n + 1)\)-times continuously differentiable. Let \(P(x)\) be the polynomial interpolating \(f\) at distinct \((n + 1)\) points \(x_0, x_1, \dots, x_n \in [a, b]\). Then, for each \(x \in [a, b]\), there exists \(\xi(x) \in (a, b)\) with</p> \[f(x) = P(x) + \frac{f^{(n + 1)}(\xi(x))}{(n + 1)!}(x - x_0)(x - x_1)\cdots (x - x_n)\] <blockquote> <p>How? Intuition?</p> </blockquote> <p>Using the above theorem, we can calculate the <u>maximum possible value of the absolute error</u> in an interval.</p> <p><strong>Note.</strong> While checking for extreme values in an interval, do not forget to check the value of the function at the edge of the interval!</p> <h1 id="lecture-12">Lecture 12</h1> <p><strong>Note.</strong> The value of \(\xi(x)\) for the error calculation depends on the point \(x\) at which error is being calculated.</p> <h3 id="practical-difficulties-with-lagrange-polynomials">Practical difficulties with Lagrange Polynomials</h3> <p>To use the error form, we need some information about \(f\) in order to find its derivative. However, this is often not the case. Also, the computations of the lower degree interpolating polynomials does not quite help the computations of the higher degree ones. We would like to find a method that helps in computing the interpolating polynomials cumulatively.</p> <h3 id="cumulative-calculation-of-interpolating-polynomials">Cumulative calculation of interpolating polynomials</h3> <p>Let us assume that \(f\) is given on distinct nodes \(x_0, x_1, \dots, x_n\). Now, the constant polynomial for the node \(x_0\) will be \(P_0(x) = f(x_0)\) and that for the node \(x_1\) will be \(Q_0(x) = f(x_1)\). Using Lagrange interpolation, we have</p> \[\begin{align} P_1(x) &amp;= \frac{x - x_1}{x_0 - x_1}f(x_0) + \frac{x - x_0}{x_1 - x_0}f(x_1) \\ &amp;= \frac{(x - x_1)P_0(x) - (x - x_0)Q_0(x)}{(x_0 - x_1)} \end{align}\] <p>Can we generalize this? Let us try to construct the quadratic polynomial. Now, suppose we have \(P_1(x)\) and $Q_1(x)$. The quadratic polynomial for the nodes \(x_0, x_1, x_2\) is given by,</p> \[\begin{align} P_2(x) &amp;= \frac{x - x_2}{x_0 - x_2}\left[\frac{x - x_1}{x_0 - x_1}f(x_0) + \frac{x - x_0}{x_1 - x_0}f(x_1)\right] \\ - &amp;\frac{x - x_0}{x_0 - x_2}\left[\frac{x - x_2}{x_1 - x_2}f(x_1) + \frac{x - x_1}{x_2 - x_1}f(x_2)\right] \\ \\ &amp;= \frac{(x - x_2)P_1(x) - (x - x_0)Q_1(x)}{x_0 - x_2} \end{align}\] <p>We shall see the general formula in the next lecture.</p> <h1 id="lecture-13">Lecture 13</h1> <p>Before we move on to the general formula, let us take the previous calculations one step further. Suppose we had to calculate the cubic polynomial in terms of the quadratic polynomials. The tedious way to do this is to expand each formula and substitute. We also have an easy way to do this. Recall the ‘unique polynomial’ theorem from last week. If we guess the formula of the cubic polynomial using induction, then all we have to do is check the value of the function at the 4 points which define it. If the value matches, then it is the polynomial we are looking for due to uniqueness.</p> <h2 id="nevilles-formula">Neville’s formula</h2> <p>Let \(f\) be defined on \(\{x_0, x_1, \dots, x_n\}\). Choose two distinct nodes \(x_i\) and \(x_j\). Let \(Q_i\) be the polynomial interpolating \(f\) on all nodes except \(x_i\), and let \(Q_j\) be the one interpolating \(f\) on all nodes except \(x_j\). If \(P\) denotes the polynomial interpolating \(f\) on all notes then</p> \[P(x) = \frac{(x - x_j)Q_j(x) - (x - x_i)Q_i(x)}{x_i - x_j}\] <p>In Neville’s formula we can get the interpolating for higher degree from any two polynomials for two subsets of nodes which are obtained by removing a single node. Through such cumulative calculations, we can calculate the interpolating polynomials up to a certain degree until we get the required accuracy. Neville’s method gives the values of the interpolating polynomials at a specific point, without having to compute the polynomials themselves.</p> <h2 id="divided-differences">Divided Differences</h2> <p>Given the function \(f\) on distinct \((n + 1)\) nodes, there is a unique polynomial \(P_n\) interpolating \(f\) on these nodes. We define \(f[x_0, \dots, x_n]\) to be the coefficient of \(x^n\) in \(P_n\). Now, it follows readily that the value of \(f[x_0, \dots, x_n]\) does not depend on the ordering of the nodes \(x_i\). Now, we shall try to get a recurrence formula for the coefficients \(f[x_0, \dots, x_n]\).</p> <p>Let \(P_{n - 1}\) and \(Q_{n - 1}\) be the polynomials interpolating \(f\) on the nodes \(x_0, \dots, x_{n - 1}\) and \(x_1, \dots, x_n\) respectively. We can get \(P_n\) from these two polynomials using Neville’s method. The coefficient of \(x^n\) in \(P_n\) is then</p> \[\frac{\text{coefficient of } x^{n - 1} \text{ in } Q_{n - 1} - \text{coefficient of } x^{n - 1} \text{ in } P_{n - 1}}{x_n - x_0} \\ = \frac{f[x_1, \dots, x_n] - f[x_0, \dots, x_{n - 1}]}{x_n - x_0}\] <p>Also note that for \(i &lt; n, P_n(x_i) = P_{n - 1}(x_i)\). That is, \(P_n - P_{n - 1} = \alpha(x - x_0)\dots (x - x_{n - 1})\) where \(\alpha\) is a real number. Hence, \(f[x_0, \dots, x_n] = \alpha\) and we have</p> \[P_n = P_{n - 1} + (x - x_0)\dots (x - x_{n - 1})f[x_0, \dots, x_n]\] <p>This formula is known as Newton’s finite differences formula.</p> <h1 id="lecture-14">Lecture 14</h1> <p>We have</p> \[P_n - P_{n - 1} = f[x_0, \dots, x_n](x - x_0)\dots (x - x_{n - 1}) \\ \\ f[x_0, \dots, x_n] = \frac{f[x_1, \dots, x_n] - f[x_0, \dots, x_{n - 1}]}{x_n - x_0}\] <p>Since the order of the nodes does not matter, we can traverse the recursion in a forward/backward manner. The forward formula is given by,</p> \[P_n(x) = f(x_0) + f[x_0, x_1](x - x_0) + f[x_0, x_1, x_2](x - x_0)(x - x_1) + \\ \cdots + f[x_0, x_1, \dots, x_n](x - x_0)\cdots (x - x_{n - 1})\] <p>The backward formula simply replaces \(i\) by \(n - i\) for \(i \in [0, \dots, n]\). For clarity, look at the following example.</p> <p><img src="/assets/img/Numerical%20Analysis/image-20220127150002932.png" alt="image-20220127150002932"></p> <h3 id="nested-form-of-the-interpolating-polynomial">Nested form of the interpolating polynomial</h3> \[P_n(x) = f(x_0) + (x - x_0)\big[f[x_0, x_1] + (x - x_1)[f[x_0, x_1, x_2] + \\ \cdots + (x - x_{n - 1})f[x_0, \dots, x_n]\big]\] <p>Neste form of the interpolating polynomial is useful for computing the polynomials \(P_n\) effectively.</p> <h3 id="divided-differences-as-a-function">Divided differences as a function</h3> <p>We now give a definition of the divided differences when some of the nodes may be equal to each other. By the Mean Value Theorem, \(f[x_0, x_1] = f’(\xi)\) for some \(\xi\) between \(x_0\) and \(x_1\). In fact, we also have the following theorem,</p> <p><strong><em>Theorem.</em></strong> If \(f\) is \(n\)-times continuously differentiable on \([a, b]\) then</p> \[f[x_0, \dots, x_n] = \frac{f^{(n)}(\xi)}{n!}\] <p>for some \(\xi \in [a, b]\).</p> <p>Since \(f[x_0, x_1] = f'(\xi)\) for some \(\xi\) between \(x_0\) and \(x_1\), we define \(f[x_0, x_0] = f’(x_0) = \lim_{x_1 \to x_0}f[x_0, x_1]\). Similarly, we define \(f[x_0, \dots, x_n]\) in a similar way using limits. For instance,</p> \[f[x_0, x_1, x_0] = \frac{f[x_0, x_1]- f'(x_0)}{x_1 - x_0}\\ f[x_0, x_0, x_0] = f^{(2)}(x_0)/2\] <p>We have thus defined \(f[x_0, \dots, x_n]\) in general. Now, by letting the last \(x_n\) as variable \(x\), we get a function of x: \(f[x_0, \dots, x_{n - 1}, x]\). This function is continuous.</p> \[f[x_0, x] = \begin{cases} \frac{f(x) - f(x_0)}{x - x_0} &amp; x \neq x_0 \\ f'(x_0) &amp; x = x_0 \end{cases}\] <h1 id="ma214-post-midsem-notes">MA214 post-midsem notes</h1> <ul> <li> <p><strong>Composite numerical integration</strong> - Newton-Cotes doesn’t work for large intervals. Therefore, we divide the interval into sub-parts. We are essentially doing a spline sorta thing instead of a higher degree polynomial. \(\begin{align} \int_a^b f(x)dx &amp;= \sum_{j = 1}^{n/2} \left\{\frac{h}{3}[f(x_{2j - 2} + 4f(x_{2j - 1} + f(x_{2j}] - \frac{h^5}{90}f^{(4)}(\xi_j)\right\} \\ &amp;= \frac{h}{3}\left[f(a) + 2\sum_{j = 1}^{n/2 - 1}f(x_{2j}) + 4\sum_{j = 1}^{n/2}f(x_{2j - 1}) + f(b)\right] - \frac{b - a}{180}h^4f^{(4)}(\mu) \end{align}\)</p> </li> <li> <p>Error in composite trapezoidal rule is \(\frac{b - a}{12}h^2f''(\mu)\), and in composite Simpson’s rule is \(\frac{b - a}{180}h^4f''(\mu)\).</p> </li> <li> <p>The round-off error does not depend on the number of calculations in the composite methods. We get \(e(h) \leq hn\epsilon = (b - a)\epsilon\) Therefore, integration is stable.</p> </li> <li> <p><strong>Adaptive Quadrature method</strong> - \(S(a, b) - \frac{h^5}{90}f^{(4)}(\xi) \approx S(a, \frac{a+ b}{2}) + S(\frac{a + b}{2}, b) - \frac{1}{16}\frac{h^5}{90}f^{(4)}(\xi')\) <strong>We will assume \(f^{(4)}(\xi) \approx f^{(4)}(\xi’)\).</strong> Using this assumption, we get that composite Simpson’s rule with \(n = 2\) is <strong>15</strong> times better than normal Simpson’s rule. If one of the subintervals has error more than \(\epsilon/2\), then we divide it even further.</p> <blockquote> <p>Check this properly!</p> </blockquote> </li> <li> <p><strong>Gaussian Quadrature method</strong> -</p> <p>Choose points for interval in an optimal way and not equally spaced. We choose \(x_i\) and \(c_i\) to minimise the error in \(\int_a^bf(x)dx \approx \sum_{i = 1}^nc_if(x_i)\) There are \(2n\) parameters, then the largest class of polynomials is the set of polynomials with degree \(2n - 1\) for the approximation to be exact.</p> <p><strong>Note.</strong> Work with special cases of polynomials like \(1, x, x^2, \dots\) to get the values of the coefficients easily. (because all polynomials in the set must satisfy the approximation)</p> <p><strong>Legendre polynomials</strong> - There exist polynomials \(\{P_n(x)\}\) for \(n = 0, 1, \dots\)satisfying</p> <ul> <li>\(P_n(x)\) is a monic polynomials</li> <li>\(\int_{-1}^1P(x)P_n(x) = 0\) whenever the degree of \(P(x)\) is less than \(n\).</li> </ul> <p>For example, \(P_0(x) = 1, P_1(x) = x\). \(P_2\) can be computed from \(P_0\) and \(P_1\) as \(\int P_0P_2\) and \(\int P_1P_2\) are 0.</p> <p><img src="/assets/img/Numerical%20Analysis/image-20220323155057163.png" alt="image-20220323155057163"></p> </li> <li> <p><strong>Multidimensional integrals</strong> - Composite trapezoidal rule has square of the number of function evaluations required for a single integral (for 2D).</p> <p><img src="/assets/img/Numerical%20Analysis/image-20220323161302337.png" alt="image-20220323161302337"></p> <blockquote> <p>See if problems to be practiced here.</p> </blockquote> </li> <li> <p><strong>Improper integrals</strong> - Function is unbounded or the interval is unbounded. We will deal with functions where the function is unbounded on the left end.</p> </li> <li> <blockquote> <p><strong><em>Aside.</em></strong> \(a^b\) is defined as \(\exp(b \log a)\) in the complex domain. \(\log\) is not defined as the inverse of \(\exp\) as \(\exp\) is neither surjective (doesn’t take the value 0) nor injective (periodic in \(\mathbb C\)). \(\exp\) is defined by the power series and so is \(\log\). The solution set of \(z\) for \(e^z = w\) where \(z, w \in \mathbb C\) is given by \(\{\log |w| + \iota(\arg w + 2\pi k) : k \in \mathbb Z\}\)</p> </blockquote> <p>If \(f(x) = \frac{g(x)}{(x - a)^p}\) where \(0 &lt; p&lt; 1\) and \(g: [a,b] \to \mathbb R\) is continuous then the improper integral \(\int_a^b f(x)dx\) exists. Assume \(g\) is 5-times continuously differentiable. We can estimate the integral of \(f(x)\) using the following</p> <ul> <li>Get \(P_4(x)\) which is the 4th degree Taylor’s polynomial of \(g\).</li> <li>Get the <strong>exact</strong> value of \(\int_a^b P_4(x)/(x - a)^p\).</li> <li>Get the value of the difference by defining the value at \(z = a\) as \(0\) using composite Simpson’s rule.</li> </ul> <blockquote> <p>Why can’t we do Simpson’s on everything? That would lead to a similar thing. <em>Think</em>. Also, we require 4 times continuously differentiable for Simpson’s</p> </blockquote> <p>The other type of improper integral involves infinite limits of integration. The basic integral is of the type \(\int_a^\infty 1/x^p dx\) for \(p &gt; 1\). Then, we substitute \(x = 1/t\) and proceed.</p> </li> <li> <p><strong><em>Ordinary Differential Equations</em></strong> We shall develop numerical methods to get solutions to ODEs at a given point. Then, we can use interpolation to get an approximate continuous solution.</p> <p>A function \(f(t, y)\) is said to satisfy a <strong>Lipschitz condition</strong> in the variable \(y\) on a set \(D \subset \mathbb R^2\) if a constant \(L &gt; 0\) exists with \(\mid f(t, y_1) - f(t, y_2) \mid \leq L\mid y_1 - y_2 \mid\) <img src="/assets/img/Numerical%20Analysis/image-20220323191549861.png" alt="image-20220323191549861"></p> <p>IVP is well-posed if it has a unique solutions, and an IVP obtained by small perturbations also has a unique solution. We consider IVPs of the form \(dy/dt = f(t, y)\), \(a \leq t \leq b\), \(y(a) = \alpha\).</p> <p><img src="/assets/img/Numerical%20Analysis/image-20220323193242124.png" alt="image-20220323193242124"></p> </li> <li> <p><strong>Euler’s method</strong> - We generate <em>mesh points</em> and interpolate. As we are considering IVPs of a certain form, we can just use 1st degree Taylor’s polynomial to approximate the solution to the IVP. We take \(q_0 = \alpha\) and \(w_{i + 1} = w_i + hf(t_i, w_i)\) for \(i \geq 0\) where \(w_i \approx y(t_i)\). The error grows as \(t\) increases, but it is controlled due to the stability of Euler’s method. It grows in a linear manner wrt to \(h\).</p> </li> <li> <p><u>Error in Euler’s method</u> - Suppose \(\mid y''(t) \mid \leq M\), then \(\mid y(t_i) - w_i \mid \leq \frac{hM}{2L}(\exp (L(t_i - a)) - 1)\). What about round-off errors? We’ll get an additional factor of \(\delta/hL\) in the above expression along with the constant \(\delta_0 \exp (L(t_i - a))\). Therefore, \(h = \sqrt(2\delta/M)\).</p> </li> <li> <p><strong>Local truncation error</strong> - <strong>\(\tau_{i + 1}(h) = \frac{y_{i + 1} - y_i}{h} - \phi(t_i, y_i)\).</strong> It is just \(hM/2\) for Euler’s method (\(\phi\) refers to the Taylor polynomial). We want truncation error to be as \(\mathcal O(h^p)\) for as large \(p\) as possible.</p> <p><strong>Higher order Taylor methods</strong> - Assume \(f\) is \(n\)-times continuously differentiable. We get \(\mathcal O(n)\) for \(n\)th degree Taylor polynomial. However, the number of computations are a bit high.</p> <blockquote> <p>Practice problems on this</p> </blockquote> </li> <li> <p>What about interpolation? We should use cubic Hermite interpolation (to match the derivative too).</p> </li> <li> <p>Now, we try to reduce the computation of higher order derivatives. <strong>Runge-Kutta methods</strong> - Based off Taylor’s theorem in two variables.</p> <p><img src="/assets/img/Numerical%20Analysis/image-20220323210229698.png" alt="image-20220323210229698"></p> <p>Order 2- We get \(a = 1, \alpha = h/2, \beta = f(t, y)h/2\) by equating \(af(t + \alpha, y + \beta)\) to \(T(t, y) = f(t, y) + h/2 f'(t, y)\). This specific Runge-Kutta method of Order 2 is known as the <strong>midpoint-method</strong>. (2D of Taylor order 2) \(w_{i + 1} = w_i + hf\left(t_i + \frac{h}{2}, w_i + \frac h 2 f(t_i, w_i)\right)\) The number of nesting \(f\)‘s represents the order of the differential equation.</p> <p>Suppose we try the form \(a_1f(t, y) + a_2 f(t + \alpha_2, y + \delta_2 f(t, y))\) containing 4 parameters to approximate. We still get \(\mathcal O(n^2)\) as there is only one nesting.</p> </li> <li> <p>However, the flexibility in the parameters allows us to derive the <strong>Modified Euler method</strong>. \(w_{i + 1} = w_i + \frac h 2[f(t_i, w_i) + f(t_{i + 1}, w_i + hf(t_i, w_i))]\) <strong>Higher-order Runge-Kutta methods</strong> - The parameter values are used in the <strong>Heun’s method</strong>.</p> <p><img src="/assets/img/Numerical%20Analysis/image-20220323212528107.png" alt="image-20220323212528107"></p> <p>The most common Runge-Kutta is order 4 whose local truncation error is \(\mathcal O(n^4)\).</p> <p><img src="/assets/img/Numerical%20Analysis/image-20220323212907583.png" alt="image-20220323212907583"></p> </li> <li> <p><u>Error control in Runge-Kutta methods</u>. Adaptive step size for lower error. Single step approximation - uses \(i-\) for \(i\). Given an \(\epsilon &gt; 0\), we need to be able to give a method that gives \(\mid y(t_i) - w_i\mid &lt; \epsilon\). \(y(t_{i + 1}) = y(t_i) + h\phi(t_i, y(t_i), h) + \mathcal O(h^{n + 1}) \\\) Local truncation error assumes \(i\)th measurement is correct to find error in the \(i + 1\)th measurement. We get \(\tau_{i + 1}(h) \approx \frac 1 h (y(t_{i + 1}) - w_{i + 1})\) assuming \(y_i \approx w_i\). For \(n\)th degree truncation error, we get \(\tau_{i + 1}(h) \approx \frac 1 h (w^{n + 1}_{i + 1} - w^{n}_{i + 1})\). After a few approximations, we get that the local truncation error changes by a factor of \(q^n\) when the step size changes by a factor of \(q\).</p> </li> <li> <p><strong>Runge-Kutta-Fehlberg Method</strong> - It uses a Runge-Kutta method with local truncation error of order five. We change the step size if \(q &lt; 1\). These methods are just an analogue of adaptive quadrature methods of integrals.</p> </li> <li> <p><strong>Multi-step methods</strong>. Methods that use the approximation at more than one previous mesh point to determine the approximation at the next point. The general equation is implicit where \(w_{i + 1}\) occurs on both sides of the equation. Implicit methods are more accurate than explicit methods.</p> <p><img src="/assets/img/Numerical%20Analysis/image-20220324124220485.png" alt="image-20220324124220485"></p> </li> <li> <p><strong>Predictor-Corrector Method</strong> - How do we solve implicit methods? We can use the root-finding procedures we learnt. All of this can get quite cumbersome. We just use implicit methods to improve the prediction of the explicit methods. We insert the solution of explicit method (prediction) and insert it on the rhs of the implicit method (correction).</p> </li> <li> <p><strong>Consistency and Convergence</strong></p> <p>One-step difference method is <strong>consistent</strong> if \(\lim_{h \to 0}\max_{1 \leq i \leq n}\mid \tau_i(h)\mid = 0\). But we also need the global measure - <strong>convergence</strong> - \(\lim_{h \to 0}\max_{1 \leq i \leq n}\mid y_i(t_i) - w_i\mid = 0\)</p> <p><strong>stability</strong> considering round-off errors. For the function \(\phi\) satisfying Lipschitz condition with a \(h_0\), the one-step difference method <strong>is convergent iff it is consistent</strong>. The local truncation error is bounded, and we get \(\mid y(t_i) - q_i \mid \leq \frac {\tau(h)}{L}e^{L(t_i - a)}\).</p> <p>Analysis of consistency, convergence, and stability is difficult for multi-step methods. Adams-* methods are stable.</p> </li> <li> <p><strong><em>Numerical Linear Algebra</em></strong> - Basics - \(Ax = b\) has a unique solution iff \(A\) is invertible, and it does not have a unique or has no solution otherwise.</p> <p><strong>Cramer’s rule</strong> - \(x_j = \frac{\det A_j}{\det A}\). However, this is cumbersome. Determinant of an upper triangular matrix is product of the diagonal entries.</p> <p><strong>Gaussian Elimination Method</strong> - \(A = LU\) for most matrices \(A\). \(L\) is a lower triangular matrix and \(U\) is an upper triangular matrix. Form the augmented matrix \([ A \mid b]\). Linear combination of rows and swapping of rows can be performed. What is the total number of arithmetic operations?</p> <p>For converting to triangular - We use \((n - i)\) divisions for each row and \((n - i + 1)\) multiplications for each column of each row. Also, we have \((n - i)(n - i + 1)\) subtractions. In total, we have \((n - i)(n - i + 2)\) multiplications. Summing, we get \(\mathcal O(n^3)\) multiplications (\((2n^3 + 3n^2 - 5n)/6\)) and subtractions \(((n^3 - n)/3)\).</p> <p>For back substitution - multiplication is \((n^2 + n)/2\) and subtraction is \((n^2 - n)/2\).</p> </li> <li> <p>We have not considered finite digit arithmetic for GEM previously. The error dominates the solution when the pivot has a low absolute value. In general, we need to ensure that the pivot does not have very low magnitude by interchanging rows (followed by interchanging columns for triangular form if needed) - <strong>partial pivoting</strong>. However, this might not be enough to get rid of the rounding error. Therefore, we need to consider <strong>scaled partial pivoting</strong>. Define \(s_i\) as the maximum magnitude in the \(i\)th row. Now, the first pivot is chosen by taking the row with the maximum value of \(a_{i1}/s_i\). The operation count order still remains the same. You need not calculate scale factors more than once.</p> </li> <li> <p><strong>LU Decomposition</strong> - The conversion of \(A\) to a triangular form using the above method can be represented as a sequence of matrix multiplications (if \(A\) does not require any row interchanges). The inverse of a matrix depicting operations on \(A\) can be seen a matrix depicting the same inverse operations on \(A\). In the end, we get \(A = (L^{(1)} \dots L^{(n - 1)})(M^{(1)}\dots M^{(n-1)}A)\) where each \(M^{(i)}\) represents the action that uses \(A_{ii}\) as a pivot. Once we get \(L\) and \(U\), we can solve \(y = Ux\) and \(Ly = b\) separately. There are multiple decompositions possible which are eliminated by imposing conditions on the triangular matrices. One such condition is setting \(L_{ii} = U_{ii}\) which is known as <em>Cholesky Decomposition</em>.</p> <p>We had assumed that row interchanges are not allowed. However, we can build <strong>permutation matrices</strong> for row interchanges which will be of the form of an identity matrix with row permutations.</p> <p>Therefore, we get <strong>PLU decomposition</strong>.</p> </li> <li> <p><strong>Diagonally dominant matrices</strong> - An \(n \times n\) matrix \(A\) is said to be diagonally dominant when \(\mid a_{ii} \mid \geq \sum^n \mid a_{ij} \mid\) for all rows. <u>A strongly diagonally dominant matrix is invertible</u>. Such matrices will not need row interchanges, and the computations will be stable wrt the round off errors.</p> <blockquote> <p>Why this instead of \(\mid a_{ii} \mid \geq \max \mid a_{ij} \mid\)</p> </blockquote> <p>A matrix \(A\) is <strong>positive definite</strong> if \(x^tAx &gt; 0\) for every \(x \neq 0\). We shall also consider \(A\) to be symmetric in the definition. Every positive definite matrix is invertible, \(A_{ii} &gt; 0\) for each \(i\), \((A_{ij})^2 &lt; A_{ii}A_{jj}\), and \(\max_{1\leq k, j \leq n} \mid A_{kj} \mid \leq \max_{1 \leq i \leq n}\mid A_{ii}\mid\).</p> <p>A <strong>leading principal submatrix</strong> of matrix \(A\) is the top-left \(k \times k\) submatrix of \(A\). \(A\) <u>is positive definite iff each leading principal submatrix of</u> \(A\) <u> has a positive determinant.</u></p> <p>Gaussian Elimination on a symmetric matrix can be applied without interchanging columns iff the matrix is positive definite.</p> <p>A matrix \(A\) is positive definite iff \(A = LDL^t\) where \(L\) is lower triangular with 1’s on the diagonal and \(D\) is a diagonal matrix with positive diagonal entries. Alternatively, \(A\) is positive dfinite iff \(A = LL^t\) where \(L\) is a lower triangular matrix. <strong>Note.</strong> Positive definite is stronger than Cholesky decomposition.</p> </li> <li> <p>We have been seeing direct methods for solving \(Ax = b\). We shall see some iterative methods now. We need a distance metric to check the closeness of the approximation. We will consider \(l_2\) distance = \(\| x - y\|_2 = \left( \sum_{i = 1}^n (x_i - y_i)^2 \right)^{1/2}\) and \(l_\infty\) distance = \(\| x - y\|_2 = \max_{i = 1}^n \mid x_i - y_i \mid\). Also, \(\|x - y\|_\infty \leq \|x - y\|_2 \leq \sqrt n\|x - y\|_\infty\). We also need to consider distances in matrices.</p> </li> <li> <p><strong>Distances in Matrices</strong> - \(\|A\|_2 = \max_{\|x\|_2 = 1} \|Ax\|_2\) and \(\|A\|_\infty = \max_{\|x\|_\infty = 1} \|Ax\|_\infty\). The \(l_\infty\) can be directly calculated using \(\|A\|_\infty = ]max_{i} \sum_j \mid A_{ij} \mid\).</p> </li> <li> <p><strong>eigenvalues, eigenvectors</strong> - A <strong>non-zero</strong> vector \(v \in \mathbb R^n\) is an eigenvector for \(A\) if there is a \(\lambda \in \mathbb R\) such that \(Av = \lambda v\) and \(\lambda \in \mathbb R\) is the eigenvalue. The <strong>characteristic polynomial</strong> of \(A\) is \(\det(A - \lambda I)\). We do not consider the complex roots that are not real for these polynomials to calculate eigenvalues.</p> <p><strong>Spectral radius</strong> - \(\rho(A) = \max \mid \lambda \mid\). Then, we have the relation that \(\|A\|_2 = [\rho(A^tA)]^{1/2}\) and also \(\rho(A) \leq \|A\|_2\) and \(\rho(A) \leq \|A\|_\infty\).</p> <p><strong>Convergent matrices</strong> - It is of particular importance to know when powers of a matrix become small, that is, when all the entries approach zero. An \(n \times n\) matrix \(A\) is called convergent if for each \(1 \leq i, j \leq n\), \(\lim_{k \to \infty}(A^k)_{ij} = 0\).</p> <ul> <li>\(A\) is a convergent matrix</li> <li> \[\lim_{n \to \infty} \|A^n\|_2 = 0\] </li> <li> \[\lim_{n \to \infty} \|A^n\|_\infty = 0\] </li> <li> \[\rho(A) &lt; 1\] </li> <li>\(\lim_{n \to \infty} A^nv =0\) for every vector \(v\).</li> </ul> <p>The above statements are all equivalent.</p> </li> <li> <p>Iterative techniques are not often used for smaller dimensions. We will study <strong>Jacobi</strong> and the <strong>Gauss-Seidel</strong> method.</p> <p><strong>Jacobi Method</strong> - We assume that \(\det(A)\) being non-zero (as matrix must be invertible for solution) and the diagonal entries of \(A\) are also non-zero. We have</p> <p>Jacobi suggested that we start with an initial vector \(x^{(0)} = [x_1^{(0)}, \dots, x_n^{(0)}]\) and for \(k \geq 1\)</p> \[x_i^{(k)} = \frac{b_i - \sum_{j \neq i} a_{ij}x_j^{(k - 1)}}{a_{ii}}\] <p>The error in the iterations is given by</p> \[\mid x_i - x_i^{(k)} \mid \leq (\sum_{j \neq i} \frac{a_{ij}}{a_{ii}})\|x_j - x_j^{(k - 1)}\|_\infty\] <p>which gives</p> \[\| x - x^{(k)} \|_\infty \leq (\max_i \sum_{j \neq i} \frac{a_{ij}}{a_{ii}})\|x_j - x_j^{(k - 1)}\|_\infty\] <p>If \(\mu = \max{i}\sum_{j \neq i} \frac{a_{ij}}{a_{ii}} &lt; 1\), then convergence is guaranteed. If \(\mu &lt; 1\), then the condition is nothing but that of strictly diagonally dominant matrices.</p> <p><strong>Gauss-Seidel method</strong> - The idea is that once we have improved one component, we use it to improve the component of the next component and so on.</p> \[x_i^{(k)} = \frac{1}{a_{ii}} \left[b_i - \sum_{j = 1}^{i - 1}a_{ij}x_j^{(k)} - \sum_{j = i + 1}^n a_{ij}x_j^{(k - 1)}\right]\] <p>There are linear systems where Jacobi method converges but Gauss-Seidel method does not converge. If \(A\) is strictly diagonally dominant, then both methods converge to the true solution.</p> </li> <li> <p><strong>Residual vector</strong> - If \(\tilde x\) is an approximation to \(Ax = b\), then \(r = b - A\tilde x\) is the residual vector. However, it is not always true that when \(\|r \|\) is small then \(\|x - \tilde x\|\) is also small. This is because \(r = A(x - \tilde x)\), and that represents the affine transformation of space. This phenomenon is captured as follows</p> <p>For a non-singular \(A\), we have</p> \[\|x - \tilde x\|_\infty \leq \|r \|_\infty \cdot \|A^{-1}\|_\infty\] <p>If \(x \neq 0\) and \(b \neq 0\)</p> \[\frac{\|x - \tilde x \|_\infty}{\|x\|_\infty} \leq \|A\|_\infty\cdot \|A^{-1}\|_\infty \cdot \frac{\|r\|_\infty}{\|b\|_\infty}\] <p>These relations work for \(l_2\) norm too.</p> <blockquote> <p>I think \(\|A\|_\infty \|x\|_\infty \geq \|b\|_\infty\)</p> </blockquote> <p>The <strong>condition number</strong> of a non-singular matrix \(A\) is</p> \[K(A) = \|A\|_\infty \cdot \|A^{-1}\|_\infty\] <p>Also, \(\|AA^{-1}\|_\infty \leq \|A\|_\infty \|A^{-1}\|_\infty\). A non-singular matrix \(A\) is said to be <strong>well-conditioned</strong> if \(K(A)\) is close to 1.</p> <p>However, the condition number depends on the round-off errors too. The effects of finite-digit arithmetic show up in the calculation of the inverse. As the calculation of inverse is tedious, we try to calculate the condition number without the inverse. If we consider \(t\)-digit arithmetic, we approximately have</p> \[\|r\|_\infty \approx 10^{-t}\|A\|_\infty \cdot \|\tilde x \|_\infty\] <p>One drawback is that we would have to calculate \(r\) is double precision due to the above relation. The approximation for \(K(A)\) comes from \(Ay = r\). Now, \(\tilde y \approx A^{-1}r = x - \tilde x\). Then,</p> \[\|\tilde y\| \leq \|A^{-1}\| \cdot (10^{-t}\cdot \|A\| \|\tilde x\|)\] <p>Using the above expression, we get</p> \[K(A) \approx \frac{\|\tilde y\|}{\|\tilde x\|}10^t\] <p>The only catch in the above method is that we need to calculate \(r\) in \(2t\)-finite arithmetic.</p> <p><strong>Iterative refinement</strong> - As we had defined \(\tilde y = x - \tilde x\), in general, \(\tilde x + \tilde y\) is more accurate. This is called as iterative improvement. If the process is applied using \(t\)-digit arithmetic and if \(K(A) \approx 10^q\), then after \(k\) iterations, we have approximately \(\min(t, k(t - q))\) correct digits. When \(q&gt; t\), increased precision must be used.</p> </li> <li> <p><strong>Approximations for eigenvalues</strong></p> <p><strong>Gerschgorin theorem</strong> - We define discs \(D_i = \left\{ z \in \mathbb C: \mid z - a_{ii} \mid \leq \sum_{j \neq i} \mid A_{ij} \mid \right\}\). Then, all eigenvalues of \(A\) are contained in the union of all the disks \(D_i\). The union of any \(k\) of the disk that do not intersect the remaining \(n - k\) disks contains precisely \(k\) of the eigenvalues including the multiplicity. From this theorem, we get that strictly diagonally dominant matrices are invertible. This is also true for strictly diagonally column dominant matrices.</p> <p>The above theorem provides us the initial approximations for the eigenvalues. We shall see the Power method.</p> <p><strong>Power method</strong> - We assume \(\mid \lambda_1 \mid &gt; \mid \lambda_2 \mid \geq \dots \geq \mid \lambda_n \mid\), and that \(A\) has \(n\) linearly independent eigenvectors. Choose a non-zero \(z \in V\), and compute</p> \[\lim_{k \to \infty} A^k z\] <p>to get the eigenvalue! (Think of vector space transformations geometrically).</p> <p>If \(z = \sum \alpha_i v_i\), we get</p> \[A^k z = \lambda^k_1 \alpha_1 v_1 + \dots + \lambda^k_n \alpha_n v_n = \lambda_1^k \alpha_1 v_1\] <p>for high values of \(k\).</p> <p>Sometimes, \(z\) may not have the component of \(v_1\). We choose a vector such that this is not the case.</p> <p>Sometimes, it may also be the case that</p> <p>\(\mid \lambda_1 \mid \geq \mid \lambda_2 \mid \geq \dots &gt; \mid \lambda_n \mid &gt; 0\). \(A\) is invertible iff this holds. Then, we use the power method on \(A^{-1}\).</p> <p>Sometimes, \(\mid \lambda_1 \mid &lt; 1\) and we’ll converge to 0. On the other hand, if it is more than 1, the limit will shoot to infinity. To take care of these, we scale \(A^k(z)\), so that it is finite and non-zero.</p> <p>Firstly, we choose \(z\) such that \(\|z^{(0)}\| = 1\) and we choose a component \(p_0\) of \(z^{(0)}\) such that \(\mid z_{p_0}^{(0)} \mid = 1\). Following this, we scale each subsequent value as follows - Let \(w^{(1)} = Az^{(0)}\) and \(\mu^{(1)} = w_{p_0}^{(1)}\).</p> \[\mu^{(1)} = \lambda_1 \frac{\alpha_1(v_1)_{p_0} + \dots + (\lambda_n/ \lambda_1) \alpha_n (v_n)_{p_0}}{\alpha_1(v_1)_{p_0} + \dots + \alpha_n (v_n)_{p_0}}\] <p>Now, we choose \(p_1\) to be the least integer with \(\mid w_{p_1}^{(1)}\mid = \|w^{(1)}\|\) and define \(z^{(1)}\) by</p> \[z^{(1)} = \frac{1}{w_{p_1}^{(1)}} Az^{(0)}\] <p>Then, in general,</p> \[\mu^{(m)} = w_{p_{m - 1}}^{(m)} = \lambda_1 \frac{\alpha_1(v_1)_{p_0} + \dots + (\lambda_n/ \lambda_1)^m \alpha_n (v_n)_{p_0}}{\alpha_1(v_1)_{p_0} + \dots + (\lambda_n/ \lambda_1)^{m - 1}\alpha_n (v_n)_{p_0}}\] <p>Now, \(\lim_{m \to \infty} \mu^{(m)} = \lambda_1\).</p> <p>To find other eigenvalues, we use <strong>Gram-Schmidt orthonormalisation</strong>.</p> <p><img src="/assets/img/Numerical%20Analysis/image-20220415200748597.png" alt="image-20220415200748597"></p> </li> </ul> <hr> <h4 id="end-of-course">END OF COURSE</h4> <hr> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/ipl/">IPL Notes</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/dbms/">DiBS Notes</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/automata/">Automata Notes</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/operating-systems/">Operating System Notes</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/philosophy/">Philosophy Notes</a> </li> </div> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Sudhansh Peddabomma. Last updated: January 22, 2024. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?9b43d6e67ddc7c0855b1478ee4c48c2d" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-0K9MLG0V24"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-0K9MLG0V24");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>