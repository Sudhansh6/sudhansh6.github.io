<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Design and Analysis of Algorithms | Sudhansh Peddabomma </title> <meta name="author" content="Sudhansh Peddabomma"> <meta name="description" content="A collection of ideas for design algorithms and analyzing them."> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%91%BE&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://sudhansh6.github.io/blog/Design-and-Analysis-of-Algorithms/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> <script src="/assets/js/chat.js?e73db4280bae3cbae4d78219277155b9"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Sudhansh Peddabomma </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Articles </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"> </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/challenges/">Challenges</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/misc/">Miscellaneous</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Design and Analysis of Algorithms</h1> <p class="post-meta"> Created in September 27, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/category/notes"> <i class="fa-solid fa-tag fa-sm"></i> Notes</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h1 id="greedy-algorithms">Greedy Algorithms</h1> <h2 id="minimum-spanning-tree">Minimum Spanning Tree</h2> <p>Consider a graph \(G\) describe by \(V\) and \(E\) (positive weights). A <strong>spanning tree</strong> of a graph is defined as an edge set \(T \subset E\) such that \((V, T)\) is a tree. A minimum spanning tree is such that \(\sum_{l \in T} l_e\) is minimized.</p> <p>For a graph with \(n\) vertices, there are \(n^{n - 2}\) spanning trees for a complete graph (<strong>Cayley’s formula</strong>).</p> <p>How do we calculate the number of spanning trees for a general graph? <strong>Kirchoff’s theorem</strong> states the following -</p> <ul> <li>Let \(M\) be the adjacency matrix of \(G\)</li> <li>Let \(L - M\) except \(L_{i, i} = -deg(i)\) - This is generally called as <strong>Graph Laplacian</strong> </li> <li>Then, #spanning trees is the determinant of any \(m-1\) square sub-matrix (obtained by removing \(i\)th row and column) of \(L\).</li> </ul> <p>Notice how any sub-matrix yields the same value!</p> <h2 id="greedy-idea-1-kruskals-algorithm">Greedy Idea 1: Kruskal’s algorithm</h2> <ul> <li>Sort all the edges with their weights</li> <li>Pick edges as long as they don’t form a cycle</li> </ul> <p>Does this work? If it does, how do we prove it?</p> <p>Firstly, why is it a greedy idea? At each point of the algorithm, we select the current greedy edge (a local minimum) to obtain the minimum spanning tree (a global optimum).</p> <ul> <li> <p><strong>The cut property -</strong> Let \(S \subseteq V\) such that \(S\) and \(V - S\) are non-empty. If \(e\) is an edge across \(S\) and \(V - S\) with the minimum cost, then there always exists a minimum spanning tree with \(e\).</p> <p><strong>Proof.</strong> Exchange argument. If there an MST with \(e’\) across \(S\) and \(V - S\), then replace \(e\) with \(e’\) to obtain another MST.</p> <blockquote> <p>Shouldn’t this argument be more delicate? Why is there a single edge from S to V - S?</p> </blockquote> <p>Essentially, the exchange argument argues replacing a part of the solution improves the solution but does not worsen it.</p> </li> <li> <p>The time complexity of the algorithm comes out to be \(O(m \log m + m \alpha(n))\). The second term in the expression comes from union-find data structures.</p> </li> <li> <p><strong>Correctness of the algorithm</strong> - We shall prove this via induction.</p> <ul> <li>Induction hypothesis - The edges selected in the \(i\)th round of Kruskal’s algorithm can form an MST along with a subset of edges from the remaining edges.</li> <li>Base statement - True for \(i = 0\)</li> <li>Induction step - Cut property</li> </ul> </li> <li> <p><strong>Union-find data structure</strong> - A data structure that supports</p> <ul> <li>Merging elements of two sets into a single set - <code class="language-plaintext highlighter-rouge">union(x, y)</code> </li> <li>Checking whether two elements are in the same set - <code class="language-plaintext highlighter-rouge">find(x)</code> </li> </ul> <p>efficiently. The amortized time complexity for these operations is \(\alpha(n)\) where \(\alpha(n) \leq 4\) for \(n\) of the order \(2^{2^{2^{2^{16}}}}\). As a result, \(\alpha(n)\) can be regarded as a constant for practical purposes.</p> <p>In our case, the elements are edges and sets represent connected components.</p> </li> </ul> <h2 id="greedy-idea-2-prims-algorithm">Greedy Idea 2: Prim’s Algorithm</h2> <p>Start with any node and expand with the smallest edge connecting to the remaining set of edges. Note that this is different from Kruskal’s algorithm where we sort all the edges and create individual connected components that eventually merge together.</p> <p>The proof for Prim’s algorithm is very similar to that of Kruskal’s. The time complexity is \(O(n^2 + m)\) similar to Djikstra’s algorithm without a data structure. We can maintain a <strong>priority queue</strong> to maintain all edges that come from \(S\) to reduce the time-complexity to \(O((n + m) \log m)\) (without decrease-key). With decrease key and a binary heap, the complexity becomes \(O((n + m) \log n)\). Furthermore, with decrease key and a Fibonacci heap, the complexity reduces to \(O((n\log n + m)\).</p> <h2 id="other-algorithms">Other algorithms</h2> <ul> <li> <strong>Reverse deletion</strong> - For every cycle in the original graph and the edge \(e\) with the maximum cost, there always exists an MST without \(e\). Until there are no cycles in the graph, find a cycle and delete the edge with a maximum cost. Note that this algorithm has a higher time complexity since we try and find a cycle for each iteration of the algorithm. How do we implement this?</li> </ul> <h2 id="union-find-data-structure">Union-Find data structure</h2> <p>The idea is to maintain trees with pointers to merge and find elements. The main complication comes while merging the individual sets.</p> <ul> <li> <p>Merging by size (consuming smaller ones by larger sets) - The complexity of merging sets of size \(n\), \(m\) times takes \(O(m \log n)\)</p> </li> <li> <p>To optimize this further, we merge by rank (generalizing the previous approach where rank was simply the size of the set). We add another trick to reduce the amortized time complexity.</p> <ul> <li>Path compression - When <code class="language-plaintext highlighter-rouge">find(x)</code> is called, attach the found elements along the path directly to the root to reduce the path size.</li> </ul> <p>The time complexity then becomes \(O(m \log^* n)\) where \(\log^* n\) is the minimum \(k\) such that \(\log^{(k)} n \leq 1\).</p> </li> </ul> <h1 id="more-greedy-problems-related-to-mst">More Greedy Problems related to MST</h1> <h3 id="k-clustering">\(k\)-clustering</h3> <p>A <strong>maximum spacing</strong> for \(k\)-clustering of \(G =(V, E)\) is defined as</p> <ul> <li>An edge set \(T \subset E\) such that \((V, T)\) has exactly \(k\) connected components</li> <li>The <strong>spacing</strong> is then \(\min d(u, v)\) for \(u, v\) in different connected components</li> <li>The goal is to maximize the spacing</li> </ul> <p>This problem can be solved again with Kruskal’s algotihm to find \(k\)-connected components - perform the <code class="language-plaintext highlighter-rouge">union</code> operation for \(n - k\) times. Why is this correct? WE can show this using a contradiction.</p> <ul> <li>Consider two nodes that lie in the same connected component in the result obtained by Kruskal’s (with spacing \(d’\)). Let them be in different connected components in the optimal solution (with spacing \(d\)). Then,</li> </ul> <h3 id="second-mst">Second MST</h3> <p>A second MST is essentially the spanning tree with the <em>second</em> lowest edge summation cost. How do we find this tree?</p> <ul> <li>Find an MST with weight \(w\)</li> <li>For every edge \(e\) not in the MST, if adding \(e\) yields a cycle in the graph; then remove the largest edge \(e’\) other than \(e\) in the cycle to obtain the second MST</li> <li>The cost of the tree would be \(w + l_e - l_{e’}\)</li> </ul> <p>The time complexity of this algorithm is \(\mathcal O(T_{MST} + mn)\) and can be improved to \(\mathcal O(T_{MST} + m \log n)\) with better data-structures and divide-and-conquer.</p> <p><strong>Lemma.</strong> The second MST only differs by one edge from the MST. Multiple MSTs? <strong>Proof.</strong> Can be shown using contradiction. The idea is that one can move from one spanning tree to another with local changes in the trees. The argument is that you can replace the edges in the second MST with the edges in the MST to obtain a tree with a lower cost. This process can be repeated until there is only one edge that is different from an MST and replacing that would cause the tree to become the MST.</p> <h2 id="more-greedy-problems">More Greedy Problems</h2> <h2 id="needle-in-haystack">Needle in Haystack</h2> <p>Given two strings \(s, t\), decide whether there is a subsequence (need not be contiguous) in \(s\) that matches with \(t\). A naive greedy algorithm is depicted as follows -</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="nf">len</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">break</span> 
    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
        <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># s[i] is matched with t[j]
</span>    <span class="k">else</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></div> <p>On first glance, it looks as if this is a very intuitive algorithm. However, there are more intricate details and the proof makes these clearer. The proof relies on the Exchange argument. If there exists a subsequence \(i_1 i_2 \dots i_m\) in \(s\) matching \(t\) (\(\vert t \vert = m\)). If \(i^*_1 &lt; i_1\) is the first index that \(s[i_1] = t[1]\), then \(i^*_1i_2\dots i_m\) also matches \(t\). This way we can find a set of indices \(i^*_1i^*_2 \dots i^*_m\) through the greedy algorithm that gives the correct answer.</p> <p>In general, greedy algorithms can be proven in two general ways</p> <ul> <li>Consider any iteration of the algorithm and show that the decision made by the greedy algorithm is the best and conclude using induction</li> <li>Exchange argument: Pick an optimal solution and gradually change it to the solution produced by the greedy algorithm showing that the optimality is not affected.</li> </ul> <h2 id="matroids">Matroids</h2> <p>A finite matroid \(M\) consists of \((E, I)\) where</p> <ul> <li>\(E\) is a finite set (called the ground set). For example, \(E\) is the set of all edges in the graph \(G = (V, E)\)</li> <li>\(I\) is a collection of subsets of \(E\) (called the independent set). For example, \(I\) consists all subsets of \(S\) of \(E\) such that all the edges in \(s \in S\) form a forest.</li> </ul> <p>\((E, I)\) should satisfy the following properties -</p> <ul> <li>Null set should be in \(I\) - \(\phi \in I\)</li> <li>if \(A \subset B\) and \(B \in I\) then \(A \in I\)</li> <li>If \(A, B \in I\), \(\vert A\vert &gt; \vert B \vert\) then \(\exists e \in A - B\), such that \(B \cup \{e\} \in I\)</li> </ul> <p>Isn’t 2 inclusive of 1 and 3?</p> <p>How does this data structure help us? Suppose we have a graph \(G = (V, E)\) with weights \(c_e \geq 0\). Then, design an algorithm to find an independent set \(S\) that maximizes \(\sum_{e \in S} c_e\). Consider the following algorithm -</p> <ul> <li>Sort \(e\) in decreasing order of weights</li> <li>Let \(S = \phi\). Add \(e\) to \(S\) if \(e\) does not add cycles in \(S\)</li> </ul> <p>This algorithm is very similar to the reverse deletion algorithm and has a time complexity \(\mathcal O(\vert E \vert \log \vert E \vert + T_{check \text{ IS}})\).</p> <p><strong>Lemma.</strong> Let \(e \in E\) have the maximum cost \(c_e\)m then there always exists an IS \(A\) with maximum weight containing \(e\).</p> <p>The proof is very similar to what we have shown with MSTs. This example can be applied to MSTs, and it demonstrates how Matroids can be useful for greedy algorithms.</p> <h2 id="task-scheduling">Task Scheduling</h2> <p>Given \(n\) jobs each with \(t_i\) time to finish and deadlines \(d_i\). Consider that there is a single resource solving tasks sequentially from time \(0\), and a job has to completely finished before moving onto the next one.</p> <p>Suppose in a scheduling algorithm, job \(i\) finishes at time \(f_i\), then the lateness is defined as \(l_i = \max\{0, f_i - d_i\}\). The goal is find an algorithm that minimizes the maximum lateness \(minimize \max_i l_i\).</p> <p>Let us consider a simple case. Suppose there are two jobs with \(d_i \leq d_2\). Note that any scheduling algorithm should not have any idle time between jobs. Why so? If there is idle time, you can always do a job earlier to reduce the lateness. Furthermore, a scheduling algorithm should not have an <em>inversion.</em> That is, if job 1 has deadline earlier than job 2, then it is always optimal to perform job 1 before job 2. This claim can be easily proved using the exchange argument.</p> <h3 id="algorithm">Algorithm</h3> <p>Sort all jobs according to the increasing order of these deadlines \(d_i\), then complete each job without any idle time.</p> <p><strong>Proof.</strong> Generalize the previous two observations to \(n\) jobs.</p> <h2 id="huffman-codes">Huffman Codes</h2> <p>How do we encode an alphabet in binaries to have no ambiguities.</p> <h3 id="prefix-codes">Prefix codes</h3> <p>A prefix code for an alphabet \(T\) is a function \(f:T \to \{0, 1\}^*\), such that for distinct \(x, y \in T\), \(f(x)\) is not a prefix of \(f(y)\).</p> <p>It can be shown that a prefix code gives unique decoding.</p> <p>How do we design an encoding that is most efficient? Let us define efficiency. For every letter \(x\) in \(T\), let its frequency be \(p_x (\sum_{x \in T} p_x = 1)\). Let \(f\) be a prefix code and for every letter \(x \in T\), let \(\vert f(x)\vert\) is the number of bits. The goal is to find a prefix code \(f\) that minimizes the expected number of bits when encoding \(R\) under the frequency \(\{p_x\}\).</p> \[\text{minimize } \sum_{x \in T} p_x \cdot |f(x)|\] <p>It is beneficial to represent prefix codes as a binary tree. Each node has two children: 0 and 1. The paths from the root to other nodes in the tree represent the binary encodings.</p> <ul> <li>For prefix codes, no node of a symbol is an ancestor of node of another symbol (from the alphabet).</li> <li>Another observation is that any optimal prefix code is a full tree (every inner node has two children) - if anode has a single chide, the parent node can itself be used for the symbol deleting the leaf node making the encoding more efficient.</li> <li>There is an optimal tree (prefix code) such that two lower frequent letters are siblings, and are as deep as possible in the tree. This claim can be proved easily with the exchange argument.</li> </ul> <p>With these observations, consider the following algorithm</p> <ul> <li> <p>Initialize each letter \(x\) as a node and label it with \(p_x\)</p> </li> <li> <p>Put all nodes into a min-heap (according to the frequency)</p> </li> <li> <p>While min-heap has atleast two elements</p> <ul> <li> <p>Pop out the two smallest elements \(u, v\) (corresponds to two trees)</p> </li> <li> <p>Combine them to a single tree</p> </li> <li> <p>Push it into the heap, label with \(p_u + p_v\)</p> </li> </ul> </li> </ul> <p>This is the Huffman’s coding algorithm which has a time complexity of \(n \log n\).</p> <h2 id="shannons-source-coding-theorem">Shannon’s source coding theorem</h2> <p>Let \(T\) be an alphabet with frequency \(\{p_x\}\). The entropy of the alphabet is defined as</p> \[H := \sum_{x \in T} p_x \cdot \log \frac{1}{p_x}\] <p>The Shannon’s source coding theorem then states that you cannot send a letter from \(T\) with frequenct \(\{p_x\}\), with expected bits less than \(H\). Huffmman’s encoding gives a solution with expected bits at most \(H + 1\).</p> <p><strong>Important point</strong>. One can suggest to increase the alphabet size with dummy symbols to virtually reduce the value of \(H\) significantly. However, this introduces complexity for encoding algorithms. Therefore, there is a tradeoff with space occupied by encoding and the time for encoding.</p> <blockquote> <p>Even with augmented alphabet, the size of the encoding does not change for the original symbols in the alphabet?</p> </blockquote> <h1 id="binary-search-x-greedy-algorithms">Binary Search X Greedy Algorithms</h1> <p>The basic binary search takes advantage of the monotone structure in arrays to identify elements with certain properties. Any binary search problem can be converted to the following simpler version: For an array \(B\) that has binary elements with all zeros occurring before all ones, find the index of the first occuring \(1\).</p> <p>The binary search algorithm can be simply proved using induction.</p> <p>Let us consider an example - Ternary search. Given an array \(A[1\dots n]\) that is first strictly increasing and then strictly decreasing, dind the largest element. The array \(B[1\dots n - 1]\) is constructed as</p> <ul> <li> \[B[i] = 1 \iff A[i + 1] &gt; A[i]\] </li> <li> \[B[i] = 0 \iff A[i + 1] &lt; A[i]\] </li> </ul> <h2 id="split-array-largest-sum">Split-array largest sum</h2> <h2 id="minimum-fractional-st">Minimum fractional ST</h2> <p>Given an undirected graph \(G = (V, E)\) and each edge has two costs \(a_e, b_e\) both of which are positive, find a spanning tree \(T\) that minimizes</p> \[\frac{\sum_{e \in T} a_e}{\sum_{e \in T} b_e}\] <p>How is this related to binary search? Firstly, we will convert this problem to a decisional version - Given an undirected graph \(G = (V, E)\) and a real number \(U\), decide whether there exists a spanning tree \(T\) such that \(\frac{\sum_{e \in T} a_e}{\sum_{e \in T} b_e} \leq U\).</p> <p>This is equivalent to find a spanning tree such that \(\sum_{e \in T} a_e - U b_e \leq 0\). Construct a new graph with the weights \(a_e - Ub_e\). The reduction is easy to follow.</p> <p>How do we find the monotone structure for binary search? If the decision problem \((G, U)\) is satisfiable, then \((G, U')\) is also satisfiable for any \(U' &gt; U\). Conceptually, assume a function \(B\) (with continuous index) such that \(B[0, S] \to \{0, 1\}\) where \(S\) is an upper bound. \(B(U) = 1\) iuf and only if \((G, U)\) is satisifiable, and \(B\) is monotone.</p> <h1 id="divide-and-conquer">Divide and Conquer</h1> <h2 id="master-theorem">Master Theorem</h2> <p>Consider an algorithm that has the following relationship for running time complexity -</p> \[T(n) = 2T \left(\frac{n}{2}\right) + c n \log^k n \quad (k \geq 0)\] <p>then \(T(n) = \mathcal O(n \log^{k + 1} n)\).</p> <h2 id="closest-point">Closest Point</h2> <h2 id="fast-multiplication">Fast Multiplication</h2> <p>Suppose we have two integers in binary \(a = \sum_{0 \leq 1 \leq n} a_i \cdot 2^i, b = \sum_{0 \leq 1 \leq n} b_i \cdot 2^i\). The goal is to compute \(c = ab = \sum_{0 \leq j &lt; 2n} c_j \cdot 2^j\) where \(c_j = \sum_{0 \leq k \leq j} a_k b_{j - k}\). The naïve brute force approach takes \(\mathcal O(n^2)\) to compute the answer.</p> <p>This question is related to matrix multiplication as well. The naïve algorithm takes \(\mathcal O(n^3)\).</p> <h3 id="algorithm-1">Algorithm 1</h3> <p>We segment \(a, b\) as follows -</p> <ul> <li> <p>\(a = A_1 \cdot 2^{\frac{n}{2}} + A_0\) where \(A_0 = \sum_{0 \leq 1 &lt; n/2} a_i \cdot 2^i\) and \(A_1 = \sum_{n/2 \leq i &lt; n} a_i \cdot 2^{i - n/2}\)</p> </li> <li> <p>\(b = B_1 \cdot 2^{\frac{n}{2}} + B_0\) similarly.</p> </li> </ul> <p>Then, \(ab = (A_1 \cdot 2^{\frac{n}{2}} + A_0)(B_1 \cdot 2^{\frac{n}{2}} + B_0)\). The strategy then is to do a divide and conquer on these halves to get the final answer.</p> \[ab = A_1 B_1 2^n + (A_0 B_1 + A_1 B_0)2^{n/2} + A_0B_0\] <p>The time complexity is then \(T(n) = 4T(\frac{n}{2}) + \mathcal O(n)\). This is essentially \(\mathcal O(n^2)\) that does not give any improvement.</p> <p>This can be optimized further -</p> \[ab = A_1 B_1 2^n + ((A_0 + A_1)(B_0 + B_1) - A_0B_0 - A_1 B_1)2^{n/2} + A_0B_0\] <p>The number of multiplications reduced to 3 - \(T(n) = 3T(\frac{n}{2}) + \mathcal O(n)\). Deriving the final expression, \(T(n) = cn + cn\frac{3}{2} + \dots + cn\left(\frac{3}{2}\right)^{\log n} = \mathcal(3^{\log n})\).</p> <p>This algorithm can be extended to matrix multiplications as well.</p> \[C = AB = \begin{bmatrix} A_{00}B_{00} + A_{01}B_{10} &amp; A_{00}B_{01} + A_{01} B_{11} \\A_{10}B_{00} + A_{11}B_{10} &amp; A_{10}B_{01} + A_{11}B_{11}\end{bmatrix}\] <p>The naïve algorithm shown above is still \(O(n^3)\). Strassen’s algorithm reduces the number of multiplications to \(7\) providing an improvement over the \(\mathcal O(n^3)\) algorithm giving \(\approx \mathcal O(n^{2.81})\).</p> <p>The current state of the art algorithm for matrix multiplication achieves \(\mathcal O(n^{2.371552})\). We do not know if there is an algorithm that achieves \(\mathcal O (n^{2 + o(1)})\).</p> <h3 id="algorithm-2">Algorithm 2</h3> <p>Multiplication can be seen as a special case of convolution and we can use <strong>Fast Fourier Transform (FFT)</strong> to perform this in \(\mathcal O(n \log n)\). The details will be elaborated in the next section.</p> <h2 id="convolution">Convolution</h2> <p>Consider two vectors of the following form -</p> <ul> <li> \[a = (a_{n - 1}, a_{n - 2}, \dots, a_2, a_1, a_0)\] </li> <li> \[b = (b_{n - 1}, b_{n - 2}, \dots, b_2, b_1, b_0)\] </li> </ul> <p>The convolution operation \(\star\) is defined as</p> \[c = a\star b = (c_{n - 1}, \dots, c_0) \quad \text{ where } c_j = \sum_{0 \leq k &lt; n} a_j b_{(j - k)\mod n}\] <p>Convolution is a generalization of integer multiplication (padding + convolution = multiplication). Also, convolution is a central operation in signal processing - used for blurring images and also to learn features from spatial data.</p> <p>The naïve algorithm can be done in \(\mathcal O(n^2)\) time. We can perform convolution using \(\mathcal O(n\log n )\) using <strong>Fourier Transform</strong>.</p> <h1 id="fourier-transform">Fourier Transform</h1> <p>Consider the \(n\) dimensional vector \(a = (a_{n - 1}, a_{n - 2}, \dots, a_2, a_1, a_0)\) and \(b = (b_{n - 1}, b_{n - 2}, \dots, b_2, b_1, b_0)\). Let \(\{e_i\}_i\) form a unit basis of \(\mathbb R^n\) such that \(a = \sum_{0 \leq i &lt; n} a_i e_i, b = \sum_{0 \leq i &lt; n} b_i e_i\).</p> <p>Consider another basis \(\hat e_i(j) = \omega_n^{ij}\) where \(\omega_n = e^{\frac{1\pi \bf{i}}{n}}\) is the \(n\)-th root of unity. Therefore, \(\hat e_i = \frac{1}{\sqrt{n}} \omega_n^{(n - 1)i}, \dots, \omega_n^{2i}, \omega_n^{i}, 1)\).</p> <p>It is easy to check that this is a valid basis. So, again, \(a, b\) can be uniquely represented as</p> <ul> <li> <p>\(a = \sum_{0 \leq i &lt; n} \hat a_i \hat e_i\), \(\hat a_i = \langle a_i, \hat e_i\rangle = \frac{1}{\sqrt{n}} \sum_j a_j \omega_n^{-ij}\)</p> </li> <li> \[b = \sum_{0 \leq i &lt; n} \hat b_i \hat e_i\] </li> </ul> <p>A <strong>Fourier transform</strong> is then defined as - Given \(\{a_i\}_{i \in [n]}\), compute \(F(a) = \{\hat{a_i}\}_{i \in [n]}\).</p> <p>The <strong>inverse problem</strong> is to find \(F^{-1} (\hat a) = \{a_i \}_{i \in [n]}\). It essentially is a change of basis between \(\{e_i\} \iff \{\hat e_i\}\).</p> <h2 id="convolution-theorem">Convolution Theorem</h2> <p>Let \(a, b\) be two vectors in \(\mathbb R^n\); then,</p> \[a \star b = F^{-1} (F(a) \cdot F(b))\] <p>With this claim, convolution can be f=done in \(\mathcal O(2T_{FT} + T_{IFT} + n)\).</p> <h1 id="dynamic-programming">Dynamic Programming</h1> <h2 id="longest-path-on-a-dag">Longest path on a DAG</h2> <p>Given a DAF with \(n\) vertices, \(m\) edges, every edge \(e\) has a weight \(l_e\), compute the longest path on the DAG. The length of a path is defined as the weight sum over all edges in the path.</p> <p>Consider the following algorithm</p> <pre><code class="language-pseudocode">DFS(u):
    if marked[u] = true:
        return DP[u]
    cost &lt;- 0
    for all v that (v, u) in E:
        cost &lt;- max(cost, DFS(v) + l_{v, u})
    marked[u] &lt;- true
    DP[u] &lt;- cost
    return cost
</code></pre> <p>The time complexity of the algorithm is \(\mathcal O(n + m)\). The key point to notice is that instead of recomputing the cost of each path, we have essentially stored the costs in the array <code class="language-plaintext highlighter-rouge">DP</code> to reduce the redundant calculations. This step is known as <strong>memoization</strong>.</p> <h2 id="knapsack-problem">Knapsack Problem</h2> <p>Consider an integer \(U\) representing total capacity and a list of integers \(\{v_i, c_i\}\) that represents the volume and cost of each item respectively. The goal is to pick items such that their total volume is at most \(U\) and their value is maximized.</p> <p><strong>Idea 1</strong>. Sort everything by \(v_i/c_i\) and pick the items until value if \(U\). It is easy to see that this greedy algorithm will not work.</p> <h3 id="a-backtracking-algorithm">A Backtracking algorithm</h3> <p>Consider an iterative algorithm that at step \(i\) has \(C\) volume left and is considering whether to pick or skip the \(i\)-th item. Considering these two possibilities, we can implement a brute force algorithm with memoization for dynamic programming.</p> <p>We set a 2D matrix of size \((U, n)\) where each row \(i\) represents the set of items that need to be picked to maximize the cost within volume \(U\). The time complexity of this algorithm would be \(\mathcal O(2^n)\).</p> <p>The algorithm is as follows -</p> <pre><code class="language-pseudocodedfs(C,">   dfs(C, i):
       if i = 0: return 0
       Cost &lt;- dfs(C, i - 1)
       if C &gt;= c_i:
           Cost &lt;- max(Cost, dfs(C - c_i, i - 1) + v_i)
       return Cost
</code></pre> <h3 id="alternative-view">Alternative view</h3> <p>We can treat every possible \((C, i)\) as a vertex in a graph. Every vertex has at most two outcoming edges - \((C, i) \to (C - c_i, i - 1)\) with cost \(v_i\) and \((C, i) \to (C, i - 1)\) with cost \(0\). This constructed graph is a DAG and we essentially reduced Knapsack problem to longest path on a DAG.</p> <p>Based on the algorithm we have seen earlier, we modify the algorithm to include memoization</p> <pre><code class="language-psuedocode">   dfs(C, i):
       if marked[C][i] = true: return DP[C][i] // Modification
       if i = 0: return 0
       Cost &lt;- dfs(C, i - 1)
       if C &gt;= c_i:
           Cost &lt;- max(Cost, dfs(C - c_i, i - 1) + v_i)
       marked[C][i] &lt;- true // Modification
       DP[C][i] &lt;- cost // Modification
       return Cost
</code></pre> <p>The modified algorithm now has the time complexity \(\mathcal O(Un)\) since there are \(Un\) vertices in total with atmost 2 edges each.</p> <h2 id="general-observation">General observation</h2> <p>Dynamic Programming problems can be typically thought og as a decision-making processes. These decision problems can be converted to graphs where the states are vertices on a graph and the transitions are edges on a graph. Typically, the problem have a DP solution if the graph is a DAG and the number of states is not too large.</p> <p>The algorithm shown above can then be used as a general procedure to solve the problems. Sometimes, it is beneficial to implement the algorithms with a loop rather than recursion.</p> <h2 id="knapsack-with-unlimited-items">Knapsack with unlimited items</h2> <p>The algorithm remains pretty much the same except that teh recrusion call has <code class="language-plaintext highlighter-rouge">dfs(C - c_i, i)</code> instead of <code class="language-plaintext highlighter-rouge">dfs(C - c_i, i - 1)</code>.</p> <h2 id="knapsack-with-limited-items">Knapsack with limited items</h2> <p>We can consider another variant where item \(i\) can be used at most \(k_i\) times. Then, a similar algorithm would have the time complexity \(\mathcal (U \sum_i k_i)\).</p> <p>A better solution treats the \(i\)th item as \(\lceil \log k_i\rceil\) items. For example, if \(k_i = 8\), then divide the item as \((c_i, v_i), (2c_i, 2v_i), (4c_i, 4v_i), (c_i, v_i)\). Then the time complexity would be reduced to \(\mathcal O(U \sum_i \log k_i)\).</p> <p>However, it can be improved to \(\mathcal O(Un)\) using a <strong>monotonic queue</strong>.</p> <h2 id="2d-knapsack">2D Knapsack</h2> <p>In this variant, each item has value \(v_i\), volume integer \(c_i &gt; 0\) and a weight integer \(w_i &gt; 0\). The goal is to find a subset of items that has the total volume at most \(U\), total weight at most \(W\) and the total value is maximized. The dynamic programming algorithm has a runtime of \(\mathcal O(WUn)\).</p> <p>In the loop variant of the algorithm, it is better to iterate over the items first rather than the weights. Why is that? Furthermore, it is better to iterate decreasing the costs, because</p> <h2 id="summary">Summary</h2> <p>Many intractable problems can be efficiently solved on trees - combining with DFS enforces the computation ordering.</p> <h1 id="bellman-ford-algorithm">Bellman-Ford algorithm</h1> <h3 id="single-source-shortest-path-sssp">Single Source Shortest Path (SSSP)</h3> <p>Given a directed graph of \(n\) vertices and \(m\) edge, find the shortest paths for a vertex pair \((s, t)\).</p> <p>Recently, researchers showed that Dijkstra’s algorithm is the most optimal algorithm possible with a <em>specially</em> designed heap.</p> <p>Would dynamic programming work for SSSP? \(dp[u][i]\) represents a path from \(s\) to \(u\) using at most \(i - 1\) edges. This simply is the Bellman-Ford algorithm.</p> <h1 id="floyd-warshall-algorithm">Floyd-Warshall algorithm</h1> <p>All pair shortest path algorithm in \(O(n^3)\).</p> <h1 id="traveling-salesman-problem">Traveling Salesman Problem</h1> <p>Given.a complete graph of \(n\) vertices, every edge has a cost \(l_e\). The goal is to find a path that visits every node exactly once while minimizing the total cost. It is an NP-hard problem where the brute-force algorithm takes \(\\mathcal O(n!)\) - enumerating all possible permutations of nodes.</p> <p>There is a dynamic programming solutions of the order \(O(2^n n^2)\). This is computable with the modern computers upto \(n = 15\). We discuss the framework here -</p> <ul> <li> <p><strong>States</strong> - At node \(u\), set of all unvisited states - minimum cost to finish the rest of the task. The number of states is \(\mathcal O(n2^n)\).</p> </li> <li> <p><strong>Decision-making</strong></p> </li> <li> <p>What will be the next node to visit? If we choose \(v \in S\), then the next state will be $$(v, S - {v})$</p> </li> </ul> <p>This can be implemented using a bitmask for representing the state - saves space and is faster.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/machine-learning-systems/">Key Works in ML Systems</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/data-systems-for-ml/">Data Systems for Machine Learning</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/ai-agents/">AI Agents</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/rl-theory/">Reinforcement Learning Theory</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/brains-and-ai/">Brains and AI</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Sudhansh Peddabomma. Last updated: March 17, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script src="/assets/js/tooltips-setup.js?53023e960fbc64cccb90d32e9363de2b"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-0K9MLG0V24"></script> <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag('js', new Date());

    gtag('config', 'G-0K9MLG0V24');
  </script> <script defer src="/assets/js/google-analytics-setup.js?12374742c4b1801ba82226e617af7e2d"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> <div id="chat-window" class="chat-window"> <div class="chat-header"> <h5 class="mb-0">Talk to my AI</h5> <button id="close-chat" class="btn-close"> <i class="fas fa-times"></i> </button> </div> <div id="chat-messages" class="chat-messages"></div> <div class="chat-input-container"> <input type="text" id="chat-input" class="form-control" placeholder="Type a message..."> <button id="send-btn" class="btn btn-primary"> <i class="fas fa-paper-plane"></i> </button> </div> </div> </body> </html>