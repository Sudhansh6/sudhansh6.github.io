<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Automata Notes | Sudhansh</title> <meta name="author" content="Sudhansh Peddabomma"> <meta name="description" content="An introductory course to Automata theory. The first half covers DFAs, NFAs, and their various properties. Relations of regularity of languages and DFAs/NFAs and proofs of non-regularity of languages. The second half of the notes covers pushdown automata, context free grammar and their relation with deterministic PDAs. Briefly touches upon Turing machines."> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%91%BE&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://sudhansh6.github.io/blog/automata/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?6185d15ea1982787ad7f435576553d64"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Sudhansh</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">Articles</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"></a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/challenges/">Challenges</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/misc/">Miscellaneous</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">Automata Notes</h1> <p class="post-meta">January 6, 2022</p> <p class="post-tags"> <a href="/blog/2022"> <i class="fa-solid fa-calendar fa-sm"></i> 2022 </a>   ·   <a href="/blog/category/notes"> <i class="fa-solid fa-tag fa-sm"></i> Notes</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <h1 id="lecture-1">Lecture 1</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">03-01-22</code></p> </blockquote> <h2 id="overview">Overview</h2> <p>Consider the problem of determining whether a given multivariate polynomial with integer coefficients has integer roots. This problem is <em>undecidable</em> - we cannot write a deterministic algorithm which halts in finite time that always gives the correct answer for a given polynomial. We will explore various techniques and theorems through the course to answer questions like these.</p> <p><strong><em>Example.</em></strong> Consider the language \(L_1 = \{a^nb^m: n,m \geq 0\}\). Consider the problem of deciding whether a word is present in this language or not. We can write such a program using a DFA of the form</p> <p><strong><em>Example.</em></strong> Suppose we have \(L_2 = \{a^nb^n: n \geq 0\}\). Can we construct a DFA for the same?</p> <p>It can be shown that such a language cannot be represented using a DFA. Instead, we use an instrument known as <strong><em>pushdown automaton</em></strong>.</p> <p>A <em>pushdown automaton</em> has a stack associated with a DFA. Every transition in the automaton describes an operation such as “push” and “pop” on the stack. A string is accepted by the automaton if the stack is empty at the end of the string. The languages accepted by such automatons are known as <strong><em>context-free grammar</em></strong>.</p> <p><strong><em>Example.</em></strong> Extending the previous example, consider the language \(L_3 = \{a^nb^nc^n:n \geq 0\}\). Turns out, a pushdown automaton cannot represent this language.</p> <p>We have a <strong><em>Turing machine</em></strong> that represents the ultimate computer that can perform any computation (not all). This machine has a ‘tape’ associated with it along with different decisions at each section of the tape. The languages associated with these machines are known as <strong><em>unrestricted grammar</em></strong>.</p> <p>These machines and the associated languages can be represented using a diagram known as <a href="#chomsky-hierarchy">Chomsky hierarchy</a>. We will also prove that adding non-determinism affects the expressive power of PDAs but not of DFAs and TMs.</p> <h1 id="lecture-2">Lecture 2</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">04-01-22</code></p> </blockquote> <p><strong><em>Definition.</em></strong> A <em>finite state automaton</em> is defined as a tuple \((Q, \Sigma, \delta, q_0, F)\), where</p> <ul> <li>\(Q\) is a finite non-empty set of states,</li> <li>\(\Sigma\) is the alphabet with a set of symbols,</li> <li>\(\delta: Q \times \delta \to Q\) is the state-transition function,</li> <li>\(q_0 \in Q\) is the initial state, and</li> <li>\(F \subseteq Q\) is the set of accepting states.</li> </ul> <p><strong><em>Example.</em></strong> Let us consider the language \(L_2 = \{a^nb^n:n\geq 0\}\) we saw before. How do we write the <em>context-free grammar</em> for this language? We write a set of <u>base cases and inductive rules</u> as follows -</p> <div style="text-align:center;"> $$ \begin{align} S &amp;\to \epsilon \\ S &amp;\to aSb \end{align} $$ </div> <p>Typically, we use \(S \to \epsilon\) as the base case. We start out with the string \(S\), and then use the above rules to keep replacing the \(S\) until we obtain a string consisting only of <em>terminals</em>. Here, the symbols \(a, b,\) and \(\epsilon\) are terminals whereas \(S\) is a non-terminal.</p> <p><strong><em>Example.</em></strong> Consider the grammar of matched parentheses. This is given by -</p> <div style="text-align:center;"> $$ \begin{align} S &amp;\to ()\\ S &amp;\to (S)\\ S &amp;\to SS \end{align} $$ </div> <p><strong><em>Definition.</em></strong> A <em>context-free grammar</em> is defined as a tuple \((V, \Sigma, R, S)\), where</p> <ul> <li>\(V\) is a set of <em>non-terminals</em> or <em>variables</em>,</li> <li>\(\Sigma\) is the alphabet,</li> <li>\(R: V \to (V \cup \Sigma)^*\) is the finite set of <em>rules</em>, and</li> <li>\(S \in V\) is the <em>start</em> symbol.</li> </ul> <p>The language of a given grammar is the set of all strings derivable using the rules.</p> <p><strong><em>Example.</em></strong> Consider the language \(\{a^nb^nc^n: n &gt; 0\}\). This can be represented by the unrestricted grammar as -</p> <div style="text-align:center;"> $$ \begin{align} S &amp;\to abc \\ S &amp;\to aAbc \\ Ab &amp;\to bA \\ Ac &amp;\to Bbcc \\ bB &amp;\to Bb \\ aB &amp;\to aa \\ aB &amp;\to aaA \end{align} $$ </div> <p>These set of rules are very similar to CFG except for the fact that, now, we have strings on the LHS too. Notice how \(A, B\) are used to convey information across the string when new \(a\)’s or \(b\)’s are added.</p> <blockquote> <p><strong><em>Homework.</em></strong> Write the unrestricted grammar rules for the language \(L = \{a^{n^2} : n \in \Z^+\}\)</p> </blockquote> <p><strong><em>Definition.</em></strong> An <em>unrestricted grammar</em> is defined as a tuple \((V, \Sigma, R, S)\), where</p> <ul> <li>\(V\) is a set of <em>non-terminals</em> or <em>variables</em>,</li> <li>\(\Sigma\) is the alphabet,</li> <li>\(R: (V \cup \Sigma)^* \to (V \cup \Sigma)^*\) is the finite set of <em>rules</em>, and</li> <li>\(S \in V\) is the <em>start</em> symbol.</li> </ul> <p><strong><em>Definition.</em></strong> <em>Regular expressions</em> are defined by the following set of rules -</p> <ol> <li> <p>\(\phi, \{\epsilon\}, \{a\}\) (for any \(a \in \Sigma\)) are regular expressions.</p> </li> <li> <p>If \(E_1, E_2\) are regular expressions,</p> <ol> <li>\(E_1 + E_2\) (union),</li> <li>\(E_1E_2\) (concatenation)</li> <li>\(E_1^*\) (<strong>Kleene star</strong>), and</li> <li>\((E_1)\) (parenthesis)</li> </ol> <p>are all regular expressions.</p> </li> </ol> <p><strong><em>Example.</em></strong> Consider \(L = \{\text{strings with even number of a's}\}\). This can be represented using the regular expression \(b^*(ab^*ab^*)^*\).</p> <blockquote> <p><strong><em>Homework.</em></strong> Suppose \(L\) is restricted to have only an odd number of \(b\)’s. How do we write the regular expression for this language?</p> </blockquote> <p>In general, PDAs are represented as a Finite State Machine. That is, we have an action associated with each transition. An empty stack is denoted using the symbol \(Z_0\). That is, the stack begins with a single symbol \(Z_0\). Each transition is represented as \(l, A\), where \(l\) is a letter and \(A\) is an action such as</p> <ul> <li>\(X \vert aX\) - push</li> <li>\(aX \vert X\) - pop</li> <li>\(W\vert Wa\) - not sure what this is</li> </ul> <p>Now, a string is rejected by the FSM in two scenarios -</p> <ol> <li>There is no transition defined at the current state for the current symbol in the string, and</li> <li>The stack is not empty, i.e. popping the stack does not yield \(Z_0\) at the end of the string input.</li> </ol> <h1 id="lecture-3">Lecture 3</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">06-01-22</code></p> </blockquote> <h2 id="chomsky-hierarchy">Chomsky Hierarchy</h2> <p><img src="/assets/img/Automata\image-20220106090455841.png" alt="image-20220106090455841"></p> <h2 id="regular-expressions">Regular Expressions</h2> <p>We define these languages using a base case and an inductive rule. <strong>Empty string</strong> is not the same as the <strong>empty set</strong>. The base case to be considered is \(L = \{\epsilon\}\)?</p> <h3 id="inductive-rules">Inductive Rules</h3> <p><strong>Lemma.</strong> If \(E_1, E_2\) are regular expressions, then so are</p> <ul> <li>\(E_1 + E_2\) - Union</li> <li>\(E_1.E_2\) - Concatenation</li> <li>\(E_1^*\) - Kleene star</li> <li>\((E_1)\) - Parentheses</li> </ul> <p>“Nothing else” is a regular expression. That is, we must use the four rules mentioned above to construct a regular expression.</p> <p>The fourth rule can be used as follows - \(L((ab)^*) = \{\epsilon, ab, abab, ababab, ...\}\). The parentheses help us group letters from the alphabet to define the language.</p> <p><strong><em>Example.</em></strong> Construct a language with <u>only even number of a's'</u>. Good strings include \(\{aba, baabaa\}\), and bad strings include \(\{abb, bbabaa\}\).</p> <p>The automata can be easily drawn as -</p> <p><img src="/assets/img/Automata\image-20220106085034344.png" alt="image-20220106085034344"></p> <p>How do we write a regular expression for this? Consider the expression \(R = (ab^*ab^*)^*\). However this expression does not include strings that start with \(b\).</p> <blockquote> <p><strong><em>Homework.</em></strong> Try and fix this expression -</p> \[R = b^*.(ab^*ab^*)^*\] </blockquote> <p><strong><em>Example.</em></strong> Construct an expression for defining the language \(L = \{\text{all strings with even number of a's} \text{and odd number of b's}\}\)</p> <p>The following automaton would work for this language -</p> <p><img src="/assets/img/Automata\image-20220106085649521.png" alt="image-20220106085649521"></p> <blockquote> <p><strong><em>Homework</em></strong>. Find a regular expression for the above language.</p> </blockquote> <p><strong><em>Example.</em></strong> What language does the regular expression \(b^*ab^*(ab^*ab^*)^*\)?</p> <p>It represents the language with an <u>odd</u> number of \(a\)’s. How do we check this? Start with the base cases - It has \(\epsilon\), and it also has \(\{ab, ba\}\). Try to check the pattern and use induction.</p> <p>We will soon learn how to derive relations such as “Is \(L = \phi\)?”, “Is \(\|L\| = \infty\)?”, “Is \(L_1 \subset L_2\)?”… All we are doing right now is exploring all the topics in the course using a BFS approach.</p> <h2 id="representation-of-push-down-automata">Representation of Push-Down Automata</h2> <p>The bottom of the stack contains a special character that indicates the bottom of the stack. We design a Finite State Machine which knows the special characters (for bottom of the stack or other purposes) and also the top element in the stack. This FSM can pop or push on the stack to go to the next state.</p> <p><strong><em>Example.</em></strong> Represent \(L = \{a^nb^n\}\) using a FSM.</p> <p><img src="/assets/img/Automata/image-20220106091221465.png" alt="image-20220106091221465"></p> <p>This is how a FSM is represented. A string is accepted <strong>iff</strong> the stack is empty. Note the transition from \(q_0\) to \(q_1\). It says that the top of the stack must be \(a\). In case it isn’t the case, the string is rejected.</p> <p>In a FSM, the string is rejected due to one of the two reasons -</p> <ul> <li>No transition for the given input symbol or we reach the top stack symbol (in the case of finite length languages)</li> <li>Input is over, and the stack is not empty.</li> </ul> <p><strong><em>Example.</em></strong> Try the same for \(L = \{\text{equal \#}a's \text{ and } b's\}\).</p> <p><img src="/assets/img/Automata/image-20220106092231128.png" alt="image-20220106092231128"></p> <p>Does this work?</p> <h2 id="non-determinism">Non-determinism</h2> <p><strong><em>Example.</em></strong> Represent \(L = \{ww^R\} \| w \in (a + b)^*\}\). Here, “R” represents reverse. That is, this language is the language of palindromes. Here, we keep pushing and then we keep popping after a decision point. <u>The decision point is a non-deterministic guess</u>. If there is a correct guess, then the algorithm will work.</p> <p><strong><em>Example.</em></strong> Is \(n\) composite? How do we design a non-deterministic algorithm for this problem?</p> <ol> <li>Guess for a factor \(p &lt; n\)</li> <li>Check if \(p\) divides \(n\). If the answer is “yes” then it is composite, else repeat.</li> </ol> <blockquote> <p>How do we reject empty strings in PDA?</p> <p>Does adding accepting states in the FSM increase the representation power? Does using the special symbol in between the stack increase the representation power?</p> </blockquote> <p>The reference textbook for this course is “Hopcroft Ullman Motwani.”</p> <h1 id="lecture-4">Lecture 4</h1> <p>This was self-reading about automatons (DFA and NFA).</p> <h1 id="lecture-5">Lecture 5</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">11-01-22</code></p> </blockquote> <blockquote> <p><strong><em>Homework.</em></strong> Find the number of binary strings of length 10 with no two consecutive 1’s.</p> <p><em>Answer.</em> \(f\) considers bit strings starting with \(0\) and \(g\) considers bit strings starting with \(1\).</p> \[\begin{align} f(1) &amp;= 1; f(2) = 2; \\ g(1) &amp;= 1; g(2) = 1 \\ f(n) &amp;= f(n - 1) + g(n - 1); \\ g(n) &amp;= f(n - 1); \end{align}\] <p>\(f: \{1, 2, 3, 5, 8, \dots\} \\ g: \{1, 1, 2, 3, 5, \dots \}\) Therefore, there are \(144\) such required strings.</p> </blockquote> <p><strong><em>Example.</em></strong> How do we construct an automata which captures the language of binary strings with no two consecutive 1’s? We use something known as a <strong>trap state</strong>. All the bad strings will be <em>trapped</em> in that state, and no transition from the trap state will lead to a final state. Consider the following automaton.</p> <p><img src="/assets/img/Automata/image-20220111114750638.png" alt="image-20220111114750638"></p> <p>Here, the 3rd state is the trap state.</p> <h3 id="extended-transition-function">Extended transition function</h3> <p>\(\hat \delta : Q \times\Sigma^* \to 2^Q\) is defined as</p> \[\hat \delta(S, aW) = \begin{cases} \delta(S, a) &amp; w = \epsilon \\ \hat \delta(\delta(S, a), W) &amp; \text{otherwise} \end{cases}\] <p>For the sake of convenience we drop the hat and use \(\delta\) for the extended function (polymorphism).</p> <blockquote> <p><strong><em>Homework.</em></strong> Read the proof for showing the equivalence of language sets in DFA.</p> </blockquote> <h2 id="non-determinism-1">Non-determinism</h2> <p>Non-determinism basically refers to the procedures where we get the same output from the same input through <em>multiple runs</em>. In <strong>don’t care</strong> non-determinism, we get the same output with different algorithms/procedures. However, in <strong>don’t know</strong> non-determinism, a single stochastic algorithm goes through many runs (scenarios) to get the answer.</p> <h1 id="lecture-6">Lecture 6</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">13-01-22</code></p> </blockquote> <p>A deterministic automaton has a single choice of transition from a given state for a given symbol from the alphabet. However, in the case of a non-deterministic automata, such guarantee does not exist. The next state for a given symbol from a given state of the NFA is a set of states rather than a single state. There are two types of NFA as discussed previously.</p> <ul> <li>Don’t know NFA - Guess the right choice</li> <li>Don’t care NFA - All choices give the same result</li> </ul> <p>One might ponder if NFAs are more expressive than DFAs. The answer is surprisingly no. Non-determinism can be introduced to an automaton in two ways -</p> <ul> <li>Choice of subset of states for each transition</li> <li>\(\epsilon\)-transitions</li> </ul> <p><strong>Example.</strong> Construct an automaton to represent the language \(L = \{abc\} \cup \{\text{all strings ending in b}\}\) whose alphabet is \(\{a,b,c\}\)</p> <p><img src="/assets/img/Automata/image-20220113085632353.png" alt="image-20220113085632353"></p> <p><strong>Note.</strong> We have introduced \(\epsilon\)-transitions in this automaton.</p> <p>As we shall see later in the course, the three models - DFA, NFA, and NFA with \(\epsilon\)-transitions; are all equivalent in terms of expressive power.</p> <h2 id="properties-of-languages">Properties of Languages</h2> <p>We mainly check two properties of languages - decision and closure.</p> <ul> <li> <p>Decision - Is \(w \in L\)? (Membership Problem) - decidable for regular languages.</p> <p>Decidable problems - Problems for which we can write a <strong>sound</strong> algorithm which <strong>halts in finite time</strong>.</p> <p>We can also consider problems like - Given \(DFA(M_1)\) and \(DFA(M_2)\), Is \(L(M_1) = L(M_2)\)? or \(L(M_1) \subset L(M_2)\)?</p> <p>Is \(L = \phi\)? Is \(L\) finite? Is \(L\) finite and has an even number of strings? We can also ask questions about the DFA - Can \(L(M)\) be accepted by a DFA with \(k &lt; n\) states (minimalism)?</p> <p><strong><em>Example.</em></strong> Can we build a DFA whose language is \(L = \{\text{bit strings divisible by } 7\}\) with less than 7 states? Turns out, the answer is no.</p> <p>Finally, we can ask a very difficult question such as - Show \(L\) cannot be accepted by any DFA. The technique for solving such a question is known as the <strong><em>Pumping Lemma</em></strong>. This lemma is based on the <em>Pigeonhole principle</em>.</p> </li> <li> <p>Closure - closure using Union, Intersection, Kleene Star, and Concatenation. The question we ask is if \(L_1, L_2\) belong to class \(C\), then does \(L_1 \texttt { op } L_2\) belong to \(C\)?</p> </li> </ul> <h1 id="lecture-7">Lecture 7</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">17-01-22</code></p> </blockquote> <p>We plan to show the equivalence of the following models -</p> <ul> <li>DFAs</li> <li>NFAs</li> <li>NFA-\(\epsilon\)</li> <li>Regular Expressions</li> </ul> <blockquote> <p><strong><em>Homework.</em></strong> Draw a DFA for the language \(L_1 \cup L_2\) where \(L_1\) is \(a\) followed by even number of \(b\)s and \(L_2\) is \(a\) followed by odd number of \(c\)s.</p> </blockquote> <h2 id="regular-expressions-1">Regular Expressions</h2> <p>They are defined using base cases and inductive cases. Before we discuss this, we define <strong>closed-world</strong> assumption. It is the presumption that a statement that is true is also known to be true. Therefore, conversely, what is not currently known to be true, is false. More info regarding this topic can be found <a href="https://en.wikipedia.org/wiki/Closed-world_assumption" rel="external nofollow noopener" target="_blank">here</a>. The base cases for regular expressions are given as follows.</p> \[\begin{align} L(a) &amp;= \{a\} \\ L(\epsilon) &amp;= \{\epsilon\} \\ L(\phi) &amp;= \phi \text{ (An empty set)} \end{align}\] <p>The inductive cases are</p> \[\begin{align} L_1, L_2 &amp;\to L_1 \cup L_2 \\ L_1, L_2 &amp;\to \{uv \vert u \in L_1, v \in L_2\} \\ L &amp;\to L_1^* \end{align}\] <h2 id="re-equiv-nfa-epsilon">RE \(\equiv\) NFA-\(\epsilon\)</h2> <p>To begin with, we convert the base cases of regular expressions to NFA-\(\epsilon\)s. Here are the automatons</p> <p><img src="/assets/img/Automata/image-20220131011047071.png" alt="image-20220131011047071"></p> <p>Now, for the inductive cases -</p> <ul> <li> <p>For union of \(L_1\) and \(L_2\), consider the NFAs of both languages. Create a new start state \(s\) and final state \(f\). Connect \(s\) to the start states of both NFAs with \(\epsilon\) transitions and the final states of both NFAs to \(f\) with the same transitions.</p> <blockquote> <p>How do we prove that this construction represents the union?</p> </blockquote> </li> <li> <p>For concatenation of \(L_1\) and \(L_2\), connect all the final states of \(L_1\)’s NFA to all the start states of \(L_2\)’s NFA using \(\epsilon\) transitions.</p> </li> <li> <p>For \(L^*\), connect all the final states of the NFA to the start states of the NFA using \(\epsilon\) transitions. However, this does not accept \(\epsilon\). Fix it. Think.</p> </li> </ul> <h1 id="lecture-8">Lecture 8</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">18-01-22</code></p> </blockquote> <h2 id="decision-properties">Decision Properties</h2> <h3 id="membership-problem">Membership Problem</h3> <p>Does \(w \in L\)? How do we show that this problem is decidable? The algorithm is well-known.</p> <h3 id="emptiness-problem">Emptiness Problem</h3> <p>Is \(L(M) = \phi\)? This problem can be solved using <em>reachability</em> in graphs. One can check if the final states are reachable from the start state. It can be achieved using <strong>fixed point</strong>. This method is essentially propagating the frontier from the start state. We add neighbors of all the states in the current frontier and keep expanding it. We do this until our frontier does not change. This frontier is the fixed point.</p> <h3 id="infiniteness-problem">Infiniteness Problem</h3> <p>Is \(L(M)\) finite? We need to search for a loop in the graph to answer this question. Suppose our DFA has \(N\) states. If the DFA accepts a string whose length is greater than or equal to \(N\), then a state has to repeat while forming this string. This observation is a result of the <strong>Pigeonhole principle</strong>.</p> <p>This check is both necessary and sufficient. If a language is infinite, then it means that it has a string of length greater than \(N\). How are we going to use this property to check the infiniteness of the language? Is there a decidable algorithm?</p> <p><strong><em>Claim.</em></strong> If there is a string of length \(\geq N\) in \(L\), then there is a string of length between \(N\) and \(2N - 1\). Think about the proof. <em>Clue.</em> You can use at the most \(N - 1\) self loops.</p> <p>It is sufficient to test for the membership of all strings of length between \(N\) and \(2N - 1\).</p> <h2 id="pumping-lemma">Pumping Lemma</h2> <p><strong><em>Problem.</em></strong> Show that \(L = \{a^nb^n\}\) is not regular.</p> <p>We use proof by contradiction. Assume that a \(DFA(M)\) with \(N\) states accepts \(L\).</p> <p><strong><em>Theorem.</em></strong> <em>Pumping Lemma</em>. For every regular language \(L\), there exists an integer \(n\) , called the <em>pumping length</em>, where every string \(w \in L\) of length \(\geq n\) can be written as \(w = xyz\) where</p> \[\begin{align} \vert xy \vert &amp;\leq n \\ \vert y\vert &amp;&gt; 0\\ \forall i \geq 0,\ &amp; x(y)^iz \in L \end{align}\] <p>Let us understand this by proving \(L = \{a^nb^n \vert n &gt; 0\}\) is not regular using contradiction. Assume there is a \(DFA(M)\) with \(N\) states that accepts \(L\).</p> <p>Now, consider the string \(a^Nb^N\). Now, define \(a^n\) as \(xy\). Let \(x = a^j\) and \(y = a^k\) where \(n \leq N\). According to the pumping lemma, \(a^j(a^k)^ib^N \in L\). Therefore, there can’t exist a DFA that represents \(L\).</p> <blockquote> <p><strong><em>Homework.</em></strong> Prove that the language with equal number of \(a\)‘s and \(b\)’s is not regular.</p> <p>The idea is to use closure properties.</p> </blockquote> <blockquote> <p><strong><em>Homework.</em></strong> Prove the pumping lemma.</p> <p><em>Answer.</em> Consider a DFA\((Q, \Sigma, Q_0, \delta, F)\) with \(N\) states, and a word \(w\) such that \(\vert w \vert = T \geq N\) belongs to \(L\). Now, let \((S_i)_{i =0}^T\) (0 - indexed) be the sequence of states traversed by \(w\). The state \(S_L\) is an accepting state as \(w \in L\). Also, there exist \(0 \leq i &lt; j \leq N\) such that \(S_i = S_j\) as there are only \(N\) states in the DFA (Pigeonhole principle). Now, define the string formed by \(S_0, \dots, S_i\) as \(x\), the one formed by \(S_i, \dots, S_j\) as y, and that formed by \(S_j, \dots, S_T\) as \(z\). We have \(w = xyz\). Also, \(\vert y \vert &gt; 0\) as \(i &lt; j\) and \(\vert xy \vert \leq N\) as \(j \leq N\).</p> <p>Since \(S_i = S_j\), we can <em>pump</em> the string \(y\) as many times as we wish by traversing cycle \(S_i, \dots, S_j\). Now, since \(S_T \in F\), the string formed by the sequence \(S_0, \dots, \{S_i, \dots, S_j\}^t, \dots, S_T\) (\(t \geq 0\)) also belongs to \(L\). This word is equivalent to \(xy^iz\). \(\blacksquare\)</p> </blockquote> <h1 id="lecture-11">Lecture 11</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">25-01-22</code> There were no lecture 9 and 10</p> </blockquote> <h2 id="nfa-equiv-dfa">NFA \(\equiv\) DFA</h2> <p>We convert a NFA to DFA using <strong>subset construction</strong>. That is, if \(Q\) is the set of states in the NFA, then \(2^Q\) will the set of states in the DFA. Initially, we construct the start states using the subset of start states in the NFA. Then, we build the following states in the DFA by tracing all the states reached by each character in the NFA into a single subset. If any of the subset consists of a final state, then that subset state is made into a final state in the DFA.</p> <p>This equivalence can also be extended to show the equivalence of NFA-\(\epsilon\) and \(DFA\).</p> <h2 id="dfa-minimization">DFA Minimization</h2> <p>All DFAs with minimal number of states are <strong>isomorphic</strong>.</p> <h3 id="distinguishable-states">Distinguishable states</h3> <p>Consider a DFA \((Q, \Sigma, Q_0, \delta, F)\). States \(q_i,q_j \in Q\) are said to be distinguishable iff there exists a word \(w \in \Sigma^*\) such that \(\delta(q_1, w) \not \in F\) and \(\delta(q_2, w) \in F\) or vice versa.</p> <p>One can merge indistinguishable states to minimize a DFA.</p> <h2 id="context-free-grammar">Context-Free Grammar</h2> <p>Let us try to write the grammar for the language \(L = \{a^ib^jc^k \vert i = j \text{ or } j = k\}\). Consider the following rules</p> \[\begin{align} S &amp;\to S_1 \vert S_2 \\ S_1 &amp;\to aS_1bC \vert C \\ S_2 &amp;\to AbS_2c \vert \epsilon \\ C &amp;\to cC \vert \epsilon \\ A &amp;\to aA \vert \epsilon \end{align}\] <p>In general, union is straightforward to write in CFG due to rules like rule 1. However, there is an ambiguity in the above rules. For example, the word \(a^3b^3c^3\) can be generated using different derivations. We’ll discuss this later in the course.</p> <p>As we discussed before, a context free grammar \(G\) is defined by \((V, \Sigma, R, S)\). A string is accepted by the grammar if \(w \in \Sigma^*\) and \(R \xrightarrow{*} w\). That is, the rules must be able to <em>derive</em> \(w\).</p> <p>A one-step derivation is given by \(u_1Au_2 \to u_1\beta u_2\) if \(A \to \beta \in R\) and \(u_1, u_2 \in (V \cup \Sigma)^*\).</p> <p>Consider the set of rules for defining arithmetic expressions. The language is defined over \(\Sigma = \{+, -, \times, \div, x, y, z, \dots\}\).</p> \[\begin{align} S &amp;\to x \vert y \vert z \\ S &amp;\to S + S \\ S &amp;\to S - S \\ S &amp;\to S \times S \\ S &amp;\to S \div S \\ S &amp;\to (S) \end{align}\] <p>Now, for an expression such \(x + y \times z\), we can give a left-most derivation or a right-most derivation. A precedence order removes ambiguities in the derivation. In programming languages, a parser removes these ambiguities using some conventions.</p> <blockquote> <p><strong><em>Homework.</em></strong> Try and write the set of rules for the language which consists of \(a\)s and \(b\)s such that every string has twice the number of \(a\)s as that of \(b\)s.</p> <p><em>Answer.</em> We try to write the rules for equal number of a’s and b’s, and try to extend them.</p> \[\begin{align} S &amp;\to \epsilon \\ S &amp;\to aSb \ \vert \ Sab \ \vert \ abS \\ S &amp;\to bSa \ \vert \ Sba \ \vert \ baS \end{align}\] <p>Does this work?</p> </blockquote> <p><strong>Note.</strong> \(\vert R \vert\) is finite.</p> <h1 id="lecture-12">Lecture 12</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">27-01-22</code></p> </blockquote> <p>We had seen the CFG for the language \(L = \{a^nb^n\}\). How can one prove that the rules represent that language? That is, how do we know that the rules generate <u>all the strings</u> in the language and <u>no other strings</u>?</p> <p>Consider the language we saw in the previous lecture - strings with equal number of a’s and b’s. The possible set of rules are -</p> \[\begin{align} S &amp;\to aB \ \vert \ bA \\ B &amp;\to b \ \vert \ bS \ \vert \ aBB \\ A &amp;\to a \ \vert \ aS \ \vert \ bAA \\ \end{align}\] <p>The thinking is as follows -</p> <ul> <li>\(S\) generates strings with equal number of a’s and b’s. \(B\) generates strings with one more b than a’s, and similarly for \(A\).</li> <li>To write the inductive cases of \(S\), we consider strings starting with both a and b. Inductive cases for \(A, B\) are also constructed similarly.</li> </ul> <p>Another possible set of rules are -</p> \[\begin{align} S &amp;\to aSb \ \vert \ bSa \\ S &amp;\to \epsilon \\ S &amp;\to SS \\ \end{align}\] <p>These rules are the minimized set of the rules I wrote for the hw in the last lecture.</p> <h2 id="grammars">Grammars</h2> <p>We can write grammars in canonical forms. A grammar is said to be in <strong>Chomsky normal form</strong> if the rules are of the form</p> \[\begin{align} C \to DE &amp;\text{ - one non-terminal replaced by 2 non-terminals} \\ C \to a &amp;\text{ - one terminal replaced by a terminal} \end{align}\] <p><strong><em>Claim.</em></strong> Any grammar \(G\) (\(\epsilon \not\in L(G)\)) can be converted to an equivalent Chomsky Normal form.</p> <p>Another canonical form of grammar is <strong>Greibach normal form</strong>. The rules are of the form</p> \[\begin{align} C &amp;\to a\alpha \end{align}\] <p>Each non-terminal converts to a terminal followed by a symbol in \((V \cup \Sigma)^*\). Similar to the Chomsky form, every grammar can be converted to the Greibach normal form.</p> <h2 id="push-down-automatons">Push Down Automatons</h2> <p>Consider the language \(L = \{wcw^R \vert w \in (a + b)^*\}\).</p> <blockquote> <p><strong><em>Aside.</em></strong> Try writing the Chomsky normal form rules for the above language. \(\begin{align} S &amp;\to AA_0 \mid BB_0 \mid c \\ A_0 &amp;\to SA \\ B_0 &amp;\to SB \\ A &amp;\to a \\ B &amp;\to b \\ \end{align}\)</p> </blockquote> <p>The pushdown automaton for this language is given by -</p> <p><img src="/assets/img/Automata/image-20220131205500689.png" alt="image-20220131205500689"></p> <h1 id="lecture-13">Lecture 13</h1> <p>How do we take a grammar and produce the normal form of the grammar? We shall learn techniques such as eliminating useless symbols, elimination epsilon and unit productions. These will be used to get the designable form of the grammar that can also be used to show languages which are context-free using the pumping lemma.</p> <p>The notation \(\alpha_1 \xrightarrow{n} \alpha_2\) is used to denote that \(\alpha_2\) can be derived from \(\alpha_1\) in \(n\) steps. The \(*\) over the arrow represents the derivative closure of the rules.</p> <p>Grammars \(G_1, G_2\) are equivalent iff \(L(G_1) = L(G_2)\). For example, we have seen two grammars for the language \(L = \text{ strings with } \#a = \#b\), and they are both equivalent.</p> <h3 id="derivation-trees">Derivation trees</h3> <ul> <li>Trees whose all roots are labeled.</li> <li>The root of the tree is labeled with the start symbol of the grammar \(S\).</li> <li>Suppose A is the label of some internal node, then A has a children \(X_1, \dots X_R\) iff \(A \to X_1\dots X_R \in R\).</li> <li>\(\epsilon\) can only be the label of leaf nodes.</li> </ul> <h3 id="derivations">Derivations</h3> <p>Grammars with multiple derivation trees are ambiguous. Are there languages for which any grammar is ambiguous? Such languages are called as <strong>inherently ambiguous</strong>.</p> <blockquote> <p><strong><em>Homework.</em></strong> Find examples of inherently ambiguous grammars.</p> </blockquote> <h2 id="simplifying-grammars">Simplifying grammars</h2> <p><strong><em>Definition.</em></strong> A variable \(B\) is productive in \(G\) iff \(B \xrightarrow[G]{*} w\) for some \(w \in \Sigma^*\).</p> <p><strong><em>Definition.</em></strong> A variable \(B\) is reachable from the start symbol \(S\) of \(G\) if \(S \xrightarrow[G]{*} \alpha B \beta\) for some \(\alpha, \beta \in (\Sigma \cup V)^*\).</p> <p>We useful variable \(X\) is productive and reachable. These are necessary conditions but not sufficient. For example, consider the following grammar.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S -&gt; AB
A -&gt; c
</code></pre></div></div> <p>Here, \(A\) is useless even if it is productive and reachable.</p> <p><strong><em>Definition.</em></strong> A variable \(X\) is useless if there is no derivation tree that gives \(w \in \Sigma^*\) from \(S\) with \(X\) as the label of some internal node.</p> <h3 id="fixed-point-algorithm">Fixed point algorithm</h3> <p>The idea is to find a monotonic algorithm which gives us the set of useful symbols at the fixed point of the underlying function.</p> <p>Firstly, let us try this for productive variables. We propose the following algorithm.</p> \[\begin{align} P_0 &amp;= \phi \\ P_i &amp;\to P_{i + 1} \\ &amp;\triangleq P_i \cup \{N \mid N \to \alpha \in R \text{ and } \alpha \in (\Sigma \cup P_i)^* \} \end{align}\] <p>For example, consider the grammar</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S -&gt; AB | AA
A -&gt; a
B -&gt; bB
-- The algorithm
P_o = \phi
P_1 = {A} // Rule 2
P_2 = {A, S} // Rule 1
P_3 = {A, S}
</code></pre></div></div> <p>Therefore, the symbols \(S, A\) are productive in the above grammar. We propose a similar algorithm for reachable states in the grammar.</p> \[\begin{align} R_0 &amp;= \phi \\ R_i &amp;\to R_{i + 1} \\ &amp;\triangleq R_i \cup \{P \mid Q \to \alpha P \beta; \alpha, \beta \in (\Sigma \cup P_i)^* \text{ and } Q \in R_i\} \end{align}\] <p><strong><em>Definition.</em></strong> A <strong>nullable</strong> symbol is a symbol which can derive \(\epsilon\). These symbols can be eliminated.</p> <p><strong><em>Definition.</em></strong> A unit production is a rule of the form \(A \to B\) where \(A, B \in V\).</p> <h1 id="lecture-14">Lecture 14</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">01-02-22</code></p> </blockquote> <p>We shall continue discussing simplifying grammars. As an initial step, we can get rid of symbols which are either unreachable or unproductive. However, the order in which we check productivity and reachability affects how the grammar is simplified. For example, consider the grammar</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S -&gt; a
S -&gt; AB
A -&gt; a
</code></pre></div></div> <p>Now, if we eliminate unreachable symbols first (that is none), and then eliminate unproductive symbols (\(B\)), we get</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S -&gt; a
A -&gt; a
</code></pre></div></div> <p>Notice that the above simplified grammar has a redundant rule. However, if we check for productivity (\(B\) is eliminated) and then reachability (\(A\) is unreachable), we get</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S -&gt; a
</code></pre></div></div> <p><strong><em>Claim.</em></strong> <u>Eliminating unproductive symbols followed by unreachable symbols gives a grammar without any useless variables.</u></p> <blockquote> <p><strong><em>Homework.</em></strong> Prove the above claim.</p> </blockquote> <h3 id="epsilon-productions">\(\epsilon\)-productions</h3> <p>Suppose \(G\) is a CFG such that \(L(G)\) has \(\epsilon\), then \(L(G) - \{\epsilon\}\) can be generated by a CFG \(G_1\) which has no \(\epsilon\)-productions (rules of the form \(A \to \epsilon\)).</p> <h3 id="nullable-symbols">Nullable symbols</h3> <p>\(A\) is <strong>nullable</strong> if \(A \xrightarrow[G]{*} \epsilon\).</p> <p>How do we remove nullable symbols? We can’t just take out a rule of the form \(A \to \epsilon\) as it may make \(A\) unproductive. The way to go about this is to replace each rule of the form \(A \to X_1\dots X_n\) to \(A \to \alpha_1 \dots \alpha_n\) where</p> \[\alpha_ i = \begin{cases} X_i &amp; X_i\text{ is not nullable}\\ \epsilon &amp;\text{otherwise} \end{cases}\] <p>However, one must be cautious about replacing all the symbols by \(\epsilon\) and also about recursive rules. For instance, consider the following grammar</p> \[S \to \epsilon \mid aSb \mid bSa \mid SS\] <p>Now, \(S\) is nullable but we can’t replace \(S \to aSb\) by \(S \to ab\) simply. We also need to have the rule \(S \to aSb\) in place for recursion. Basically, for each rule of the form \(A \to X_1\dots X_n\), we need to have all the rules of the form \(A \to \alpha\) where \(\alpha\) spans over all subsets of \(X_1 \dots X_n\).</p> <h3 id="unit-productions">Unit Productions</h3> <p>To remove unit productions, let us assume that there are no \(\epsilon\)-productions and useless symbols. Now, we need to find all pairs \((X, Y)\) such that \(X \xrightarrow[G]{*} Y\). Once we find such pairs, we can try and eliminate the unit symbols themselves, or solely the rules.</p> <p>Let us take the following grammar for \(L \{w \mid n_a(w) = n_b(w)\}\)</p> \[S \to \epsilon \mid aSb \mid bSa \mid SS \\ \text{ simplified to } \\ S \to abS \mid bSa \mid SS \mid ab \mid ba\] <p>and</p> \[S \to \epsilon \\ S \to aB \mid bA \\ B \to b \mid bS \mid aBB \\ A \to a \mid aS \mid bAA \\ \text{ simplified by just removing } S \to \epsilon\\\] <p>To convert the grammar into Chomsky normal form, we do approximately the following - we replace each rule of the form \(A \to X_1 \dots X_n\) with \(A \to X_1B\) and \(B \to X_2 \dots X_n\). We keep repeating this until there is only a single terminal symbol on the rhs, or two non-terminals.</p> <h1 id="lecture-15">Lecture 15</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">03-02-22</code></p> </blockquote> <p>Consider a grammar in Chomsky form. The derivation tree will consist of nodes with either 2 children (\(A \to BC\)), 1 child (\(A \to a\)) or leaf nodes.</p> <p>Let the longest path in the derivation tree be \(k\). Then, the upper bound on the length of the word formed is \(2^{k - 1}\) and lower bound is \(k\). <strong>Note.</strong> The variables from \(V\) can repeat across a path.</p> <h2 id="pumping-lemma-for-cfg">Pumping Lemma for CFG</h2> <p>For any CFL \(L\), the language \(L - \{\epsilon \}\) has a Chomsky Normal form grammar.</p> <p><strong><em>Theorem.</em></strong> <em>Pumping Lemma</em> For every CFL \(L\), there is a \(n\) such that for all strings \(\vert z \vert \geq n\) with \(z \in L(G)\), there are strings \(u, v, w, x, y\) such that \(z = uvwxy\) and</p> <ul> <li> \[\vert vwx \vert \leq n\] </li> <li> \[\vert vx \vert \geq 1\] </li> <li>for all \(z_i = u v^iwx^iy\), \(i \geq 0\), \(z_i \in L(G)\).</li> </ul> <p>It is easy to show \(L = \{a^nb^nc^n \mid n \geq 1\}\) is not a CFL using the above lemma.</p> <h3 id="proof-of-the-lemma">Proof of the lemma</h3> <p>If there is a \(z \in L(G)\) such \(\vert z \vert \geq n = 2^k\), then there must be a path of length at least \(k + 1\). Now, due to pigeonhole principle, a variable must repeat in this path in the derivation tree of \(z\).</p> <p>Now, consider the path \(S, \dots, A, \dots, A, \dots, a\).</p> <ul> <li>It is easy to the see that the word formed by the subtree below the first \(A\) has length \(\leq n\).</li> <li>Also, as there are 2 \(A\)s in the path, the number of letters in the “left” subtree and “right” subtree would be greater than 1.</li> <li>These “left” and “right” subtrees can be derived an arbitrary number of times as \(A\) can be derived from \(A\).</li> </ul> <p><em>Note.</em> To draw some more intuition, call the subtree formed by the first \(A\) as \(T_1\), and the subtree formed by the second \(A\) as \(T_2\). We shall label the word formed by \(T_2\) as \(w\), and the word labeled by \(T_1\) as \(vwx\). Now, \(\vert vx \vert \geq 1\). <em>Think.</em> The “left” and “right” subtree in the above explanation together are formed by the set \(T_1 \setminus T_2\).</p> <blockquote> <p><strong><em>Homework.</em></strong> Show that the following languages cannot be represented by CFG.</p> <ul> <li> \[L = \{a^ib^ic^i \mid j \geq i\}\] </li> <li> \[L = \{a^ib^jc^k \mid i \leq i \leq k\}\] </li> <li> \[L = \{a^ib^jc^id^j \mid i, j \geq 1\}\] </li> </ul> </blockquote> <p>We shall see that 2 stacks PDA is the most expressive Turing machine.</p> <blockquote> <p>Can’t there be useless symbols in normal forms? yes -&gt; \(S \to AB\)</p> </blockquote> <h2 id="ogdens-lemma">Ogden’s Lemma</h2> <p>This lemma is a generalization of pumping lemma. Consider the pumping lemma for the FSA. It basically said that some state must repeat for a string of length \(\geq n\) in the language. Ogden’s lemma talks about a similar claim for CFGs. It will be formally discussed in the next lecture.</p> <h2 id="closure-properties">Closure properties</h2> <p>The union, concatenation and Kleene closure of CFGs are also CFGs. Proof is left as a homework.</p> <p><strong>Intersection</strong> is not context-free!</p> <h1 id="lecture-16">Lecture 16</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">07-02-22</code></p> </blockquote> <h2 id="pushdown-automata">Pushdown Automata</h2> <p>Consider the languages \(L_1 = \{wcw^R \mid w \in (0 + 1)^* \}\) and \(L_3 = \{ww^R \mid w \in (0 + 1)^* \}\). Let us build PDAs for these two models.</p> <p>The stack of the PDA uses different symbols that those from \(\Sigma\). We shall denote the superset of symbols of stack by \(\Tau\). Each transition in the PDA depends on the input symbol and the symbol on the top of the stack. These are similar to the FSA transition diagram. If both of these symbols are satisfied for the transition, we perform <em>an action</em> on the stack by pushing or popping symbols. Note that we can also choose to not perform any action.</p> <p>We shall also use the symbol \(X\) to denote ‘matching any character’ for the symbols on stack. We can also have \(\epsilon\) transitions in non-deterministic PDAs. \(\epsilon\) transitions basically denote ignoring input symbols.</p> <p><strong>Note.</strong> We can push multiple symbols in each transition but we can only pop one symbol in each transition.</p> <p>The PDA for \(L_1\) is given by</p> \[\begin{align} \delta(q_1, c, X) &amp;= (q_2, X) \\ \delta(q_1, 1, X) &amp;= (q_1, GX) \\ \delta(q_1, 0, X) &amp;= (q_1, BX)\\ \delta(q_2, 0, B) &amp;= (q_2, \epsilon) \\ \delta(q_2, 1, G) &amp;= (q_2, \epsilon) \\ \delta(q_2, \epsilon, Z_0) &amp;= (q_2, \epsilon) \\ \end{align}\] <p>The PDA for \(L_3\) is similar but we cannot express this language without non-determinism. We can’t guess where the “middle of the string” occurs without <em>guessing</em>. Therefore, non-deterministic PDAs are more expressive than deterministic ones.</p> <p>Remember that the non-deterministic PDA accepts a string if there is at least one run that accepts it.</p> <h3 id="formal-definition-of-pda">Formal definition of PDA</h3> <p>A Pushdown automata is formally given by the 7 element tuple \(M \lang Q, \Sigma, \Tau, \delta, q_0, Z_0, F \rang\) where</p> <ul> <li>\(\Tau\) is the set of stack symbols</li> <li>\(Z_0\) is a special symbol denoting the bottom of the stack</li> <li>\(F\) is the set of final states of the automata</li> <li>\(\delta: Q \times (\Sigma \cup \epsilon) \times \Tau \to (Q, \lambda)\) where \(\lambda \in \Tau^*\) is an action performed on the transition.</li> </ul> <p>A string is accepted if one of the runs ends with an empty stack or at a final state. That is, \(L(M) = \{w \mid (q_0, w, Z_0) \vdash^*_M (p, \epsilon, \epsilon)\} \cup \{ w \mid (q_0, w, Z_0) \vdash^*_M (q, \epsilon, \lambda), q \in F\}\). In the following lectures, we shall prove DPDA \(\neq\) NPDA, ‘accepting by empty stack’ \(\equiv\) ‘accepting by final state’ and PDA (NPDA) \(=\) CFG.</p> <h1 id="lecture-17">Lecture 17</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">08-02-22</code></p> </blockquote> <p>We shall continue the formal description of PDAs.</p> <p>We define a <strong>move</strong> or an <strong>arrow</strong> as a transition in the PDA.</p> <p><strong>Instantaneous Description</strong> refers to the property of defining a system using a <em>single number</em>. In case of a PDA, the description is given by a numerical representation of (Current string, Remaining input tape, Stack content). These values, that constitute the dynamic information of a PDA, keep changing during moves. The notation \(ID_1 \vdash_M ID_2\) denotes a single transition in the PDA. The notation \(ID_1 \vdash^*_M ID_2\) is a sequence of 0 or more moves.</p> <p>We have seen the <strong>accept criteria</strong> in the last lecture. We will show that a PDA built on the final state accept criteria has an equivalent PDA built on the empty state accept criteria.</p> <h2 id="greibach-normal-form">Greibach Normal Form</h2> <p>CFGs of the form \(A \to a\alpha\).</p> <p><strong>Note.</strong> \(\alpha\) in the above expression consists of non-terminals only!</p> <p>What are the challenges involved in converting a grammar to a Greibach normal form? It involves the following steps.</p> <h3 id="elimination-of-productions">Elimination of productions</h3> <p>Suppose we want to remove the rule \(A \to \alpha_1 B \alpha_2\) and keep the language of the CFG same. Then, we consider all rules of the form \(B \to \beta\) and replace each of them by \(A \to \alpha_1 \beta \alpha_2\). After doing this, we can delete the initial production involving \(A\).</p> <h3 id="left-recursion">Left Recursion</h3> <p>Suppose we have rules of the form \(A \to A\alpha_1 \mid A\alpha_2 \mid \dots \mid A\alpha_r\) which we wish to remove. Now, there would be other rules involving \(A\) of the form \(A \to \beta_1 \mid \dots \mid \beta_s\).</p> <p>Now, we define a new variable \(B \not\in V\). Then, we write rules of the form \(A \to \beta_1B \mid \dots \mid \ \beta_s B\) and \(\beta \to \alpha_1 B \mid \dots \mid \alpha_r B\). We can then remove all the left-recursive productions of \(A\). Basically, we have replaced left-recursion rules with right-recursion rules.</p> <h3 id="ordering-of-variables">Ordering of Variables</h3> <p>Simplify the variables in one order? <em>Wasn’t taught?</em></p> <h2 id="equivalence-of-pda-and-cfg">Equivalence of PDA and CFG</h2> <p>Given any CFG \(G\), we convert it into Greibach normal form. Then, we choose the non-terminals as the stack symbols. The initial symbol in the grammar is taken as the top symbol of the stack initially. For each rule \(A \to a\alpha\) we write the transition \(\delta(q, a, A) = (q’, \alpha)\). We start with a single state in the DFA, and write all the rules on this state. Through this intuition, we have shown that every CFG has a corresponding PDA. Then, we need to show that every PDA has a corresponding CFG.</p> <p>To show that CFG \(\subseteq\) PDA, we need to show the equivalence of a language in both directions. That is, for every string accepted by the CFG, we need to show that the PDA also accepts it and vice versa. Note that we also have to prove PDA \(\subseteq\) CFG.</p> <h1 id="lecture-18">Lecture 18</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">10-02-22</code></p> </blockquote> <p>We will continue the equivalence proof now.</p> <p>## Ogden’s Lemma revisited</p> <p>Suppose we had to prove the language \(L = \{a^ib^jc^kd^l \mid i = 0 \text{ or } j = k = l\}\) is not CFG. Can we do this using pumping lemma? No. <em>Think</em>.</p> <p>We do this using Ogden’s lemma which goes something like this. You can give a \(z = z_1 \dots z_m\) such that \(m \geq n\). Now, we can mark positions by choosing a subset of \(z_i\)’s. Then, the \(vwx\) from the pumping lemma must have at most \(n\) marked positions and \(vx\) has at least one marked position. This is a stronger condition as compared to the pumping lemma.</p> <blockquote> <p><strong><em>Homework.</em></strong> Show that \(L = \{a^ib^jc^k \mid i \neq j, j \neq k, i \neq k\}\) is not context-free using Ogden’s lemma.</p> </blockquote> <h2 id="closure-properties-of-cfls">Closure properties of CFLs</h2> <ul> <li> <strong>Union</strong> - \(L(G_1) \cup L(G_2)\) regular? Yes. Add a rule \(S \to S_1 \mid S_2\).</li> <li> <strong>Kleene closure</strong> - \((L(G_1))^*\) regular? Yes. Add a rule \(S \to S_1S \mid \epsilon\).</li> <li> <strong>Concatenation</strong> - \(L(G_1). L(G_2)\) regular? Yes. Add a rule \(S \to S_1 S_2\).</li> <li> <strong>Intersection</strong> - Consider the example \(L_1 = \{a^ib^ic^j \mid i, j \geq 1\}\) and \(L_2 = \{a^ib^jc^i \mid i, j \geq 1\}\). Both of them are context free but their intersection is not.</li> <li> <strong>Complement</strong> - Easy to show from intersection.</li> </ul> <h2 id="decision-properties-of-cfls">Decision properties of CFLs</h2> <h3 id="is-the-language-empty">Is the language empty?</h3> <p>This is easy to check. Remove useless symbols and show that \(S\) is useful.</p> <h3 id="is-the-language-finite">Is the language finite?</h3> <p>Consider the Chomsky normal form of the grammar. <u>Draw a graph corresponding to the grammar such that every node has a single edge directed to a terminal or two edges directed to non-terminals</u>.</p> <p><strong><em>Claim.</em></strong> If the graph has a cycle, then the language formed by the grammar is infinite. This is intuitive.</p> <p>We can find cycles using DFS simply.We can derive more efficient methods which is not the goal of this course.</p> <h3 id="does-a-string-belong-to-the-language">Does a string belong to the language?</h3> <p>The first approach is the following. Get the Greibach form of the grammar. Now, for each letter \(c\) in the string check whether there are rules of the form \(A \to c\alpha\). We consider the values of all such \(\alpha\)s and continue parsing the rest of the input string. Therefore, at each letter in the string we limit the number of possible derivations. If we reach the end of the string without running out of possible derivations at each letter, then the string belongs to the language. Remember that we will start with the start symbol for the beginning of the string.</p> <p>However, we can see that this method is not very efficient. We shall see the CYK algorithm which works in \(\mathcal O(n^3)\).</p> <h1 id="lecture-19">Lecture 19</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">14-02-22</code></p> </blockquote> <h2 id="additional-closure-properties-of-cfls">Additional closure properties of CFLs</h2> <ul> <li> <p>\(L(G) \cap R\), where \(R\) is a regular language, is also context-free.</p> <p>How do we show that \(L = \{ww \mid w \in (a + b)^*\}\) is not context free? It can be shown via pumping lemma which is complicated. However, it is very easy to prove it using the above property.</p> <p>How do we prove the closure property? Consider a \(PDA(M_1)\) for \(L(G)\) and \(DFA(M_2)\) for \(R\). Now, we construct a ‘product’ PDA similar to what we did in NFAs. We use the ‘final state’ accept PDA for the purpose. The final states would be \(F_1 \times F_2\). It is easy to see that we can get the required property.</p> </li> </ul> <h2 id="cyk-algorithm">CYK algorithm</h2> <p>The Cocke-Younger-Kasami algorithm can be used to check if a string \(w\) belongs to \(L(G)\).</p> <p>Suppose there is a \(w = w_1 w_2 \dots w_i \dots w_l \dots w_n\) whose membership we need to check. We consider subproblems of the form: Is \(w_{ij} \triangleq w_i \dots w_{i + j - 1}\) derivable from any non-terminal in the grammar? Then, finally, we need to answer is \(w_{1n}\) can be derived from \(S\).</p> <p>We consider the Chomsky normal form of the grammar for this algorithm. All strings of the form \(w_{j1}\) can be checked easily. For each \(w_{i1}\) we store all the non-terminals that can derive it. Now, the recursion for all \(j \geq 2\) is given by</p> \[f(w_{in}) = \bigcup_{j = 1}^{n - 1}\bigcup_{A \in f(w_{ij})} \bigcup_{B \in f(w_{i(n - j)})} \{C \mid (C \to AB) \in G \}\] <p>See the following example using the CYK algorithm.</p> <p><img src="/assets/img/Automata/image-20220222011041265.png" alt="image-20220222011041265"></p> <p>It is easy to see that this algorithm takes \(\mathcal O(n^3)\).</p> <h1 id="lecture-20">Lecture 20</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">15-02-22</code></p> </blockquote> <h3 id="epsilon-closure">\(\epsilon\) closure</h3> <p>We define \(\epsilon\) closure for a state \(q\) in a DFA as all the states that \(q\) can reach via \(\epsilon\) transitions. Then, to remove all the \(\epsilon\) transitions from \(q\), we add a transition corresponding to all transitions from \(q\) to each of the states in the \(\epsilon\) closure of \(q\). Also, if any state in the \(\epsilon\) closure of \(q\) is final, then \(q\) can also be made as a final state.</p> <p><strong>Note.</strong> Minimal DFAs need not be unique. They are isomorphic.</p> <h1 id="lecture-21">Lecture 21</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">28-02-22</code></p> </blockquote> <h2 id="satan-cantor-game">Satan-Cantor Game</h2> <p>The game goes like this. Satan chooses a random natural number and asks Cantor to guess the number. Cantor gets a chance to guess once on each day. If Cantor guesses the right number, then he can go to heaven. Does Cantor have a strategy that will guarantee him going to heaven? Yes, Cantor can choose numbers in the sequence \(1, 2, 3, \dots\) and eventually <em>it is guaranteed</em> that Cantor chooses the correct number.</p> <p>Suppose, Satan changes the game by choosing a random integer. Does Cantor have a strategy then? Yes, choose numbers of the form \(0, 1, -1, 2, -2, \dots\). Now, suppose Satan chooses a pair of integers, then how do we get a strategy? We can order the points based on the distance from the origin in the 2D Cartesian plane (<strong>Cantor’s pairing function</strong>). Similarly, a tuple of \(n\) integers is also enumerable.</p> <p>Can we give a set for Satan such that the elements are not enumerable? What if Satan chooses \((n_1, \dots, n_k)\) where \(k\) is not known to Cantor. Can Cantor win in this case? Yes. <em>Proof is homework</em>.</p> <p>Satan can choose the set of real numbers, and in that scenario Cantor would not be able to win. The key idea here is <a href="https://www.cse.iitb.ac.in/~mp/teach/ds/aut19/slides/21.pdf" rel="external nofollow noopener" target="_blank"><strong>Cantor’s diagonalization argument</strong></a>.</p> <p>Also, look up <a href="https://en.wikipedia.org/wiki/Kolmogorov_complexity" rel="external nofollow noopener" target="_blank">Kolmogorov complexity</a>. Enumerability \(\equiv\) Countability.</p> <h2 id="enumerability-in-languages">Enumerability in Languages</h2> <p>A language which is finite will be regular, and we can build an FSA for it. How about infinite languages? CFLs can represent a subset of these languages.</p> <p>If we categorise the infinite languages as languages which are <u>recursively enumerable</u> and <u>uncountable</u>. Can we build models for recursively enumerable languages?</p> <h2 id="turing-machines">Turing Machines</h2> <p>Turing wanted to build a machine that could recognize any enumerable language. The inspiration is drawn from the <em>recursive function theory</em> developed by Alonzo Church. There are other people who developed <strong>Type-0 grammars</strong> which are similar to CFGs but the left hand side of the rules can consist of a string composed of terminals and non-terminals making it context-dependent.</p> <p>Church and Turing came up with a thesis, and they proposed that Church’s theory and Turing’s machine can be used to compute any <em>effectively computable</em> function.</p> <blockquote> <p><strong><em>Aside.</em></strong> Aren’t all languages enumerable with alphabet being a finite set?</p> </blockquote> <p>“Is \(L(G)\) empty?” is a decidable problem. However, “Is the complement of \(L(G)\) empty?” is not decidable! This property was proven by Godel.</p> <p>We shall now introduce the notion of Turing machines. Instead of a stack, we have an <strong>input tape</strong> with a <em>fixed left end</em>. A string is written in the tape with each letter being in a <strong>cell</strong> of the tape. The machine also involves a control which is essentially a FSM that takes the input from the tape, and performs actions on it. Basically, in PDAs, we could only see the top of the stack, but here we are able to freely traverse over the tape.</p> <h2 id="definitions-from-set-theory">Definitions from set theory</h2> <p><strong><em>Definition.</em></strong> <strong>Enumerable</strong> of a set refers to the property of being able to define a one-to-one correspondence from the elements of the set to positive integers.</p> <p><strong><em>Definition.</em></strong> In computability theory, a set \(S\) of natural numbers is called computably enumerable, recursively enumerable, semi-decidable, partially decidable, listable, provable or Turing-recognisable if</p> <ul> <li>there is an algorithm such that the set of input numbers for which the algorithm halts is exactly \(S\).</li> <li>or equivalently, there is an algorithm that enumerates the members of \(S\). That means that its output is simply a list of all the members of \(S = \{s_1, s_2, s_3, \dots\}\) . If \(S\) is infinite, this algorithm will run forever.</li> </ul> <h1 id="lecture-22">Lecture 22</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">07-03-22</code></p> </blockquote> <h2 id="dovetailing">Dovetailing</h2> <p>In the Satan-Cantor game, the idea was to enumerate all possible answers “fairly”.</p> <p>Let us consider the scenario where Satan chooses a \(k\) tuple of integers where \(k\) is unknown. How do we enumerate this set? We use dovetailing for the same. Consider the tuple \((k, n)\). For one such given tuple, we will enumerate all \(k\)-tuples with distance from origin being less than \(n\). The idea is that we are balancing the enumeration across two dimensions, \(k\) and \(n\), together.</p> <h2 id="cantors-diagonalization">Cantor’s diagonalization</h2> <p>How is the above set different from the power set of natural numbers? Let us consider the question in terms of languages. Consider a language \(L \subseteq \Sigma^*\) with a finite \(\Sigma\). \(\Sigma^*\) is enumerable (\(\epsilon, a, b, c, aa, ab, ac, \dots\)). Now, is the set of all languages \(\mathcal L\) enumerable? We know that \(\mathcal L = 2^{\Sigma^*}\).</p> <p>We shall use contradiction to show that the set is not enumerable. Consider the following table -</p> <table> <thead> <tr> <th> </th> <th>\(\epsilon\)</th> <th>\(a\)</th> <th>\(\dots\)</th> </tr> </thead> <tbody> <tr> <td>\(L_1\)</td> <td>1</td> <td>0</td> <td> </td> </tr> <tr> <td>\(L_2\)</td> <td>1</td> <td>1</td> <td> </td> </tr> <tr> <td>\(\vdots\)</td> <td> </td> <td> </td> <td>\(\ddots\)</td> </tr> </tbody> </table> <p>The table consists of all the languages (assuming they are enumerable) with the respective strings in the language tagged as 1. Define the language \(L_{new} = \{w_i \mid w_i \not \in L_i\} \forall i \in \mathcal N\). We then have a contradiction that \(\exists L_{new}\) such that \(l_{new} \neq L_i\) for any \(i\).</p> <p><strong>Claim.</strong> The state of every computer can be encoded as a <em>single</em> number.</p> <h2 id="turing-machines-2">Turing Machines (2)</h2> <p>The machine can do the following things</p> <ul> <li>Replace the symbols on the tape by symbols in \(T\) where \(\Sigma \subseteq T - \{B\}\). \(B\) is a blank symbol to denote an empty cell</li> <li>Move left or right by one step</li> <li>Go to the next state</li> </ul> <p>So, the labels on the transitions of the FSM are of the form \(X \mid Y, D\) where \(X, Y \in T\) and \(D = L \mid R\). It means that the symbol \(X\) in the cell is replaced by the symbol \(Y\). The machine has to <em>definitely</em> move left or right in each transition. A “run” starts from the first cell and the state \(q_0\) in the FSM. As an example, we consider the following FSM for the language \(L = \{0^n1^n \mid n \geq 1\}\).</p> <p><img src="/assets/img/Automata/image-20220312155130493.png" alt="image-20220312155130493"></p> <p><strong>TODO</strong> Draw the above diagram again.</p> <p>In a Turing machine, we halt when there is no move possible.</p> <p>Formally, a Turing machine is defined as \(T = (Q, \Sigma, T, \delta, q_0, B, F)\) where \(\delta: Q \times T \to Q \times T \times \{L, R\}\). There are many variations possible to this machine which we shall show are equivalent to this simple definition. For example, we can have multiple tapes, output tape, non-determinism, etc.</p> <h1 id="lecture-23">Lecture 23</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">08-03-22</code></p> </blockquote> <blockquote> <p>Is countable same as enumerable? Countable implies that there is a one-to-one mapping from the elements in the set to natural numbers. This definition is equivalent to that of enumerability.</p> <p>A Turing machine can enumerate a language. A language is <strong>recursively enumerable</strong> if a Turing machine can enumerate it.</p> <p>\(\Sigma^*\) is enumerable but there are languages in \(\Sigma^*\) which are not enumerable.</p> </blockquote> <p>The theory of Turing machines was developed in the 1930s.</p> <p>Consider the derivation \((q_0, w_{inp}) \vdash^*_M (q_k, x)\) where the machine halts. A machine halts when there is no move at any given state. If \(q_k \in F\) and the machine \(M\) halts, then \(M\) accepts \(w_{inp}\).</p> <h3 id="variations-of-turing-machines">Variations of Turing Machines</h3> <ul> <li>2-way infinite tapes</li> <li>Multi-tape heads</li> <li>Non-determinism</li> <li>Output type (write only, immutable)</li> </ul> <p>Let us try and build the Turing machine for \(L = \{a^nb^nc^n \mid n \geq 1\}\). We’ll use the following logic. In each pass, we will change 1 a, 1 b and 1 c to X, Y and Z respectively. If we have any extra a’s, b’s or c’s, then we will halt.</p> <p><img src="/assets/img/Automata/image-20220312183041093.png" alt="image-20220312183041093"></p> <p>The machine is given in the above diagram.</p> <blockquote> <p><strong><em>Homework.</em></strong> Draw a Turing machine for the language \(L = \{ww \mid w \in (a + b)^+\}\). Hint - Think of subroutines. That is, tackle smaller problems like “Find the middle of the string”, and then match left and right.</p> <p><strong><em>Homework.</em></strong> Try \(L = \{a^n \mid n \text{ is prime}\}\)</p> </blockquote> <h2 id="type-0-grammars">Type-0 Grammars</h2> <p>These are also known as <strong>Unrestricted grammars</strong>. These are essentially same as CFGs but the LHS of rules can be any string. Consider the language \(L = \{a^nb^nc^n\mid n \geq 0\}\). The grammar can be as follows</p> \[\begin{align} S &amp;\to ABCS \mid T_c \\ CA &amp;\to AC \\ BA &amp;\to AB \\ CB &amp;\to BC \\ CT_c &amp;\to T_cc \\ BT_b &amp;\to T_bb \\ AT_a &amp;\to T_aa \\ T_c &amp;\to T_b \\ T_b &amp;\to T_a \\ T_a &amp;\to \epsilon \end{align}\] <p>If one notices closely, then there are a few issues with this grammar. However, it is correct considering non-determinism. That is, a terminal string derived from this grammar will be in \(L\).</p> <blockquote> <p><strong><em>Homework.</em></strong> Write the Type-0 grammar for \(L = \{ww \mid w \in (a + b)^+\}\)</p> </blockquote> <h1 id="lecture-24">Lecture 24</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">10-03-22</code></p> </blockquote> <p>Let us go back to the \(L = \{a^nb^nc^n\}\) language. How do we come up with a deterministic grammar? We use the idea of <strong>markers</strong>.</p> <ul> <li> <p>1-end marker</p> \[\begin{align} S &amp;\to S_1$ \\ S_1 &amp;\to ABC \mid ABCS_1 \\ CA &amp;\to AC \\ CB &amp;\to BC \\ BA &amp;\to AB \\ C$ &amp;\to c ,\; Cc \to cc \\ Bc &amp;\to bc ,\; Bc \to bb \\ Ab &amp;\to ab ,\; Aa \to aa \\ \end{align}\] <p>The problem with the above grammar is obvious. This issue is often prevented using priority rules in hierarchical grammars. Another fix for this is, adding the following set of rules</p> \[\begin{align} Ca &amp;\to aC ,\; ca \to ac\\ Cb &amp;\to bC ,\; cb \to bc\\ Ba &amp;\to aB ,\; ba \to ab \end{align}\] <blockquote> <p>Check if this is correct</p> </blockquote> </li> <li> <p>2-end marker</p> </li> </ul> <h3 id="tm-as-a-recogniser">TM as a recogniser</h3> <p>Are the set of moves on a TM a decision procedure? A decision procedure refers to a procedure that outputs yes or no for a given input. It involves <em>correctness</em> and <em>termination</em>. No, TM does not do that. For example, consider never halting TMs. Therefore, TM is a semi-decision procedure. In order to classify TM as a decision procedure, we need to show that it halts on every input. Also, we need to show that it gives the correct answer.</p> <h3 id="tm-as-a-computer">TM as a “computer”</h3> <p>Can TM replicate any function of the form \(y = f(X_1, \dots, X_n)\) where the arguments belong to $\mathbb N$. Yes, it can be done. What should a Turing machine do when we give invalid arguments to partial functions? It should never halt. On total functions, the TM must always halt and give the correct answer. For example, we have the following TM for \(f(x, y) = max(0, x - y)\). Numbers \(x\) and \(y\) are written consecutively on the tape in unary form separated by a \(1\).</p> <p><img src="/assets/img/Automata/image-20220328173509367.png" alt="image-20220328173509367"></p> <h1 id="lecture-25">Lecture 25</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">14-03-22</code></p> </blockquote> <p>If the TM has to halt when \(w \not \in L\), then we shall see that this set of TMs will only recognise recursively enumerable languages. For TMs to accept all the enumerable languages, we must allow the TM to not halt for certain inputs.</p> <h3 id="tm-as-an-enumerator">TM as an enumerator</h3> <p>Such TMs do not take any input. It continuously writes input on the tape and never halts. The TM prints a sequence that looks like the following \(w_1 \# w_2 \# \dots\) for each \(w_i \in L\). The machine halts if \(L\) is finite, but doesn’t otherwise. \(L\) is recursively enumerable iff a TM can enumerate the language.</p> <p><strong>Semi-Decision Procedure</strong> - Given \(M_1\) for \(L\) as an enumerator, construct \(M_2\) as a recogniser for \(L\). In \(M_2\), we can just check if the given input is present in the list of words printed by \(M_1\). Now, we have come up with a semi-decision procedure based on an enumerator.</p> <p>Our goal is to determine if there are any functions that cannot be computed by TMs. Or rather, are there any languages that TM cannot enumerate or recognise. Enumeration and Recognition are equivalent (hint: dovetailing).</p> <h2 id="recursive-function-theory">Recursive Function Theory</h2> <p>Let \(N = \{0, 1, \dots\}\). Any function we consider will be of the form \(f: N^k \to N\). How do we define these functions? We start with base cases and recursion. To define these functions, we shall define some basic functions that will be used to define the others.</p> <ul> <li> <strong>Constant function</strong> - \(C^k_n(x_1, \dots, x_k) = n\) for all \(x_1, \dots, x_k \in N\).</li> <li> <strong>Successor functions</strong> - \(S(x) = x + 1\).</li> <li> <strong>Projection function</strong> - \(P^k_i(x_1, \dots, x_i, \dots, x_k) = x_i\) for \(1 \leq i \leq k\).</li> </ul> <p>We move on to more primitive recursive functions.</p> <ul> <li> <strong>Composition</strong> - \(f(x_1, \dots, x_k) = h(g_1(x_1, \dots, x_k), \dots, g_m(x_1, \dots, x_k))\)</li> </ul> <p>Primitive recursion is given by</p> <ul> <li> <strong>Basecase</strong> - \(f(0, x_1, \dots, x_k) = g(x_1, \dots, x_k)\)</li> <li> <strong>Recursion</strong> - \(f(S(y), x_1, \dots) = h(y, f(y, x_1, \dots, x_k), x_1, \dots, x_k)\)</li> </ul> <p>For example, the formal definition of \(+\) is given by</p> \[\begin{align} +(0, x) &amp;= P^1_1(x) \\ +(S(y), x) &amp;=h(y, +(y, x), x) \\ h(y, +(y, x), x) &amp;= S(+(y, x)) \end{align}\] <p>There are functions which are not primitive recursive.</p> <h1 id="lecture-26">Lecture 26</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">15-03-22</code></p> </blockquote> <p>We shall see that primitive recursion is not expressive enough, Adding “minimization” to our set of rules will help us define any total function. We shall also see <strong>Equational Programming</strong> that is Turing-complete.</p> <p>As we have seen earlier, we are using 3 base functions - constant, successor, and projection. Composition is depicted as \(f = h \circ (g_1, \dots, g_m)\).</p> <p>Primitive-Recursion in layman’s terms refers to recursion using for loops. We write the functions as \(f = \rho(g, h)\) where \(g, h\) are the same functions that are used in the recursive definition. For example, \(add \triangleq \rho(P_1^1, S \circ P_2^3)\). The recursion must be of this form. The formal definition of \(mult\) is given by \(mult \triangleq \rho(C_0^1, add \circ (P_1^3, P_2^3))\).</p> <p>How do we write functions such as \(div\). Do we need <code class="language-plaintext highlighter-rouge">if-then-else</code> notion in our theory? Before we define this, let us try to define \(prev\) functions. We will define that \(prev(0) = 0\) for totality of the function. Then, we can define the function as \(prev \triangleq \rho(C_0^0, P_1^2)\). Using, \(prev\) we can define \(monus\) as \(monus(y, x) = x \dot- y \triangleq \rho(P_1^1, prev \circ P_2^3)\).</p> <p>Now, to introduce the notion of booleans, we define \(isZero \triangleq \rho(C_1^0, C_0^2)\). We can use this function to utilise booleans. Similarly, \(leq \triangleq \rho(C_1^1, isZero \circ monus \circ (S \circ P_1^3, P_3^3))\). Using similar logic, we can implement looping and branching.</p> <h1 id="lecture-27">Lecture 27</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">17-03-22</code></p> </blockquote> <p>We will now see the limitations of primitive-recursion.</p> <h2 id="limitations-of-primitive-recursion">Limitations of primitive recursion</h2> <p>We have seen composition as \(h \circ (g_1, \dots, d_n)\). This concept is equivalent to passing parameters to functions in programming. To refresh the shorthand notion of primitive recursive functions, we define if-then-else as \(if\_then\_else(x, y, z)\) as \(y\) when \(x &gt; 0\) and \(z\) otherwise. Therefore, \(if\_then\_else(x, y, z) = \rho(P_2^2, P_3^4)\). Using this, we define</p> \[\begin{align} quotient(x, y) &amp;\triangleq \rho ( ite \circ (P_1^1, 0, \infty), \\ &amp; ite \circ (P_3^3, ite \circ ( \\ &amp;monus \circ (mult \circ (P_3^3, S\circ P_2^3) , \\ &amp;S \circ P_1^3) , P_2^3 , S \circ P_2^3), \infty) ) \end{align}\] <h3 id="ackermann-function">Ackermann function</h3> <p>Many mathematicians tried to show that primitive recursion is not enough to represent all functions. In this pursuit, Ackermann came up with the following function</p> \[\begin{align} A(0, x) &amp;= x + 1\\ A(y + 1, 0) &amp;= A(y, 1) \\ A(y + 1, x + 1) &amp;= A(y, A(y + 1, x)) \\ \end{align}\] <p>Similarly, there is a ‘91-function’ that Mc Carthy came up with. It is given as</p> \[M_c (x) \begin{cases} x - 10 &amp; x&gt; 100 \\ M_c(M_c(x + 11)) &amp; \text{otherwise} \end{cases}\] <p>The above function always returns \(91\) for \(x &lt; 100\). However, it requires a lot of recursive calls for evaluating its value.</p> <h3 id="all-primitive-functions-are-total">All primitive functions are total</h3> <p>The converse of the above statement is false. For example, the Ackermann function is not primitive. The idea is to show that any \(f\) defined using primitive recursion grows slower than \(A(n_f, y)\) for some \(n_f\). Using <em>Godel numbering</em> we can count all the possible primitive recursive functions.</p> <h2 id="partial-recursive-functions">Partial Recursive functions</h2> <p>We use the idea of <strong>minimisation</strong> to define partial functions and also increase the expressive power of our definitions. We have the following definition</p> \[\mu(f)(x_1, \dots, x_k) \triangleq \begin{cases} z &amp; \forall z_1 &lt; z \; f(z_1, x_1, \dots, x_k) &gt; 0 \land f(z, x_1, \dots, z_k) = 0\\ \end{cases}\] <p>Notice that the first case in the above definition behaves like a while loop, as it gives the smallest value of \(z\) that renders the function zero. The ‘partiality’ in the function definition comes from the fact that \(f\) may never be zero.</p> <p><u>The Church-Turing thesis states that all definable functions that can be defined using primitive recursion, minimisation, and substitution can be computed by a Turing machine.</u> There is no proof for this yet. The set of these functions is the set of ‘all effectively computable functions’. However, there are undecidable functions that are not computable by a TM.</p> <h2 id="equational-logic">Equational Logic</h2> <p>This paradigm has the same expressive power as primitive recursion but is easier to express. To start off, we consider the function \(leq\). We will define \(N\) as \(\{0, S(0), S(S(0)), \dots\}\). We write the rules as</p> \[\begin{align} leq(0, x) &amp;= S(0) \\ leq(S(x), 0) &amp;= 0 \\ leq(S(x), S(y)) &amp;= leq(x, y) \end{align}\] <p>This way of writing rules is known as <strong>Pattern matching</strong>. Similarly, \(gcd\) is given by</p> \[\begin{align} gcd(0, x) &amp;= x \\ gcd(add(x, y), x) &amp;= gcd(y, x) \\ gcd(y, add(x, y)) &amp;= gcd(y, x) \\ \end{align}\] <p>In the above definition, the pattern matching is <em>semantic</em> and not <em>syntactic</em>. The <em>syntactic</em> pattern matching definition uses \(if\_then\_else\). However, note that \(if\_then\_else\) is always assumed to be calculated in a <strong>lazy manner</strong>. That is, the condition is evaluated first and the corresponding branch is then evaluated. If the expressions in the two branches are evaluated along with the condition, then there is a chance that the computation never ends.</p> <p>Also, the factorial function \(fact\) is given by</p> \[\begin{align} fact(0) &amp;= S(0) \\ fact(S(x)) &amp;= mult(S(x), fact(x)) \end{align}\] <p>Another way of writing the factorial function using <strong>tail recursion</strong> is</p> \[\begin{align} f(x) &amp;= f_a(1, x) \\ f(y, 1) &amp;= y \\ f_a(y, S(x)) &amp;= f_a(y\times S(x), x) \end{align}\] <p>Notice that the first definition of \(fact\) is very inefficient compared to the latter. The second definition does inline multiplication with the arguments carrying the answer. However, the values are pushed on to the stack in the case of the first definition. These concepts of optimisation come to great use in building compilers.</p> <h1 id="lecture-28">Lecture 28</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">21-03-22</code></p> </blockquote> <h2 id="term-rewriting">Term-rewriting</h2> <p>We have seen 3 computation paradigms</p> <ul> <li>Turing machine</li> <li>Type-0 grammars</li> <li>Partial recursive functions</li> </ul> <p>Now, we shall see a 4th paradigm called as term rewriting.</p> <p>We have <strong>terms</strong> and <strong>domains</strong>. There a few constructors involved with a domain. For example, we have \(0, S\) for \(N\). Also, for lists we have \(nl\) (empty list) and \(\bullet\) (cons/pipe). We use them as follows</p> <p><img src="/assets/img/Automata/image-20220330010921594.png" alt="image-20220330010921594"></p> <p>There are also constants (\(0\)) and function symbols/constructors (\(S\)). Termination is guaranteed in normal forms. We also want unique normal form. This will ensure that a term gives a single answer with different recursions (<strong>confluence</strong>). If we get two answers, we call it ill-defined systems.</p> <p>To understand this better, we shall define \(exp\).</p> \[\begin{align} exp(x, 0) &amp;= s(0) \\ exp(x, S(y)) &amp;= mult(x, exp(x, y)) \end{align}\] <p>\(max\) is defined as</p> \[\begin{align} max(0, y) &amp;= y \\ max(S(x), S(y)) &amp;= max(x, y) \\ max(x, 0) &amp;= x \\ \end{align}\] <h3 id="lists">Lists</h3> <p>Suppose we want to define \(app\). We then have</p> \[\begin{align} app(nl, y) &amp;= y \\ app(\bullet(x, y), z) &amp;= \bullet(x, app(y, z)) \end{align}\] <p>Similarly,</p> \[\begin{align} rev(nl) &amp;= nl \\ rev(\bullet(x, y)) &amp;= app(rev(y), \bullet(x, nl)) \end{align}\] <blockquote> <p><strong><em>Homework.</em></strong> Show that \(len(x) = len(rev(x))\)</p> </blockquote> <p>How do we sort a list of numbers?</p> \[\begin{align} sort(nl) &amp;= nl \\ sort(\bullet(x, y)) &amp;= ins(x, sort(y)) \\ ins(x, nl) &amp;= \bullet(x, nl) \\ ins(x, \bullet(y, z)) &amp;= \bullet(\min(x, y), ins(\max(x, y), z)) \end{align}\] <blockquote> <p><strong><em>Homework.</em></strong> Try quick sort and merge sort.</p> </blockquote> <h3 id="termination">Termination</h3> <p>We have termination on \(N\) due to \(&gt;\). How about \(N \times N\)? We use <strong>lexicographic ordering</strong>. One might think it’s not well-founded. This is because \((9, 1)\) is greater than \((5, 1000)\). However, it is well-founded for finite length tuples. In case of strings, the length need not be finite in lexicographic ordering. Therefore, the ordered list need not be finite.</p> <blockquote> <p><strong><em>Homework.</em></strong> Give an ordering rule for multi-sets</p> </blockquote> <h3 id="predicates-and-branching">Predicates and Branching</h3> <p>It is easier to express these things in the term-rewriting paradigm. I’m skipping these for brevity.</p> <p>Can we write \(isPrime\), \(gcd\), and \(nth-prime\)? This paradigm naturally develops to Functional Programming. It’s essentially writing everything in terms of functions as we’ve been doing so far.</p> <h3 id="logic-programming">Logic Programming</h3> <p>Suppose we give the black-box the input \(x + 3 = 10\). Can we determine \(x\)? Can we ask multiple answers in case of \(u + v = 10\)? It is possible to do so in logic programming. We do this by <u>passing parameters by unification</u>. That is, we try to convert the parameters \(u, v\) to look like the parameters given in the rules of \(+\). This is known as <strong>backtracking</strong>.</p> <h1 id="lecture-29">Lecture 29</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">22-3-22</code></p> </blockquote> <p>Term matching is don’t care non-determinism. There might be multiple possible reductions at any given situation, and all will lead to the same answer in case of well-formed normal forms. Also, all the paths should terminate.</p> <p>What are the strategies for computing normal forms?</p> <ul> <li> <strong>Hybrid</strong> - Check if sub-term matches rule-by-rule</li> <li> <strong>Innermost</strong> - Many programming languages adopt this. Evaluate the “lowest” redex first.</li> <li> <strong>Outermost</strong> - This is lazy evaluation. We evaluate topmost redex first.</li> </ul> <p>Redex is a sub-term where a rule can be applied.</p> <p>And then, sir lost his connection :D</p> <blockquote> <p><strong><em>Aside.</em></strong> Write primality test function using primitive recursion. \(\begin{align} prime(0) &amp;= 0 \\ prime(S(x)) &amp;= g(x, S(x)) \\ \\ g(0, y) &amp;= 0 \\ g(S(x), y) &amp;= ite(isZero(y), 1,\\ &amp;ite(isZero(monus(S(x), gcd(S(x), y))), 0, g(x, y))) \\ \\ gcd(0, y) &amp;= y \\ gcd(S(x), y) &amp;= ite(gte(S(x), y), \\ &amp;gcd(monus(S(x), y), y), gcd(y, x)) \end{align}\)</p> </blockquote> <h1 id="lecture-30">Lecture 30</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">24-03-22</code></p> </blockquote> <p>We were discussing the definition of \(quotient\) in the previous lecture. In terms of minimisation, we can write the definition as</p> \[\begin{align} quotient(x, y) &amp;= \mu(f)(x, y) \\ f(k, x, y) &amp;= y*k &gt; x \end{align}\] <h2 id="encoding-turing-machines">Encoding Turing machines</h2> <p>Let us consider the example of enumerating all the finite subsets of \(N\). A subset \((n_1, n_2, \dots, n_k)\) is represented as \(m = p_1^{n_1} \times \dots \times p_k^{n_k}\) where \(p_1, \dots, p_k\) are the first \(k\) prime numbers. Note that we need to ignore trailing zeros for this.</p> <p>Can we enumerate Turing Machines? Let us try to encode a Turing Machine as a bit string. The core idea is that a Turing Machine has a finite set of states. We can encode a transition in the following way - Suppose we have the transition \(\delta(q_3, X_1) = (q_7, X_2, D_0)\). Then, the bit string corresponding to this is \(11\; 000 \;1 \; 0000000 \; 1\; 0 \; 1 \; 00 \; 1 \; 0 \; 11\) Here, a \(1\) just acts as a separator, and every state, tape symbol and direction are encoded in unary format. A substring \(11\) represents the start of a transition, followed by \(q_3, q_7, X_1, X_2, D_0\) for the above example. This way, we can list all the transitions of the Turing Machine. All the transitions can be enclosed between a pair of substrings \((111, 111)\). Now, we just need to add the set of final states.</p> <p>Instead of listing out all the final states, we can convert the Turing Machine to an equivalent TM which has a single finite state.</p> <blockquote> <p><strong><em>Homework.</em></strong> Prove that the above conversion can be done for any Turing Machine.</p> </blockquote> <p>Now that we have encoded a TM, how do we enumerate the set of all TMs? We know how to enumerate bit strings based on the value and the length (ignore leading \(0\)‘s for non-ambiguity). We need out to weed out the bit strings that do not represent a valid TM.</p> <p>What features are present in a bit string that represents a TM? It needs to start with \(111\), and end with \(111\). If there is a \(11\) in between the above substrings, there need to be at least 4 \(1\)‘s in between with appropriate number of \(0\)’s in between. This concludes our discussion on encoding TMs.</p> <h2 id="variants-of-tm">Variants of TM</h2> <p>Let us consider the time of execution with a single computer and \(n\) computers. Any task will have at most \(n\) times speedup when done on \(n\)-computers in comparison to a single computer (generally). For example, matrix multiplication can be heavily parallelised. However, tasks such as gcd calculation of \(k\) numbers is <em>inherently sequential</em> and it is not easy to speed it up using parallel computation.</p> <p>Now, we shall consider variants of TMs and show equivalence of each with the 1-way infinite tape variant.</p> <h3 id="2-way-infinite-tape">2-way infinite tape</h3> <p>It is easy to see that a 2-way infinite tape can be restricted of the left movement beyond a point to simulate all the 1-way infinite tape machines.</p> <p>To prove the other direction, we will consider a multi-track 1-way TM. That is, every cell will now contain 2 elements. The basic idea is that a 2-way machine of the form \(\dots \mid B_1 \mid B_0 \mid A_0 \mid A_1 \mid \dots\) will be converted to \((A_0, C) \mid (A_1, B_0) \mid \dots\).</p> <p>The states in the 2-way machine will be separated based on whether the transition is on the left side of the tape or the right side. Then, based on the side, we will work on the first element in the tuple of each cell or the second element. The formal proof is left to the reader.</p> <h3 id="multi-tapes">Multi tapes</h3> <p>There are multiple tapes under a single control. Therefore, each transition is represented as \(( X_1, \dots, X_k )\mid ( Y_1, \dots, Y_k) , (D_1, \dots, D_k)\). One can see that all the logic boils down to the Satan-Cantor puzzle.</p> <p>Again, one direction of the equivalence is straightforward. The other half involves converting a \(k\)-tuple to a natural number.</p> <h3 id="non-determinism-2">Non-Determinism</h3> <p>The equivalence can be shown in a similar way as that of regular languages.</p> <h3 id="k-head-machine">k-head machine</h3> <p>We have a single tape which has multiple heads that move independently.</p> <h3 id="offline-tm">Offline TM</h3> <p>The input tape never changes. That is, the actions are read-only.</p> <h1 id="lecture-31">Lecture 31</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">28-03-22</code></p> </blockquote> <h2 id="universal-turing-machine">Universal Turing Machine</h2> <p>The intention is to build a general purpose computer. Recollect that a Turing Machine is represented as \(M = (Q, \Sigma, T, \delta, q, B, F)\).</p> <p>Every Turing Machine has an equivalent TM</p> <ul> <li>whose alphabet is \(\{0, 1\}\) and the set of tape symbols is \(\{0, 1, B\}\), and</li> <li>has a single final state.</li> </ul> <p>\(L\) is</p> <ul> <li> <strong>recursively enumerable</strong> - there exists a TM (recogniser) that accepts \(L\) (need not halt on wrong input, think of recogniser built from enumerators).</li> <li> <strong>recursive</strong> - there is a TM that accepts \(L\) <u>which halts on all inputs</u>.</li> </ul> <p>For example, consider the language that accepts a pair of CFGs \((G_1, G_2)\) if \(L(G_1) \cap L(G_2) \neq \phi\). To show that this language is recursively enumerable, we will give a <em>high level</em> algorithm in terms of primitive steps that we know can be converted to a TM. We consider the following algorithm.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- Enumerate L(G_1) // enumerate w, check G_1 =&gt;* w (CYK)
- For each w in L(G_1) check if G_2 =&gt;* w
</code></pre></div></div> <p>Now, if we generate a word and check for the word in the other grammar alternately, then the algorithm will halt if the input is acceptable. However, it is not guaranteed to halt in case of unacceptable input for this algorithm. Does that mean the language is recursively enumerable?</p> <p>We need to show that we can’t construct an algorithm that halts in case of an unacceptable input. Then, we can conclusively state that the language is recursively enumerable.</p> <p>In conclusion, there are language that are recursively enumerable, and languages that are not recursively enumerable. The set of recursive languages are a strict subset of the set of recursively enumerable languages.</p> <h3 id="non-recursive-language">Non-recursive language</h3> <p>We know that we can enumerate all TMs and all \(w \in \Sigma^*\). Then, we draw a 2D infinite bit matrix A where \(A_{ij}\) tells whether \(w_i \in M_j\). Now, we use the Cantor’s diagonalization argument to conclude that \(L_d = \{i \mid A_{ii} = 0\}\) is not recursively enumerable. <strong>Genius proof</strong> based off Barber’s paradox.</p> <p>If \(L\) is not recursively enumerable, then \(\bar L\) is also not recursively enumerable. That is, show that if TM accepts \(L\), then it must also accept \(\bar L\).</p> <p>One might ponder on how we construct the table \(A\) when some TM may not halt for a few inputs. The important distinction is that, we are “defining” this table conceptually and not “computing” it. The concept of dovetailing also comes to use here.</p> <h3 id="recursively-enumerable-but-not-recursive">Recursively enumerable but not Recursive</h3> <p>The language of the <strong>Universal Turing Machine</strong> is the required example. We formally define this language as \(L_u = \{( M, w) \mid\ M \text{ halts on } w\}\).</p> <p>Equivalently, we are trying to write a Python script that takes another Python script as input along with some arguments. This script should halt when the input python script halts on the input argument, and need not halt otherwise. Basically, we are trying to build a simulator TM.</p> <blockquote> <p>No lectures 32 and 33.</p> </blockquote> <h1 id="lecture-34">Lecture 34</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">04-04-22</code></p> </blockquote> <h2 id="undecidability">Undecidability</h2> <p>A language \(L \subseteq \Sigma^*\) is <strong>recursive</strong> if there is a Turing Machine \(M\) that halts in an accept state if \(w \in L\) and in a reject state if \(w \not\in L\). It <em><u>need</u></em> not halt in reject states for <strong>recursively enumerable</strong> languages. The algorithms similar to the latter TMs are <strong>semi-decidable</strong>.</p> <p>We were looking for languages that are not recursively enumerable \(L_d\) and languages that are recursively enumerable but not recursive \(L_u\). For the latter set, we had seen the universal TM. We also have the language of “polynomials that have integer roots”. How do we show that this is recursively enumerable? The key idea lies in encoding polynomials as a number. The motivation for this language comes from <strong>Hilbert’s 10th Problem</strong>.</p> <p>Another example for an undecidable problem is the <strong>Halting Problem</strong>.</p> <p>Let us continue the discussion on \(L_u\) and \(L_d\) from the last lecture. We had constructed a matrix \(A\) and showed using the diagonalization argument that there are languages that are not recursively enumerable. However, we did not address two issues</p> <ul> <li>There are multiple TMs that accept the same language - It does not matter.</li> <li>How do we fill the table? - Computation vs Definition.</li> </ul> <p>Also, all the languages defined by each row \(A_i\) in the matrix form the set of recursively enumerable languages.</p> <p>We had defined \(L_u\) as \(\{(M_i, w_j) \mid M_i \text{ accepts } w_j \}\). We will show that this language is recursively enumerable by constructing a Turing Machine \(M\) that accepts this language. The input tape will initially have the encoding of \(M_i\) followed by the encoding of \(w_j\). Now, we use two more tapes</p> <ul> <li>One for copying \(w_j\)</li> <li>Another tape for keeping track of the state in \(M\), starting with state 0.</li> </ul> <p>Now, we give the higher level logic of \(M\).</p> <ul> <li>Validate \(M_i\). This can be done using a TM.</li> <li>Run \(M_i\) step-by-step. Pick the top state from the 3rd tape, find the corresponding move from the first tape, and update the 2nd and 3rd tapes.</li> </ul> <p>The last two tapes help simulate any input TM. In conclusion, we have constructed a universal TM. Therefore, the TM paradigm is powerful enough to perform <strong>self-introspection</strong>.</p> <p>Note that we have still not shown \(L_u\) is not recursive. We will use the properly of \(L_d\) not being recursively enumerable to show this.</p> <h1 id="lecture-35">Lecture 35</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">05-04-22</code></p> </blockquote> <p>Let us continue the discussion on the Universal Turing Machine. The encoding of a move \(\delta(q_i, X_j) = (q_k, Xl, D_m)\) in a Turing Machine is \(0^i10^j10^k10^l10^m\). The universal TM works in 3 steps</p> <ul> <li>Decode/Validate</li> <li>Set up the tapes</li> <li>Simulate</li> </ul> <p>Also, we had shown that \(L_u\) is recursively enumerable by the construction of the universal TM. Suppose, there is a TM that halts every time for \(L_u\). Now, we will show that \(L_u\) is recursive then \(L_d\) is recursive. To do that, we will convert \(L_d\) into an instance of \(L_u\).</p> <p><img src="/assets/img/Automata/image-20220413194329791.png" alt="image-20220413194329791"></p> <p>Here, we can see that we are able to answer the question \(w_i \in L_d\) by constructing a TM using the Universal TM. That is, if the Universal TM is recursive, then \(L_d\) is also recursive. <em>Think</em>.</p> <h2 id="reduction-technique">Reduction Technique</h2> <p>To understand this technique, consider the following two problems</p> <ul> <li>\(L_{ne} = \{( M ) \mid L(M) \neq \phi\}\) - Machine accepts at least one string</li> <li>\(L_{rec} = \{( M ) \mid L(M) \text { is recursive}\}\) - Machine halts on all inputs</li> </ul> <p>We can show that both are recursively enumerable. The first language can be shown as recursively enumerable using dovetailing (words and moves being the dimensions). To show non-recursivity, we convert \(L_d\) or \(L_u\) to an instance of this language. We need to try and come up with an algorithm that halts for machines with empty languages.</p> <blockquote> <p>How do we do this?</p> </blockquote> <p>The second problem is a little bit more difficult.</p> <p>In conclusion, given a language</p> <ul> <li>To prove that it is recursive, we need to construct a TM that halts on all inputs.</li> <li>To prove that it is recursively enumerable, we just need to construct a TM that halts on good inputs. To show that it is not recursive, we need to use reductions probably.</li> <li>To prove non recursively enumerable, we need to show that we can’t construct any TM.</li> </ul> <p>TM is a powerful model as it is universal (self-referential), and it has many undecidable problems. They can represent Type-0 Grammar, Partial Recursive functions, and RAM (random access mechanism).</p> <h2 id="post-correspondence-problem">Post Correspondence Problem</h2> <p>Post is a mathematician. Consider the following table</p> <table> <thead> <tr> <th>w</th> <th>x</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>111</td> </tr> <tr> <td>1011</td> <td>10</td> </tr> <tr> <td>10</td> <td>0</td> </tr> </tbody> </table> <p>Now, take the string \(101111110\). Can we decompose this string in terms of \(w_i\) or \(x_i\)? For example, we can decompose the string as \(2113\) in terms of \(w's\) and \(2113\) again in terms of \(x’s\). These decompositions need not be unique.</p> <p>So, PCP is stated as follows.</p> <p>Given \(w = \{w_i \mid w_i \in \Sigma^* \}, x = \{x_i \mid x_i \in \Sigma^*\}\) and a string \(s \in \Sigma^*\), we need to be able to come up with decompositions \(s = w_{i1} \dots w_{il}\) and \(s = x_{j1}\dots x_{jl}\) such that \(ik = jk\) for \(k \in \{1, \dots, l\}\).</p> <p>Consider the following table.</p> <table> <thead> <tr> <th>w</th> <th>x</th> </tr> </thead> <tbody> <tr> <td>10</td> <td>101</td> </tr> <tr> <td>011</td> <td>11</td> </tr> <tr> <td>101</td> <td>011</td> </tr> </tbody> </table> <p>Now, for any string \(s\), we will not be able to come up with decompositions that are equal for the above sets.</p> <p>The reason we came up with this problem, is to show that PCP is undecidable (not recursive). That is, no TM can halt correctly on all PCP instances. However, it is recursively enumerable as we can enumerate all sequences fairly. This can be shown by a reduction of \(L_u\) to PCP.</p> <p>Let us now consider another problem - Ambiguity of CFGs. Can we build a TM that halts with a ‘yes’ if the input CFG has an ambiguity and with a ‘no’ is it does not. In an ambiguous grammar, a single word has multiple derivations in the grammar. That is, we have multiple structurally different derivation trees. Using this problem we are trying to show the importance of <strong>direction of reduction</strong>. We know that PCP is undecidable. Therefore, we need to reduce PCP to an instance of the CFG problem. That is, we’ll essentially show that is the CFG problem is decidable, then so is PCP.</p> <p>PCP is essentially a pair of sets of strings. What is the grammar corresponding to these sets such that when PCP has a solution, the grammar is ambiguous and unambiguous otherwise? We introduce \(k\) new symbols \(a_1, \dots, a_k\). We construct the following grammar</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S -&gt; Sa | Sb
Sa -&gt; w_i Sa a_i | w_i a_i
Sb -&gt; x_i Sb a_i | x_i a_i
</code></pre></div></div> <p>It is easy to see that this grammar meets our requirements. To prove this, we need to show the proof in two directions</p> <ul> <li>If PCP has a solution, then G is ambiguous</li> <li>If G is ambiguous, then PCP has a solution. Here, we need to show that ambiguity happens only due to <code class="language-plaintext highlighter-rouge">Sa</code> and <code class="language-plaintext highlighter-rouge">Sb</code>.</li> </ul> <blockquote> <p>Why did we introduce <code class="language-plaintext highlighter-rouge">a</code>?</p> </blockquote> <p><strong>Note.</strong> To show problem A is undecidable knowing that problem B is undecidable, we essentially show that A is a subroutine of B.</p> <h2 id="properties-of-recursive-languages">Properties of Recursive Languages</h2> <p>If \(L_1\) and \(L_2\) are both recursive, then so are</p> <ul> <li> \[L_1 \cup L_2\] </li> <li> \[L_1 \cap L_2\] </li> <li> \[L_1 - L_2\] </li> <li> \[L_1^c\] </li> <li> \[L_1L_2\] </li> </ul> <p>The intersection and complement closure break in case of recursively enumerable languages <strong>(?)</strong></p> <h1 id="lecture-36">Lecture 36</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">07-04-22</code></p> </blockquote> <p><strong>Note.</strong> Don’t get confused into thinking there are three (disjoint) kinds of sets: decidable, semi-decidable, and undecidable. There are two kinds: decidable and undecidable. Semi-decidable falls under undecidable.</p> <h2 id="np-completeness">NP-Completeness</h2> <h3 id="decision-problems">Decision Problems</h3> <p>These are a class of problems that deal with problem instances like Fermat’s last theorem - \(\forall n &gt; 2\exists a, b, c, a^n + b^n = c^n\)? We also have the law of excluded middle in decision problems - The answer is either ‘yes’ or ‘no’.</p> <p>Optimisation problems can be converted to a decision problem.</p> <h3 id="decidable-problems">Decidable Problems</h3> <p>We solve these problems by building a brute-force TM - <strong>generate and test method</strong>. For example, consider the problem of finding a vertex cover in a graph of size \(k\). Now, the TM will enumerate all subsets of size \(k\) and check each one for vertex cover conditions.</p> <p>We come up with “algorithms” for these problems and check their efficiency. Apart from time and space complexity, we also consider <strong>descriptive (Kolmogorov) complexity</strong>. It refers to the program size. In our case, it refers to the size of the TM.</p> <h3 id="complexity-classes">Complexity Classes</h3> <p>Given two problems, which problem is “more difficult”? The difficulty criterion we consider is time. We define two classes of problems \(P\) and \(NP\).</p> <ul> <li> <strong>P</strong> is the class of (decision) problems that can be solved in “polynomial time” by a deterministic Turing Machine \(M\).</li> <li> <strong>PSPACE</strong> refers to the class of problems that use polynomial number of cells in the tape.</li> <li> <strong>NP</strong> is the class of (decision) problems that can be solved in <strong>polynomial time</strong> by <u>non-deterministic TM</u>. This is equivalent to guessing a solution in polynomial time followed by checking using a deterministic TM in polynomial time. The claim is that this is same as a non-deterministic TM. We shall use this technique to show that problems are in NP. That is, we’ll show that we can guess in P-time and verify in P-time.</li> </ul> <p>For example, let us try to show vertex cover problem is in \(NP\). Aside - A polynomial algorithm was developed in the 1980s for the problem “Is \(n\) a prime number” in IITK (Manindra Agarwal).</p> <h3 id="more-difficult-problem">More difficult problem</h3> <p>Given \(L_1\) and \(L_2\), which one is more difficult? We use reduction to answer this question.</p> \[L_1 \leq_{P} L_2\] <p>If \(L_1\) can be converted to an instance of \(L_2\) in polynomial time, then we have the above defined relation. That is, \(L_2\) is at least as difficult as \(L_1\).</p> <h3 id="completeness">Completeness</h3> <p>We try to determine the most difficult problem amongst all the problems. To start off, we define that \(L_{sat}\) belongs to NP-complete set. This problem refers to the satisfiability of propositional logic expressions.</p> <p>Every problem in \(NP\) can be reduced to \(L_{sat}\). In some sense, \(L_{sat}\) is the most difficult problem. But how did we come to this conclusion without knowing all the problems in \(NP\)? We can show that <u>any non-deterministic TM can be reduced to</u> \(L_{sat}\).</p> <h1 id="lecture-37">Lecture 37</h1> <blockquote> <p><code class="language-plaintext highlighter-rouge">11-04-22</code></p> </blockquote> <p>Let us continue the topic of NP-completeness.</p> <p>We define hard problems as anything not in \(P\). There are problems that are more difficult than the ones in \(NP\)!</p> <p>We classify decidable problems as the set of recursive languages. These problems can be further classified as</p> <ul> <li>Deterministic TM takes only polynomial number of steps in terms of the input size to halt.</li> <li> <p>A non-deterministic TM takes polynomial number of steps.</p> </li> <li>A non-deterministic TM needs \(\Omega (2^n)\) number of steps.</li> </ul> <h3 id="sat-problem-p_sat">SAT Problem \(P_{sat}\)</h3> <p>Given a well formed formula \(F\), is \(F\) satisfiable? A well formed formula is a formula that is formed via the base case (propositional variables) and inductive rules (using connectors like negation, ‘and’ and ‘or’).</p> <p>This problem can be solved via brute force but that is exponential. So we now ask the following questions</p> <ul> <li>Is \(P_{sat} \in P\)?</li> <li>Is \(P_{sat} \in NP\)?</li> </ul> <p>We’ll answer the second question first. It is easy to construct a non-deterministic TM that solves the problem in polynomial steps. We can generate a random guess (bit string) and verify (check satisfiability) in polynomial steps. This procedure is the way to show that any problem is in \(NP\).</p> <h3 id="comparison-of-problems">Comparison of Problems</h3> <p>Let us revisit the topic of \(\leq_{P}\). \(P_{sat} \leq_{P} 3\text{-}SAT\), and \(3\text{-}SAT \leq_P VC\) where \(VC\) is the vertex cover problem.</p> <p>To do perform the latter reduction, we construct nodes for \(p\) and \(\neg p\) for each propositional variable in the clause. Then, we construct cliques out of each disjunction in the CNF. Finally, we connect each \(p\) with \(\neg p\). Now, if we can find a vertex cover of this graph with size \(2k\), we get the satisfiability of the 3-CNF clause with \(k\) disjunctive clauses.</p> <ul> <li>If \(F\) has a satisfying assignment, take out exactly one literal with value \(1\) out of each disjunctive clause and construct a VC out of the remaining literals. It can be shown that the vertex cover will have size \(2k\).</li> <li>If there is a vertex cover, then we can drop at most 1 node from each disjunctive clause. Also, as the size if \(2k\) we can drop exactly 1 node from each clause. Assign these dropped nodes with a value of \(1\). Now, since we have a true value in each clause, the assignment satisfies the expression.</li> </ul> <h3 id="np-completeness-1">NP-Completeness</h3> <p>As we mentioned before, we consider \(P_{sat}\) or \(3\text{-}SAT\) as the hardest problem. That is, for every \(Q \in NP\), \(Np \leq_P P_{sat}\).</p> <p>We show this by reducing non-deterministic Turing Machines to \(P_{sat}\). To prove that a problem is NP-complete, we show</p> <ul> <li>That the problem lies in \(NP\). This step is very important as there are problems that are more difficult than \(NP\).</li> <li>Convert the 3-SAT problem (or any other known NP-complete problem) to an instance of the given problem.</li> </ul> <p>We list out some problems in NP-complete set.</p> <ul> <li>3-SAT</li> <li>Vertex Cover</li> <li>Clique in a graph</li> <li>\(k\)-coloring</li> <li>Min-cut and Max-flow</li> <li>Travelling Salesman Problem</li> <li>Hamiltonian Cycle in a graph</li> <li>Partitioning of a set of numbers such that the partitions have the same sum</li> <li>Knapsack problem</li> </ul> <p>The good news about \(NP\)-complete problems is that there are many heuristics and approximations such as LAs Vegas and Monte Carlo that work well for most of the above problems.</p> <hr> <h4 id="end-of-course">END OF COURSE</h4> <hr> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/dbms/">DiBS Notes</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/ipl/">IPL Notes</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/NumAn/">Numerical Analysis Notes</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/operating-systems/">Operating System Notes</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/philosophy/">Philosophy Notes</a> </li> </div> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Sudhansh Peddabomma. Last updated: March 08, 2024. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?9b43d6e67ddc7c0855b1478ee4c48c2d" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-0K9MLG0V24"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-0K9MLG0V24");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>