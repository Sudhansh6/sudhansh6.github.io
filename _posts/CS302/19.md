# Lecture 19

> `25-03-22`

## Runtime support

The data objects come into existence during the execution of the program.  The generated code must refer to the data objects using their addresses, which must be decided during compilation. 

Runtime support also helps in dynamic memory allocation, garbage collection, exception handling, and virtual function resolution.

Virtual function resolution falls under the category of runtime support as pointer declarations are static but the objects pointed are dynamic. 

A programmer specifies the type of a data item, and also its role and allocation. Unnamed data resides on heap. We have the following properties of data

![image-20220405185340593](/assets/img/IPL/image-20220405185340593.png)

> Local and global static variables?

A sequential language may allow procedures to be

- Invoked as subroutines - Stack and static memory suffices for organising data for procedure invocations.
- Invoked recursively - Stack memory is required for organising data for procedure invocations.
- Invoked indirectly through a function pointer or passed as a parameter. Access to non-local data of the procedure needs to be provided.

## Compiling Procedure Calls

### Activation Records

Every invocation of a procedure requires creating an **activation record**. An activation record provides space for

- Local variables
- Parameters
- Saved registers
- Return value
- Return address
- Pointers to activation records of the calling procedures

We maintain two parameters known as **frame pointer** and **stack pointer**. Activation record of the callee is partially generated by the caller. We store the return parameter in one of the registers itself. Function prologue and function epilogue are generated by the compiler. We reduce the value of stack pointer when we push something on the stack. The stack pointer `$sp` points to the lower address of the next free location. Unlike the stack pointer, the frame pointer `$fp` holds the address of an occupied word. 

**Reminder.** We are talking about runtime activity. 

As discussed earlier, the compiler generates a function prologue and epilogue. It also generates a code before the call and after the call. This is all the boring assembly code we typically see for calling functions. We shall this code changes when the parameter passing mechanism changes. We will also see implicit sharing through scoping. 

