<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Perception for Home Robot | Sudhansh Peddabomma</title> <meta name="author" content="Sudhansh Peddabomma"> <meta name="description" content="Experimenting with various NeRF and Gaussian Splatting based SLAM algorithms to build a real-time 3D reconstruction of the environment. The methods used include NeRF-SLAM, Nice SLAM, Mip-NeRF and Splatam."> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%91%BE&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://sudhansh6.github.io/projects/Home_Robot/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?6185d15ea1982787ad7f435576553d64"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Sudhansh Peddabomma</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">Articles</a> </li> <li class="nav-item active"> <a class="nav-link" href="/projects/">Projects<span class="sr-only">(current)</span></a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"></a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/challenges/">Challenges</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/misc/">Miscellaneous</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Perception for Home Robot</h1> <p class="post-description">Experimenting with various NeRF and Gaussian Splatting based SLAM algorithms to build a real-time 3D reconstruction of the environment. The methods used include NeRF-SLAM, Nice SLAM, Mip-NeRF and Splatam.</p> </header> <article> <p>Check out this <a href="https://github.com/DoongLi/awesome-Implicit-NeRF-SLAM" rel="external nofollow noopener" target="_blank">repository</a> for all the latest papers relating to NeRF-SLAM.</p> <h1 id="nerf-slam"><a href="https://github.com/ToniRV/NeRF-SLAM" rel="external nofollow noopener" target="_blank">NeRF-SLAM</a></h1> <p>The paper proposes a novel geometric and photometric 3D mapping pipeline for real-time scene reconstruction from monocular images.</p> <p>While many 3D reconstruction solutions are based on RGB-D or Lidar sensors, scene reconstruction from monocular imagery provides a more convenient solution. RGB-D don’t work well in different lighting conditions, LIDARs are expensive, and stereo cameras have calibration problems. However, even with the improvements due to deep- learning, building both geometrically and photometrically accurate 3D maps of the scene from a casually taken monocular video in real-time is not currently possible.</p> <blockquote> <p>The geometric deals with the relation between 3D objects and their views under parallel, perspective, and central projection. The photometric deals with the relation between 3D matte objects and their images under changing illumination conditions.</p> </blockquote> <p>Neural Radiance Fields are a photometrically accurate 3D representations of the world. However, they require costly volumetric rendering, and they also originally required ground-truth pose estimates to converge. The fundamental problem of NeRF representations, given no depth supervision, is that the parameterization of the surfaces by a density is prone to ‘floaters’, ghost geometry that appears because of bad initializations or convergence to bad local minima. Depth supervision significantly improves the performance of the pipeline.</p> <p>The idea is that, a dense monocular SLAM pipeline can be used for close-to-perfect pose estimates, together with dense depth maps to build NeRFs on the fly.</p> <h3 id="dense-slam">Dense SLAM</h3> <p>SLAM refers to estimation of pose and depth. The main challenges for depth SLAM are</p> <ul> <li>computational complexity - dealt by decoupling pose and depth estimation.</li> <li>dealing with ambiguous information - Avoided with RGB-D or LIDARs.</li> </ul> <p>Traditional dense SLAM techniques that achieved real-time computation include <a href="https://www.doc.ic.ac.uk/~ajd/Publications/newcombe_etal_iccv2011.pdf" rel="external nofollow noopener" target="_blank">DTAM</a> and <a href="https://www.roboticsproceedings.org/rss11/p01.pdf" rel="external nofollow noopener" target="_blank">ElasticFusion</a>, but they are unable to make plausible geometry estimation for unobserved regions.</p> <h3 id="neural-radiance-fields-nerfs">Neural Radiance Fields (NeRFs)</h3> <p>NeRFs allow capturing view-dependent effects while maintaining multi-view consistency. NeRF synthesizes novel views (a rendering algorithm) of complex scenes by optimizing an underlying continuous volumetric scene function using a sparse set of input views. <a href="https://dl.acm.org/doi/pdf/10.1145/3503250" rel="external nofollow noopener" target="_blank">The vanilla NeRF approach</a> represents a scene using a fully connected (non-convolutional) deep network, whose input is a single continuous 5D coordinate (spatial location (x, y, z) and viewing direction (θ, φ)) and whose output is the volume density and view-dependent emitted radiance at that spatial location. The model learns a continuous volumetric function that can output the color and volume density to any voxel in space. To learn more about NeRF in detail, visit <a href="https://dtransposed.github.io/blog/2022/08/06/NeRF/" rel="external nofollow noopener" target="_blank">this</a> article. Here is a general overview of the NeRF pipeline -</p> <ol> <li>We have a set of “poses” in the form of (θ, φ) (3rd parameter not needed for pose since the camera always points at the object). We get the vector representation $v_0, v_d$ (origin, direction) for each pixel in every pose image. So, we get $H<em>W</em>n$ such rays for an image plane of size $H*W$ and $n$ poses.</li> <li>Next, we need to sample the points on these rays that are relevant to the object. That is, we need to sample points that are not in the empty space, but on the object itself. Also, we need to ensure that the sampling is done proportional to the expected effect on the final rendering. We can parameterize the ray and sample the points with a high $t$, but it is not that simple. The authors use a “hierarchical volume” sampling for this.</li> <li>The voxels are then mapped to a high dimensional space for better performance on high-frequency details like textures and colors. Neural networks are known to approximate low-frequency functions rather than high-frequency. The authors correct for this by introducing an encoding function $\gamma(p)$ that takes a voxel $p$ and maps to high-dimensional spaces like $sin(\pi p), cos(2\pi p)$, etc. This is called <em>positional encoding</em>.</li> <li>The final step is neural inference and volume rendering. The query points (obtained above) are fed into the neural network to obtain $c (r, g, b), \sigma$, that can be used to obtain the volume density profile for each ray.</li> <li> <p>In the volume rendering step, we take this output and get the rendered images. The information along a ray is aggregated using the <strong>rendering equation</strong>. In computer graphics, the rendering equation is an integral equation in which the equilibrium radiance leaving a point is given as the sum of emitted plus reflected radiance under a geometric optics approximation. Here, since the rays are straight, the equation simplifies to a simple sum along the ray. The idea is that, the ray has a higher probability of stopping (from the viewer to the object) if the volume density is high at that point. The color at that point will have the most effect in the final rendered image. Therefore, we use the volume density as weights for the colors to obtain the final RGB value in the image.</p> <p>Why not just outer-shell rendering instead of volume?</p> <p>Where is reflectance being taken care of? Also, how are shadows being taken care of?</p> </li> <li>The loss is then calculated by calculating the MSE between the ground truth image and the rendered image.</li> </ol> <p>There has been a lot of development on this line of work, which provide faster training, faster computations and better looking results.</p> <p>For example, <a href="https://alexyu.net/plenoxels/" rel="external nofollow noopener" target="_blank">Plenoxels</a> (Plenoptic volume element) improved the speed by parameterizing the directional encoding using spherical harmonics without using an MLP at all! Basically, they showed that the exceptional performance of NeRFs is due to the differentiable volume rendering function rather than the implicit neural representation. <a href="https://deeprender.ai/blog/plenoxels-radiance-fields-without-neural-networks" rel="external nofollow noopener" target="_blank">This article</a> explains in detail the physics behind rendering and the motivation behind plenoxels.</p> <p>Finally, <a href="https://nvlabs.github.io/instant-ngp/" rel="external nofollow noopener" target="_blank">Instant-NGP</a> shows that with a hash-based hierarchical volumetric representation of a scene, it is possible to train a neural radiance field in real-time. The authors propose to learn a multi-resolution hashtable that maps the query coordinates to feature vectors. The encoded input feature vectors are passed through a small MLP to predict the color and density of a point in the scene, NeRF-style. Check <a href="https://www.casualganpapers.com/fastest_nerf_3d_neural_rendering/Instant-Neural-Graphics-Primitives-explained.html" rel="external nofollow noopener" target="_blank">this article</a> to understand the key-ideas in the paper.</p> <h3 id="slam-with-nerfs">SLAM with NeRFs</h3> <p>An area of research in NeRFs focuses on removing the dependence on partially known camera poses. <a href="https://yenchenlin.me/inerf/" rel="external nofollow noopener" target="_blank">iNeRF</a> is an interesting framework that performs pose estimation by “inverting” a trained NeRF. Following this, <a href="https://arxiv.org/pdf/2103.12352.pdf" rel="external nofollow noopener" target="_blank">iMap</a> and <a href="https://arxiv.org/pdf/2112.12130.pdf" rel="external nofollow noopener" target="_blank">Nice-SLAM</a> (an extension of iMap) showed how to build accurate 3D reconstructions, without the need for poses! Now, this work builds on these two approaches (which use RGB-D) input, to work with monocular images. Some works also use a hierarchical volumetric map for real-time SLAM with monocular images. The paper aims to build an indirect loss for pose-estimation, which is known to be more robust than direct image alignment, and has the ability to <strong>depth supervise the radiance field</strong>.</p> <p>To summarize, dense monocular SLAM estimates dense depth maps and camera poses, while also providing uncertainty estimates for both. This is used for the training of NeRF. The paper uses real-time implementations of both these parts, and runs them in parallel to obtain better performance in real-time.</p> <h3 id="tracking-dense-slam">Tracking: Dense SLAM</h3> <p><a href="https://arxiv.org/pdf/2108.10869.pdf" rel="external nofollow noopener" target="_blank">Droid-SLAM</a> is used as the tracking module to provide dense depth maps and poses for every keyframe. This is done via computing dense <em>optical-flow</em> between pairs of frames using a <strong><em>convolutional Gated Recurrent Unit (GRU)</em></strong>.</p> <blockquote> <p>Check <a href="https://towardsdatascience.com/illustrated-guide-to-lstms-and-gru-s-a-step-by-step-explanation-44e9eb85bf21" rel="external nofollow noopener" target="_blank">this article</a> for a detailed explanation of what this term means.</p> </blockquote> <p>The module solves a dense bundle adjustment (BA) problem where the 3D geometry is parametrized as a set of inverse depth maps for keyframe. (Not really sure what this means).</p> <h3 id="mapping-probabilistic-volumetric-nerf">Mapping: Probabilistic Volumetric NeRF</h3> <p>Now that the dense depth-maps are available, these can be used to supervise the neural volume. The resulting point-cloud from dense monocular SLAM, is however noise and contains large outliers. based on the works in <a href="https://arxiv.org/pdf/2210.01276.pdf" rel="external nofollow noopener" target="_blank">Probabilistic Volumetric Fusion for Dense Monocular SLAM</a>, the uncertainties in depth estimates can be used to weigh the depth values for classical <em>TSDF volumetric fusion</em>.</p> <blockquote> <p>TSDF - Truncated Signed Distance Function</p> </blockquote> <p>Comments -</p> <ul> <li>This is for large-scenes? We need for small items on the table?</li> </ul> <h2 id="zip-nerf"><a href="https://arxiv.org/pdf/2304.06706.pdf" rel="external nofollow noopener" target="_blank">Zip-NeRF</a></h2> <p>The idea is to use grid-based representations to accelerate the training of NeRFs. However, these approaches are limited by aliasing. Anti-aliasing has been previously corrected for in <a href="https://jonbarron.info/mipnerf360/" rel="external nofollow noopener" target="_blank">mip-NeRF 360</a>, which reasons about sub-volumes along a cone rather than points along a ray. Zip-NeRF combines the techniques from Instant NGP and mip-NeRF 360.</p> <p>mip-NeRF 360 has been designed to work with unbounded scenes, where the background has a lot of information in terms of various objects. This is done in the following way -</p> <ul> <li>The unbounded space is represented in a bounded domain using a Kalman-filter like transform to warp the Gaussians (used by the conic slices).</li> <li> <p>Unbounded scenes can require heavy computation. The paper addresses this problem by distilling scene geometry using a large NeRF MLP to a small MLP while training.</p> </li> <li>A novel regularizer along mip-NeRF ray intervals to solve for sparse observations in large scenes (highly ill-posed problem)</li> </ul> <p>Current grid-based approaches do not use positional encoding, but instead use learned features that are obtained by interpolating into a hierarchy of grids at a single 3D coordinate.</p> <p>Mip-NeRF 360 and iNGP are similar in the sense that they sample points along the camera rays to train a continuous volume density and color function. However, they differ significantly in how the coordinates along the ray are parameterized.</p> <ul> <li>In mip-NeRF 360, a ray is subdivided into a set of intervals, each of which represents a conical frustum whose shape is approximated using a multivariate Gaussian, and the expected positional encoding is used as input to the MLP. This approach is scale-aware.</li> <li>iNGP trilinearly interpolates into a hierarchy of differently-sized 3D grids to produce feature vectors for small MLP</li> </ul> <h3 id="spatial-anti-aliasing">Spatial Anti-Aliasing</h3> <h3 id="z-aliasing-and-proposal-supervision">z-aliasing and Proposal Supervision</h3> <p>Comments -</p> <ul> <li>This is useful when the background is information rich.</li> <li>Don’t we need 360 views?</li> </ul> <h1 id="gaussian-splatting">Gaussian Splatting</h1> <p><strong><a href="https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/" rel="external nofollow noopener" target="_blank">3D Gaussian Splatting for Real-Time Radiance Field Rendering</a></strong></p> <p><strong><a href="https://arxiv.org/abs/2311.11700#:~:text=In%20this%20paper%2C%20we%20introduce,balance%20between%20efficiency%20and%20accuracy." rel="external nofollow noopener" target="_blank">GS-SLAM: Dense Visual SLAM with 3D Gaussian Splatting</a></strong></p> <p>No code yet!</p> <p>300 fps apparently!</p> <p><strong><a href="https://arxiv.org/abs/2311.16728" rel="external nofollow noopener" target="_blank">Photo-SLAM: Real-time Simultaneous Localization and Photorealistic Mapping for Monocular, Stereo, and RGB-D Cameras</a></strong></p> <p>No code yet!</p> <p>300 fps apparently!</p> <h3 id="useful-links">Useful links</h3> <ul> <li> <p>https://huggingface.co/blog/gaussian-splatting</p> </li> <li> <p>https://www.linkedin.com/pulse/recon-labs-internal-open-seminar-3-nerf-gaussian-splatting-ou2he/</p> </li> <li> <p>https://www.toolify.ai/ai-news/revolution-in-3d-imaging-photogrammetry-vs-nerf-vs-gaussian-splatting-79775</p> </li> <li> <p><a href="https://github.com/facebookresearch/Detic" rel="external nofollow noopener" target="_blank">Detic</a></p> </li> <li> <p><a href="https://github.com/facebookresearch/segment-anything" rel="external nofollow noopener" target="_blank">Segment-Anything (SAM)</a></p> </li> <li> <p><a href="https://github.com/IDEA-Research/Grounded-Segment-Anything" rel="external nofollow noopener" target="_blank">Grounded Segment-Anything</a></p> </li> </ul> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Sudhansh Peddabomma. Last updated: June 07, 2024. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?9b43d6e67ddc7c0855b1478ee4c48c2d" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-0K9MLG0V24"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-0K9MLG0V24");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>