<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Programming Cheatsheet | Sudhansh</title> <meta name="author" content="Sudhansh Peddabomma"> <meta name="description" content="A quick overview of all the important concepts in DSA."> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%91%BE&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://sudhansh6.github.io/blog/programming/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?6185d15ea1982787ad7f435576553d64"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Sudhansh</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">Articles</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"></a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/challenges/">Challenges</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/misc/">Miscellaneous</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">Programming Cheatsheet</h1> <p class="post-meta">July 22, 2021</p> <p class="post-tags"> <a href="/blog/2021"> <i class="fa-solid fa-calendar fa-sm"></i> 2021 </a>   ·   <a href="/blog/category/notes"> <i class="fa-solid fa-tag fa-sm"></i> Notes</a>   <a href="/blog/category/articles"> <i class="fa-solid fa-tag fa-sm"></i> Articles</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <h1 id="data-structures">Data Structures</h1> <h2 id="arrays">Arrays</h2> <h3 id="vector-syntax">Vector syntax</h3> <ul> <li> <code class="language-plaintext highlighter-rouge">vector&lt;type&gt;</code> stores elements of the type <code class="language-plaintext highlighter-rouge">type</code>. They are indexed by <code class="language-plaintext highlighter-rouge">ints</code>.</li> <li>Initialise a vector with <code class="language-plaintext highlighter-rouge">n</code> elements with all equal to <code class="language-plaintext highlighter-rouge">m</code> using <code class="language-plaintext highlighter-rouge">vector&lt;type&gt; vec(n, m)</code>.</li> <li>Copy a part of another vector in a new vector using <code class="language-plaintext highlighter-rouge">vector&lt;type&gt; cpy(m.begin(), m.end())</code>.</li> <li> <code class="language-plaintext highlighter-rouge">vector&lt;type&gt;::iterator</code> for an iterator through a vector. The special thing about iterators is that they provide the glue between <a href="https://stackoverflow.com/a/11948413/819272" rel="external nofollow noopener" target="_blank">algorithms and containers</a>. You can use <code class="language-plaintext highlighter-rouge">int</code> for indexing contiguous data structures such as <code class="language-plaintext highlighter-rouge">vector</code> </li> <li> <strong>Sort</strong> a vector using <code class="language-plaintext highlighter-rouge">sort(v.begin(), v.end(), [](auto a, auto b){return a &lt; b;})</code>.</li> <li> <strong>Rotate</strong> a vector by <code class="language-plaintext highlighter-rouge">k</code> indices to the <em>right</em> using <code class="language-plaintext highlighter-rouge">::rotate(nums.begin(), nums.end() - k%size, nums.end());</code>.</li> <li> <strong>Reverse</strong> a vector using <code class="language-plaintext highlighter-rouge">reverse(v.begin(), v.end())</code>.</li> <li> <strong>Length</strong> of a vector is given by <code class="language-plaintext highlighter-rouge">v.size()</code> and not <code class="language-plaintext highlighter-rouge">v.length()</code>.</li> <li>Finding max sub array and max sub sequence</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">maxSubarray</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">,</span> <span class="n">sarr</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">,</span> <span class="n">sseq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">prev</span><span class="p">)</span> <span class="o">+</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">sarr</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">sarr</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">sseq</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">sseq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">sseq</span> <span class="o">=</span> <span class="n">M</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="n">sarr</span><span class="p">,</span> <span class="n">sseq</span><span class="p">};</span>
<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>Visit <a href="https://www.geeksforgeeks.org/accumulate-and-partial_sum-in-c-stl-numeric-header/" rel="external nofollow noopener" target="_blank">here</a> for finding sum and partial sums of vector.</li> </ul> <h2 id="strings">Strings</h2> <p>First, all the syntax from <code class="language-plaintext highlighter-rouge">&lt;string&gt;</code> library.</p> <ul> <li> <strong>Length</strong> of a string is given by <code class="language-plaintext highlighter-rouge">str.length()</code>.</li> <li> <strong>Reverse</strong> a string using <code class="language-plaintext highlighter-rouge">reverse(str)</code> . If you want to store the reversed string elsewhere, use <em>reverse iterators</em> and do the following <code class="language-plaintext highlighter-rouge">string res = string(str.rbegin(), str.rend())</code>. Yes! strings have iterators.</li> <li> <strong>Transform</strong> a string using <code class="language-plaintext highlighter-rouge">transform(in.begin(), in.end(), out.begin(), ::tolower)</code>. <code class="language-plaintext highlighter-rouge">in</code> can be <code class="language-plaintext highlighter-rouge">out</code>.</li> <li> <strong>Filter</strong> alphabets from a string/<strong>iterable</strong> using <code class="language-plaintext highlighter-rouge">remove_if(vec2.begin(), vec2.end(), [](auto c){return !::isalpha(c);})</code>. <strong>The above does not work perfectly</strong>. Use <code class="language-plaintext highlighter-rouge">s.erase(::remove_if(s.begin(), s.end(), [](auto c){return !::isalpha(c);}), s.end());</code>.</li> <li> <code class="language-plaintext highlighter-rouge">::tolower</code> affects only alphabets in a string.</li> <li> <strong>Compare</strong> characters with <strong>single quotes</strong>.</li> <li>Refer to this <a href="https://www.javatpoint.com/cpp-strings" rel="external nofollow noopener" target="_blank">link</a> for all string functions in C++. <a href="https://fresh2refresh.com/c-programming/c-strings/c-strstr-function/" rel="external nofollow noopener" target="_blank">Here</a> is another list of useful string functions.</li> <li>String to number using <code class="language-plaintext highlighter-rouge">atoi()</code> and <code class="language-plaintext highlighter-rouge">stoi()</code>. Number to string conversion using <code class="language-plaintext highlighter-rouge">to_string()</code>.</li> <li>Use <code class="language-plaintext highlighter-rouge">push_back</code> <strong>or</strong> <code class="language-plaintext highlighter-rouge">+</code> to add new chars at the end. Use <code class="language-plaintext highlighter-rouge">a + b</code> to <strong>concatenate</strong> strings.</li> <li>Use <code class="language-plaintext highlighter-rouge">size_t</code> for storing lengths of strings.</li> </ul> <h3 id="theory">Theory</h3> <ul> <li>Storing strings in <code class="language-plaintext highlighter-rouge">char</code> arrays. Allocate space equal to <strong>one more</strong> than the length of string of array. The last character is for the <strong>end</strong> character: <code class="language-plaintext highlighter-rouge">\0</code>. Strings in C must end with the null character. Suppose you try to print a string without the end character, the program will print characters until it encounters the null character. Functions like <code class="language-plaintext highlighter-rouge">strlen</code> and <code class="language-plaintext highlighter-rouge">printf("%s", char_array)</code> depend on the end character.</li> <li>You can also initialise a string using ‘double quotes’. For example, <code class="language-plaintext highlighter-rouge">char arr[100] = "Null character is implictly placed"</code>. You can also <em>avoid writing the size</em>. Although, when you initialise the string with comma separated characters, you must mention the size. Also, you must explicitly mention the end character.</li> <li>Arrays and pointers are different types used in a similar manner. Let <code class="language-plaintext highlighter-rouge">p1</code> be an array and <code class="language-plaintext highlighter-rouge">p2</code> be a pointer. <strong><code class="language-plaintext highlighter-rouge">p2 = p1</code></strong> is valid but <strong><code class="language-plaintext highlighter-rouge">p1 = p2; ++p1</code> are invalid</strong>.</li> <li>Arrays are always passed to a function <strong>by reference</strong>.</li> <li>Memory of an application is classified into :</li> </ul> <table> <thead> <tr> <th style="text-align: center">Heap</th> </tr> </thead> <tbody> <tr> <td style="text-align: center"><strong>Stack</strong></td> </tr> <tr> <td style="text-align: center"><strong>Static/Global</strong></td> </tr> <tr> <td style="text-align: center"> <strong>Code</strong> (Text)</td> </tr> </tbody> </table> <ul> <li> <div class="language-cpp highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">C</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span>  <span class="o">=</span> <span class="s">"Hello"</span><span class="p">;</span> <span class="c1">//String gets stored in the space of the array. Can be edited.</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">C2</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="p">;</span> <span class="c1">//String gets stored as a constant during compile time.</span>
<span class="c1">// C2[0] = 'A'; would be invalid</span>
</code></pre></div> </div> </li> <li>C++ provides <code class="language-plaintext highlighter-rouge">string</code> inbuilt datatype.</li> </ul> <h2 id="linked-lists">Linked Lists</h2> <ul> <li>You can’t delete a node by just using <code class="language-plaintext highlighter-rouge">delete node</code>. You should do <code class="language-plaintext highlighter-rouge">prev -&gt; next = node -&gt; next</code> and then <code class="language-plaintext highlighter-rouge">delete node</code>. You should do this even if <code class="language-plaintext highlighter-rouge">node -&gt; next = NULL</code>.</li> <li> <strong>Reverse</strong> a linked list in <code class="language-plaintext highlighter-rouge">O(n)</code> using a sliding window mechanism.</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">head</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="n">ListNode</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="n">prev</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
<span class="n">curr</span> <span class="o">=</span> <span class="n">head</span> <span class="o">-&gt;</span> <span class="n">next</span><span class="p">;</span>
<span class="n">head</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">curr</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">next</span> <span class="o">=</span> <span class="n">curr</span> <span class="o">-&gt;</span> <span class="n">next</span><span class="p">;</span>
    <span class="n">curr</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
    <span class="n">curr</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">curr</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
<span class="k">return</span> <span class="n">curr</span><span class="p">;</span>
</code></pre></div></div> <ul> <li>Check if a <strong>cycle</strong> exists in a linked list using the <strong>Hare and Tortoise</strong> algorithm.</li> <li>Check if a list is a <strong>palindrome</strong> in <code class="language-plaintext highlighter-rouge">O(n)</code> time and <code class="language-plaintext highlighter-rouge">O(1)</code> storage using the above two algorithms.</li> <li>In doubly linked lists, make sure you change both <code class="language-plaintext highlighter-rouge">prev</code> and <code class="language-plaintext highlighter-rouge">next</code> of the previous and following nodes.</li> </ul> <h2 id="queues-and-stacks">Queues and Stacks</h2> <table> <thead> <tr> <th>Operations</th> <th>Queues</th> <th>Stacks</th> </tr> </thead> <tbody> <tr> <td>Adding elements</td> <td><code class="language-plaintext highlighter-rouge">queue.push()</code></td> <td><code class="language-plaintext highlighter-rouge">stack.push_back()</code></td> </tr> <tr> <td>First element</td> <td><code class="language-plaintext highlighter-rouge">queue.front()</code></td> <td><code class="language-plaintext highlighter-rouge">stack.top()</code></td> </tr> </tbody> </table> <ul> <li>Stacks and queues can be implemented via arrays and linked lists.</li> </ul> <h2 id="trees">Trees</h2> <ul> <li>When you write recursive algorithms, make sure you write the base cases. Your base case can include <code class="language-plaintext highlighter-rouge">NULL</code> too! Don’t write <code class="language-plaintext highlighter-rouge">left == NULL</code>, <code class="language-plaintext highlighter-rouge">right == NULL</code> etc separately. Let me show what I mean. Consider the problem of validating a BST. Initially, the code I wrote in python was this.</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">checker</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">True</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">data</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span>
        <span class="n">c_left</span> <span class="o">=</span> <span class="nf">checker</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">c_left</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">root</span><span class="p">.</span><span class="n">data</span> <span class="ow">and</span> <span class="n">c_left</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nf">min</span><span class="p">(</span><span class="n">c_left</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">root</span><span class="p">.</span><span class="n">data</span><span class="p">),</span> <span class="nf">max</span><span class="p">(</span><span class="n">c_left</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">root</span><span class="p">.</span><span class="n">data</span><span class="p">)]</span> 
    <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span>
        <span class="n">c_right</span> <span class="o">=</span> <span class="nf">checker</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">c_right</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">root</span><span class="p">.</span><span class="n">data</span> <span class="ow">and</span> <span class="n">c_right</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nf">min</span><span class="p">(</span><span class="n">c_right</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">root</span><span class="p">.</span><span class="n">data</span><span class="p">),</span> <span class="nf">max</span><span class="p">(</span><span class="n">c_right</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">root</span><span class="p">.</span><span class="n">data</span><span class="p">)]</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span>
    <span class="n">c_left</span> <span class="o">=</span> <span class="nf">checker</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
    <span class="n">c_right</span> <span class="o">=</span> <span class="nf">checker</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">c_left</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c_right</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">root</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">c_left</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">c_right</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">root</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">c_left</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">root</span><span class="p">.</span><span class="n">data</span> <span class="ow">and</span> <span class="n">c_left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">c_right</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">root</span><span class="p">.</span><span class="n">data</span> <span class="ow">and</span> <span class="n">c_right</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">,</span> <span class="n">M</span><span class="p">]</span> 
            
<span class="k">def</span> <span class="nf">checkBST</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">return</span> <span class="nf">checker</span><span class="p">(</span><span class="n">root</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div> <p>This is really ugly and redundant. Here is an equivalent solution in C++.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">validate</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">long</span> <span class="n">m</span><span class="p">,</span> <span class="kt">long</span> <span class="n">M</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        
        <span class="k">if</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">val</span> <span class="o">&gt;=</span> <span class="n">M</span> <span class="o">||</span> <span class="n">root</span> <span class="o">-&gt;</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">validate</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">val</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">validate</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">,</span> <span class="n">max</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">val</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">M</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="kt">bool</span> <span class="nf">isValidBST</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">validate</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">INT_MIN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">INT_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div> <p><strong>BSTs</strong> <strong>don’t have</strong> <strong>duplicate values</strong>. Using a Balanced Search Tree (<strong>BST</strong>), we can do the following:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	1. Insert in O(log n)
        2. Delete in O(log n)
        3. Search for an element in O(log n)
        4. Find Min in O(log n)
        5. Find Max in O(log n)
        6. Get all the elements in sorted order in O(n) - Inorder traversal.
        7. Find an element closest in value to x O(log n)
</code></pre></div></div> <p><a href="#hashing">Hashmaps</a> are also a great way to store elements but the following operations cannot be done efficiently in hash tables:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        1. the min / max query in reasonable time
        2. Iterating through the element in sorted order in linear time
        3. Find an element closes to x in logarithmic time.
</code></pre></div></div> <p>Check out Segment Trees <a href="https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/" rel="external nofollow noopener" target="_blank">here</a>.</p> <h2 id="heaps-and-maps">Heaps and Maps</h2> <p><strong>Treemaps</strong> are implemented internally using balanced trees ( They mostly use red black trees). Take a look at <a href="https://stackoverflow.com/questions/6147242/heap-vs-binary-search-tree-bst" rel="external nofollow noopener" target="_blank">this</a> answer for comparison of Heaps and BSTs (Maps).</p> <h3 id="implementation-details">Implementation Details</h3> <p><strong>C++</strong>. <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">set</code> from the STL library are implemented using balanced red-black trees. Maps are sorted via keys.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Declaration */</span>
<span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">A</span><span class="p">;</span> <span class="c1">// O(1) declaration which declares an empty tree map.</span>
<span class="cm">/* Inserting a key */</span>
<span class="n">A</span><span class="p">[</span><span class="n">K</span><span class="p">]</span> <span class="o">=</span> <span class="n">V</span><span class="p">;</span> <span class="c1">// O(log n). Note that we expect key K to be unique here. If you have keys that will repeat, take a look at multimaps.</span>
<span class="cm">/* Delete a key */</span>
<span class="n">A</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">K</span><span class="p">);</span> <span class="c1">// O(log n)</span>
<span class="cm">/* Find a key */</span>
<span class="n">A</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="o">!=</span> <span class="n">A</span><span class="p">.</span><span class="n">end</span><span class="p">()</span>  <span class="c1">// O(log n)</span>
<span class="cm">/* Find minimum key K in the map */</span>
<span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">begin</span><span class="p">())</span><span class="o">-&gt;</span><span class="n">first</span>     <span class="c1">// O(1)</span>
<span class="cm">/* Find maximum key K in the map */</span>
<span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">rbegin</span><span class="p">())</span><span class="o">-&gt;</span><span class="n">first</span>     <span class="c1">// O(1)</span>
<span class="cm">/* Find closest key K &gt; x */</span>
<span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">first</span>     <span class="c1">// O(log n). Do need to handle the case when x is more than or equal to the max key in the map. </span>
<span class="cm">/* Find closest key K &gt;= x */</span> <span class="c1">// Use lower_bound</span>
<span class="cm">/* Iterate over the keys in sorted order */</span>
<span class="k">for</span> <span class="p">(</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">A</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// it-&gt;first has the key, it-&gt;second has the value. </span>
    <span class="p">}</span>
</code></pre></div></div> <p><strong>Python</strong> - Python does not have treemap. The closest implementation is <code class="language-plaintext highlighter-rouge">heapq</code>.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1"># declares an empty list / heap. O(1)
</span>            <span class="c1"># Note that heaps are internally implemented using lists for which heap[k] &lt;= heap[2*k+1] and heap[k] &lt;= heap[2*k+2] for all k. 
</span><span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">));</span>     <span class="c1"># O(log n)
</span><span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">A</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Delete the 'smallest' key. Deleting random key is inefficient.
</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># minimum key
</span></code></pre></div></div> <h3 id="heapsort">Heapsort</h3> <p>Heap sort can be understood as the improved version of the binary search tree. It does not create a node as in case of binary search tree instead it builds the heap by adjusting the position of elements within the array itself.</p> <p>In which method a tree structure called heap is used where a heap is a type of binary tree. An ordered balanced binary tree is called a <strong>Min-heap</strong>, where the value at the root of any subtree is less than or equal to the value of either of its children.</p> <p>An ordered balanced binary tree is called a <strong>max heap</strong> where the value at the root of any subtree is more than or equal to the value of either of its children.</p> <p><strong>A heap is a tree data structure that satisfies the following properties:</strong></p> <ol> <li> <strong>Shape property</strong>: Heap is always a complete binary tree which means that all the levels of a tree are fully filled. There should not be a node which has only one child. Every node except leaves should have two children then only a heap is called as a complete binary tree.</li> <li> <strong>Heap property</strong>: All nodes are either greater than or equal to or less than or equal to each of its children. This means if the parent node is greater than the child node it is called as a max heap. Whereas if the parent node is lesser than the child node it is called as a min heap.</li> </ol> <p><strong>Heapsort</strong> implementation in <strong>C++</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// To heapify a subtree rooted with node i which is</span>
<span class="c1">// Heapify:- A process which helps regaining heap properties in tree after removal </span>
<span class="kt">void</span> <span class="nf">heapify</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
   <span class="kt">int</span> <span class="n">largest</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// Initialize largest as root</span>
   <span class="kt">int</span> <span class="n">left_child</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// left = 2*i + 1</span>
   <span class="kt">int</span> <span class="n">right_child</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// right = 2*i + 2</span>
   <span class="c1">// If left child is larger than root</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">left_child</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">A</span><span class="p">[</span><span class="n">left_child</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">[</span><span class="n">largest</span><span class="p">])</span>
       <span class="n">largest</span> <span class="o">=</span> <span class="n">left_child</span><span class="p">;</span>
   <span class="c1">// If right child is larger than largest so far</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">right_child</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">A</span><span class="p">[</span><span class="n">right_child</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">[</span><span class="n">largest</span><span class="p">])</span>
       <span class="n">largest</span> <span class="o">=</span> <span class="n">right_child</span><span class="p">;</span>
   <span class="c1">// If largest is not root</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">largest</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">swap</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">largest</span><span class="p">]);</span>
       <span class="c1">// Recursively heapify the affected sub-tree</span>
       <span class="n">heapify</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">largest</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// main function to do heap sort</span>
<span class="kt">void</span> <span class="nf">heap_sort</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
   <span class="c1">// Build heap (rearrange array)</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
       <span class="n">heapify</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
   <span class="c1">// One by one extract an element from heap</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
       <span class="c1">// Move current root to end</span>
       <span class="n">swap</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
       <span class="c1">// call max heapify on the reduced heap</span>
       <span class="n">heapify</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="trie-advanced">Trie (Advanced)</h2> <p>Properties of the Trie for a set of the strings -</p> <ol> <li>The root node of the trie always represents the null node.</li> <li>Each child of nodes is sorted alphabetically.</li> <li>Each node can have a maximum of <strong>26</strong> children (A to Z).</li> <li>Each node (except the root) can store one letter of the alphabet.</li> </ol> <p>I’m lazy, so check the complete code <a href="https://www.javatpoint.com/trie-data-structure" rel="external nofollow noopener" target="_blank">here</a>.</p> <h1 id="important-topics">Important Topics</h1> <h2 id="bit-manipulation">Bit Manipulation</h2> <ul> <li>Integer data types. <ul> <li>If the <strong>most-significant</strong> byte is given the <strong>highest</strong> address then it is <strong>Little-endian architecture</strong>.</li> <li>If the <strong>most-significant</strong> byte is given the <strong>lowest</strong> address then it is <strong>Big-endian architecture</strong>.</li> </ul> </li> <li>2’s complement is given by adding 1 to inverted bits.</li> <li> <code class="language-plaintext highlighter-rouge">long long int</code> is stored in <code class="language-plaintext highlighter-rouge">8 bytes</code>.</li> <li>Get size of a data type using <code class="language-plaintext highlighter-rouge">sizeof(&lt;datatype&gt;)</code>.</li> </ul> <h3 id="tricks-with-bits">Tricks with bits</h3> <ul> <li> <code class="language-plaintext highlighter-rouge">x &amp; (x - 1)</code> will clear the lowest set bit of <code class="language-plaintext highlighter-rouge">x</code>.</li> <li> <code class="language-plaintext highlighter-rouge">x &amp; ~(x - 1)</code> extracts the lowest set bit of <code class="language-plaintext highlighter-rouge">x</code>.</li> <li>Check others <a href="https://www.interviewbit.com/tutorial/tricks-with-bits/#tricks-with-bits" rel="external nofollow noopener" target="_blank">here</a>. No, I was not lazy to write, they felt unimportant.</li> </ul> <h2 id="design">Design</h2> <ul> <li>You can generate a random number between 0 and 32767 using <code class="language-plaintext highlighter-rouge">rand()</code> in C++.</li> </ul> <h2 id="mathematics">Mathematics</h2> <ul> <li>Counting the number of prime numbers. Follow the logic used in CS251. Initialise all numbers to primes. Make all multiples to false. Or more formally, follow what’s called as <strong>Eratosthenes sieve method</strong>.</li> <li>Simple trick for questions like determine if a number <code class="language-plaintext highlighter-rouge">n</code> has the form \(a^x\): Check <code class="language-plaintext highlighter-rouge">pow(a, max)% n == 0</code>!!!!</li> </ul> <h2 id="pointers">Pointers</h2> <ul> <li>int, float - 4 bytes of memory , char - 1 byte of memory</li> <li>Pointers for 2D arrays and general syntax -&gt; <a href="https://www.geeksforgeeks.org/pointer-array-array-pointer/" rel="external nofollow noopener" target="_blank">here</a> </li> </ul> <h2 id="others">Others</h2> <ul> <li> <div class="language-cpp highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">hammingWeight</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="p">){</span>
            <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="o">&amp;</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
            <span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div> </div> </li> </ul> <h1 id="algorithms">Algorithms</h1> <h2 id="kmp---knuth-morris-pratt">KMP - Knuth Morris Pratt</h2> <blockquote> <p>Given a text <code class="language-plaintext highlighter-rouge">txt[0, ..., n-1]</code> and a pattern <code class="language-plaintext highlighter-rouge">pat[0, ..., m-1]</code>, write a function <code class="language-plaintext highlighter-rouge">search(char pat[], char txt[])</code> that prints all occurrences of <code class="language-plaintext highlighter-rouge">pat[]</code> in <code class="language-plaintext highlighter-rouge">txt[]</code>.</p> </blockquote> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// lsp[i] = the longest proper prefix of pat[0..i] which is also a suffix of pat[0..i]</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">lsp</span><span class="p">(</span><span class="n">needle</span><span class="p">.</span><span class="n">length</span><span class="p">(),</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">needle</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">lsp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">needle</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">needle</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">lsp</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">lsp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">needle</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">needle</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">++</span><span class="n">lsp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
<span class="c1">// TIME COMPLEXITY - O(needle.length())</span>
<span class="c1">// STORAGE COMPLEXITY - O(needle.length())</span>
</code></pre></div></div> <p>Counting the occurrences of needle in haystack:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">haystack</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span> <span class="n">j</span> <span class="o">==</span> <span class="n">needle</span><span class="p">.</span><span class="n">length</span><span class="p">())</span> 
	<span class="p">{</span>
		<span class="o">++</span><span class="n">ANSWER</span><span class="p">;</span>
		<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
   <span class="k">if</span><span class="p">(</span><span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">needle</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
   <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">lsp</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="o">--</span><span class="n">i</span><span class="p">;</span> 
   <span class="p">}</span>
   <span class="k">else</span>
       <span class="o">++</span><span class="n">j</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// TIME COMPLEXITY - O(haystack.length() * needle.length()) - Worst case is "AAAAA", "AA"</span>
<span class="c1">// STORAGE COMPLEXITY - O(1)</span>
</code></pre></div></div> <p><strong>Other pattern matching algorithms</strong></p> <ol> <li> <a href="https://www.geeksforgeeks.org/rabin-karp-algorithm-for-pattern-searching/?ref=rp" rel="external nofollow noopener" target="_blank">Rabin - Karp algorithm</a> - Something to do with hashes</li> <li> <a href="https://www.geeksforgeeks.org/boyer-moore-algorithm-for-pattern-searching/?ref=rp" rel="external nofollow noopener" target="_blank">Boyer Moore algorithm</a> - Something to do finding good and bad heuristics</li> </ol> <p>There are many more algorithms which are covered <a href="https://www.tutorialspoint.com/introduction-to-pattern-searching-algorithms" rel="external nofollow noopener" target="_blank">here</a>.</p> <h2 id="the-two-pointer-technique">The two pointer technique</h2> <p>This technique is a clever optimization on some brute force approaches in certain conditions. Let us take an example to understand this concept.</p> <p>Suppose you have to find two indices in a sorted (non-decreasing) array such that the sum of values at those indices is zero. The naive <code class="language-plaintext highlighter-rouge">O(n^2)</code> approach would be to check every pair of indices satisfying this condition.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> 
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// solution found. </span>
                <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> <span class="c1">// Clearly A[i] + A[j] would increase as j increases</span>
            <span class="p">}</span>
</code></pre></div></div> <p>Although, let us make some keen observations in this method. When <code class="language-plaintext highlighter-rouge">i</code> increases, <code class="language-plaintext highlighter-rouge">A[i]</code> increases, and the breaking point of the inner loop decreases. Also, the inner loop need not run till <code class="language-plaintext highlighter-rouge">A.size() - 1</code> but can end before <code class="language-plaintext highlighter-rouge">j = i</code>.</p> <p>We can rewrite the code such that the value of <code class="language-plaintext highlighter-rouge">j</code> starts from the end of the array and goes till <code class="language-plaintext highlighter-rouge">i</code>. In that case, we would break the inner loop when the sum goes <em>below</em> 0. And similarly, as <code class="language-plaintext highlighter-rouge">i</code> increases, the breaking point would decrease.</p> <p>Now, the value of the sum at the breaking point of the <strong>previous</strong> iteration will be positive as <code class="language-plaintext highlighter-rouge">A[i]</code> increases with <code class="language-plaintext highlighter-rouge">i</code>. Therefore, the iterations of the inner loop can begin from the breaking point of the previous iteration. In other words, consider the following code.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>    
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> 
            <span class="k">for</span> <span class="p">(;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// solution found. </span>
                <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> <span class="c1">// Clearly A[i] + A[j] would decrease as j decreases.</span>
            <span class="p">}</span>
</code></pre></div></div> <p>Consider the time analysis of this code. <code class="language-plaintext highlighter-rouge">i</code> only moves forward and <code class="language-plaintext highlighter-rouge">j</code> only moves backward. Therefore, this code runs in <code class="language-plaintext highlighter-rouge">O(n)</code>.</p> <p>In general, all two pointer approach work similarly. You look at the naive solution involving multiple loops and then you start analyzing the pattern on each loop. Try to look for monotonicity in one of the loops as other loops move forward. If you find that, you have found your optimization.</p> <h2 id="graph-algorithms">Graph Algorithms</h2> <h3 id="dijkstras-algorithm---graphs">Dijkstra’s Algorithm - Graphs</h3> <p>This algorithm finds the shortest distance from the source vertex to all other vertices in the graph. Refer <a href="#dijkstra's-algorithm">here</a>.</p> <p><strong>Caution</strong>. Dijkstra’s does not work in <em>negative</em> weighted graphs.</p> <h3 id="floyd-warshall-algorithm---ov3">Floyd Warshall Algorithm - <code class="language-plaintext highlighter-rouge">O(V^3)</code> </h3> <p>This algorithm finds the shortest distance between <strong>every pair</strong> of nodes in the graph. We initialise the solution matrix equal to the adjacency matrix. Then we perform the following update:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dist[i][k] + dist[k][j] if dist[i][j] &gt; dist[i][k] + dist[k][j]
</code></pre></div></div> <p>The C++ code is given as follows:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Pick all vertices as source one by one</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Pick all vertices as destination for the</span>
            <span class="c1">// above picked source</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// If vertex k is on the shortest path from</span>
                <span class="c1">// i to j, then update the value of</span>
                <span class="c1">// dist[i][j]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span>
                        <span class="o">&amp;&amp;</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span><span class="p">))</span>
                    <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div> <p>We can modify the solution to print the shortest paths also by storing the predecessor information in a separate 2D matrix. <a href="https://imada.sdu.dk/~jbj/DM85/lec6a.pdf" rel="external nofollow noopener" target="_blank">Here</a> is the proof of the algorithm.</p> <h3 id="mst---prims-algorithm">MST - Prim’s Algorithm</h3> <p>The basic idea is to maintain a set <code class="language-plaintext highlighter-rouge">S</code> and choose the edge with <strong>minimum</strong> cost connecting <code class="language-plaintext highlighter-rouge">S</code> and <code class="language-plaintext highlighter-rouge">V\S</code> in each iteration. This is implemented via priority queues, similar to Dijkstra’s.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// Create a priority queue to store vertices that</span>
    <span class="c1">// are being preinMST. This is weird syntax in C++.</span>
    <span class="c1">// Refer below link for details of this syntax</span>
    <span class="c1">// http://geeksquiz.com/implement-min-heap-using-stl/</span>
    <span class="n">priority_queue</span><span class="o">&lt;</span> <span class="n">iPair</span><span class="p">,</span> <span class="n">vector</span> <span class="o">&lt;</span><span class="n">iPair</span><span class="o">&gt;</span> <span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="n">iPair</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">pq</span><span class="p">;</span> <span class="c1">//greater&lt;iPair&gt; for reverse</span>
    <span class="kt">int</span> <span class="n">src</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Taking vertex 0 as source</span>
    <span class="c1">// Create a vector for keys and initialize all</span>
    <span class="c1">// keys as infinite (INF)</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">key</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">INF</span><span class="p">);</span>
    <span class="c1">// To store parent array which in turn store MST</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">// To keep track of vertices included in MST</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">inMST</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="c1">// Insert source itself in priority queue and initialize</span>
    <span class="c1">// its key as 0.</span>
    <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">src</span><span class="p">));</span>
    <span class="n">key</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="cm">/* Looping till priority queue becomes empty */</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pq</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="c1">// The first vertex in pair is the minimum key</span>
        <span class="c1">// vertex, extract it from priority queue.</span>
        <span class="c1">// vertex label is stored in second of pair (it</span>
        <span class="c1">// has to be done this way to keep the vertices</span>
        <span class="c1">// sorted key (key must be first item</span>
        <span class="c1">// in pair)</span>
        <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">second</span><span class="p">;</span>
        <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
          <span class="c1">//Different key values for same vertex may exist in the priority queue.</span>
          <span class="c1">//The one with the least key value is always processed first.</span>
          <span class="c1">//Therefore, ignore the rest.</span>
          <span class="k">if</span><span class="p">(</span><span class="n">inMST</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="nb">true</span><span class="p">){</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">inMST</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>  <span class="c1">// Include vertex in MST</span>
        <span class="c1">// 'i' is used to get all adjacent vertices of a vertex</span>
        <span class="n">list</span><span class="o">&lt;</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Get vertex label and weight of current adjacent</span>
            <span class="c1">// of u.</span>
            <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">first</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">weight</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">second</span><span class="p">;</span>
            <span class="c1">//  If v is not in MST and weight of (u,v) is smaller</span>
            <span class="c1">// than current key of v</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">inMST</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="nb">false</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">weight</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// Updating key of v</span>
                <span class="n">key</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span><span class="p">;</span>
                <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">v</span><span class="p">));</span>
                <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div> <h3 id="mst---kruskals-algorithm">MST - Kruskal’s Algorithm</h3> <p>The idea is much simpler compared to Prim’s. Although, the implementation is involved. We sort all the edges in the decreasing order of their weights, and add edges sequentially such that <strong>no cycles</strong> are formed. We use something known as the <strong>Union-Find</strong> algorithm to detect cycles.</p> <h4 id="union-find-algorithm">Union-Find algorithm</h4> <p>A <a href="http://en.wikipedia.org/wiki/Disjoint-set_data_structure" rel="external nofollow noopener" target="_blank"><em>disjoint-set data structure</em></a> is a data structure that keeps track of a set of elements partitioned into a number of disjoint (non-overlapping) subsets. A <a href="http://en.wikipedia.org/wiki/Disjoint-set_data_structure" rel="external nofollow noopener" target="_blank"><em>union-find algorithm</em></a> is an algorithm that performs two useful operations on such a data structure. A simple method to do this is maintain a parent array, and check the highest ancestors of the vertices in the new edge. If they are the same, then they form a cycle. Otherwise, the new edge does not form a cycle. This approach is <code class="language-plaintext highlighter-rouge">O(n)</code> in worst case. To improve this to <code class="language-plaintext highlighter-rouge">O(logn)</code> we can use <strong>union by rank</strong>.</p> <p>The basic problem in the above approach is, the parent tree can be highly skewed. We need to keep the tree balanced by always attaching the smaller depth tree under the root of the deeper tree. The second optimization to naive method is <strong><em>Path Compression</em></strong>. The idea is to flatten the tree when <code class="language-plaintext highlighter-rouge">find()</code> is called. When <code class="language-plaintext highlighter-rouge">find()</code> is called for an element x, root of the tree is returned. The <code class="language-plaintext highlighter-rouge">find()</code> operation traverses up from x to find root. The idea of path compression is to make the found root as parent of x so that we don’t have to traverse all intermediate nodes again. This is somewhat like a <em>dynamic programming</em> paradigm.</p> <p>The amortized time complexity of this method becomes constant. The implementation is as follows. For a change, I’m including the code in Python.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># A union by rank and path compression based
# program to detect cycle in a graph
</span><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="c1"># a structure to represent a graph
</span><span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">num_of_v</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">num_of_v</span> <span class="o">=</span> <span class="n">num_of_v</span>
        <span class="n">self</span><span class="p">.</span><span class="n">edges</span> <span class="o">=</span> <span class="nf">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="c1"># graph is represented as an
</span>    <span class="c1"># array of edges
</span>    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Subset</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">rank</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="n">self</span><span class="p">.</span><span class="n">rank</span> <span class="o">=</span> <span class="n">rank</span>
<span class="c1"># A utility function to find set of an element
# node(uses path compression technique)
</span><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">subsets</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">subsets</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">parent</span> <span class="o">!=</span> <span class="n">node</span><span class="p">:</span>
        <span class="n">subsets</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">parent</span> <span class="o">=</span> <span class="nf">find</span><span class="p">(</span><span class="n">subsets</span><span class="p">,</span> <span class="n">subsets</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">parent</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">subsets</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">parent</span>
<span class="c1"># A function that does union of two sets
# of u and v(uses union by rank)
</span><span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">subsets</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="c1"># Attach smaller rank tree under root
</span>    <span class="c1"># of high rank tree(Union by Rank)
</span>    <span class="k">if</span> <span class="n">subsets</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">rank</span> <span class="o">&gt;</span> <span class="n">subsets</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">rank</span><span class="p">:</span>
        <span class="n">subsets</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">parent</span> <span class="o">=</span> <span class="n">u</span>
    <span class="k">elif</span> <span class="n">subsets</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">rank</span> <span class="o">&gt;</span> <span class="n">subsets</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">rank</span><span class="p">:</span>
        <span class="n">subsets</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">parent</span> <span class="o">=</span> <span class="n">v</span>
    <span class="c1"># If ranks are same, then make one as
</span>    <span class="c1"># root and increment its rank by one
</span>    <span class="k">else</span><span class="p">:</span>
        <span class="n">subsets</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">parent</span> <span class="o">=</span> <span class="n">u</span>
        <span class="n">subsets</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">rank</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="c1"># The main function to check whether a given
# graph contains cycle or not
</span><span class="k">def</span> <span class="nf">isCycle</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="c1"># Allocate memory for creating sets
</span>    <span class="n">subsets</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">graph</span><span class="p">.</span><span class="n">num_of_v</span><span class="p">):</span>
        <span class="n">subsets</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nc">Subset</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="c1"># Iterate through all edges of graph,
</span>    <span class="c1"># find sets of both vertices of every
</span>    <span class="c1"># edge, if sets are same, then there
</span>    <span class="c1"># is cycle in graph.
</span>    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">:</span>
        <span class="n">u_rep</span> <span class="o">=</span> <span class="nf">find</span><span class="p">(</span><span class="n">subsets</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="n">v_rep</span> <span class="o">=</span> <span class="nf">find</span><span class="p">(</span><span class="n">subsets</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">u_rep</span> <span class="o">==</span> <span class="n">v_rep</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nf">union</span><span class="p">(</span><span class="n">subsets</span><span class="p">,</span> <span class="n">u_rep</span><span class="p">,</span> <span class="n">v_rep</span><span class="p">)</span>
</code></pre></div></div> <h1 id="sorting">Sorting</h1> <ul> <li> <strong>C++ -&gt;</strong> <strong><code class="language-plaintext highlighter-rouge">sort(v.begin(), v.end());</code></strong> </li> <li><strong>Python -&gt; <code class="language-plaintext highlighter-rouge">v.sort()</code></strong></li> <li>My best implementation of merging algorithm in merge sort:</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;)</span>
    <span class="k">if</span><span class="p">(</span><span class="n">nums2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums1</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>     <span class="n">res</span><span class="p">[</span><span class="n">c</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
    <span class="k">else</span>    <span class="n">res</span><span class="p">[</span><span class="n">c</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
<span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">n</span><span class="p">)</span>   <span class="n">res</span><span class="p">[</span><span class="n">c</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
<span class="k">while</span><span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">m</span><span class="p">)</span>   <span class="n">res</span><span class="p">[</span><span class="n">c</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
</code></pre></div></div> <h3 id="insertion-sort">Insertion Sort</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">INSERTION</span><span class="o">-</span><span class="n">SORT</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
   <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span>
   	<span class="n">key</span> <span class="err">←</span> <span class="n">A</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
    	<span class="n">j</span> <span class="err">←</span> <span class="n">i</span> <span class="err">–</span> <span class="mi">1</span>
  	 <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">and</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">key</span>
   		<span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="err">←</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
   		<span class="n">j</span> <span class="err">←</span> <span class="n">j</span> <span class="err">–</span> <span class="mi">1</span>
   	<span class="n">End</span> <span class="k">while</span> 
   	<span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="err">←</span> <span class="n">key</span>
  <span class="n">End</span> <span class="k">for</span> 
</code></pre></div></div> <h3 id="quick-sort">Quick Sort</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
* The main function that implements quick sort.
* @Parameters: array, starting index and ending index
*/</span>
<span class="n">quickSort</span><span class="p">(</span><span class="n">arr</span><span class="p">[],</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// pivot_index is partitioning index, arr[pivot_index] is now at correct place in sorted array</span>
        <span class="n">pivot_index</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>

        <span class="n">quickSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">pivot_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// Before pivot_index</span>
        <span class="n">quickSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pivot_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span> <span class="c1">// After pivot_index</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**
* The function selects the last element as pivot element, places that pivot element correctly in the array in such a way
* that all the elements to the left of the pivot are lesser than the pivot and
* all the elements to the right of pivot are greater than it.
* @Parameters: array, starting index and ending index
* @Returns: index of pivot element after placing it correctly in sorted array
*/</span>
<span class="n">partition</span> <span class="p">(</span><span class="n">arr</span><span class="p">[],</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// pivot - Element at right most position</span>
    <span class="n">pivot</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">high</span><span class="p">];</span>  
    <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// Index of smaller element</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">low</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// If current element is smaller than the pivot, swap the element with pivot</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>    <span class="c1">// increment index of smaller element</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">high</span><span class="p">]);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="selection-sort">Selection Sort</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SelectionSort</span><span class="p">(</span><span class="n">Arr</span><span class="p">[],</span> <span class="n">arr_size</span><span class="p">)</span><span class="o">:</span>    
        <span class="n">FOR</span> <span class="n">i</span> <span class="n">from</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">arr_size</span><span class="o">:</span>    
            <span class="n">min_index</span> <span class="o">=</span> <span class="n">FindMinIndex</span><span class="p">(</span><span class="n">Arr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">arr_size</span><span class="p">)</span>    
        
            <span class="n">IF</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">min_index</span><span class="o">:</span>    
                <span class="n">swap</span><span class="p">(</span><span class="n">Arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Arr</span><span class="p">[</span><span class="n">min_index</span><span class="p">])</span>    
            <span class="n">END</span> <span class="n">of</span> <span class="n">IF</span>    
        <span class="n">END</span> <span class="n">of</span> <span class="n">FOR</span>
</code></pre></div></div> <h3 id="bubble-sort">Bubble Sort</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bubbleSort</span><span class="p">(</span> <span class="n">Arr</span><span class="p">[],</span> <span class="n">totat_elements</span><span class="p">)</span>
   <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">total_elements</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span><span class="o">:</span>
      <span class="n">swapped</span> <span class="o">=</span> <span class="nb">false</span>
      <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">total_elements</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">2</span> <span class="k">do</span><span class="o">:</span>
         <span class="cm">/* compare the adjacent elements */</span>   
         <span class="k">if</span> <span class="n">Arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="n">then</span>
            <span class="cm">/* swap them */</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">Arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">Arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>		 
            <span class="n">swapped</span> <span class="o">=</span> <span class="nb">true</span>
         <span class="n">end</span> <span class="k">if</span>
      <span class="n">end</span> <span class="k">for</span>
      <span class="cm">/*if no number was swapped that means 
      array is sorted now, break the loop.*/</span>
      <span class="k">if</span><span class="p">(</span><span class="n">not</span> <span class="n">swapped</span><span class="p">)</span> <span class="n">then</span>
         <span class="k">break</span>
      <span class="n">end</span> <span class="k">if</span>
   <span class="n">end</span> <span class="k">for</span>
<span class="n">end</span>
</code></pre></div></div> <h1 id="recursion">Recursion</h1> <p>For Time Analysis of recursive programs, it may be easier to find lower bounds and upper bounds first. For example, consider the time analysis of recursive Fibonacci code.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">T</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">T</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">O</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="s">" Lower bound "</span>
<span class="n">T</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="n">T</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">O</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">O</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span> 
<span class="s">"""</span><span class="err">
</span><span class="s">Writing big-O notation here is not technically right. Instead we can write the following</span><span class="err">
</span><span class="s">If we know that T(n) = T(n - 1) + T(n - 2) + Θ(n), then we can write T(n) &gt; Ω(n)</span><span class="err">
</span><span class="s">"""</span>
<span class="s">" Upper bound "</span>
<span class="n">T</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="n">T</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">O</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">O</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="n">n</span><span class="p">)</span>
</code></pre></div></div> <p>Recursion builds up an implicit stack in the memory. To calculate the <strong>maximum</strong> space consumed, find the <strong>depth</strong> of the recursion tree.</p> <h1 id="hashing">Hashing</h1> <p>Hashing is the process of converting a given key into another smaller value for O(1) retrieval time. This is done by taking the help of some function or algorithm which is called as <strong>hash function</strong> to map data to some encrypted or simplified representative value which is termed as “hash code” or “hash”. This hash is then used as an index to narrow down search criteria to get data quickly.</p> <p><strong>Hash Table</strong> - A hash table is an array that stores pointers to data mapping to a given hashed key.</p> <p><strong>Bucket</strong> - A list containing all the values having the same hash value</p> <p><strong>Hash Functions</strong> - A hash function is a function or algorithm that is used to generate the encrypted or shortened value to any given key. Types of Hash Functions:</p> <ul> <li>Index Mapping method - The index of the element in the array is its hash.</li> <li>Division method - The hash is given by the remainder of the value with the table size. In this case, we need to take care of certain things. If the table length has the form \(r^p\) then the hash values occupy only the <code class="language-plaintext highlighter-rouge">p</code> lowest-order bits of key.</li> <li>Mid square method - Square the value and take the middle digits. For ex, <code class="language-plaintext highlighter-rouge">h(88) -&gt; 7(74)4 -&gt; 74</code>.</li> <li>Digit folding method - The key is divided into separate parts and by using simple operations these separated parts are combined to produce a hash.</li> </ul> <p><strong>Load Factor</strong> - The load factor is simply a measure of how full (occupied) the hash table is, and is simply defined as: <code class="language-plaintext highlighter-rouge">α = number of occupied slots/total slots</code></p> <h3 id="collisions">Collisions</h3> <p>When multiple elements fall into the same bucket, we say a collision has occured. Handling collisions:</p> <ul> <li> <p><strong>Separate Chaining</strong> - The idea is to maintain linked lists for buckets. Hashing performance can be evaluated under the assumption that each key is equally likely and uniformly hashed to any slot of hash table.</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>Performance Analysis
Load Factor = α = n/ table_size
Time Complexity for search and delete - O(1 + α)
Time Complexity for insert - O(1)
</code></pre></div> </div> </li> <li> <p><strong>Open Addressing</strong> - In this technique, we ensure that all records are stored in the hash table itself. The size of the table must be greater than or equal to the total number of keys available.</p> <ul> <li> <strong>Insert(Key)</strong> - When we try to insert a key to the bucket which is already occupied, we keep probing the hash table until an empty slot is found. Once we find the empty slot, we insert <code class="language-plaintext highlighter-rouge">key</code> into that slot.</li> <li> <strong>Search(key):</strong> While searching for <code class="language-plaintext highlighter-rouge">key</code> in the hash table, we keep probing until slot’s value doesn’t become equal to <code class="language-plaintext highlighter-rouge">key</code> or until an empty slot is found.</li> <li> <strong>Delete(key):</strong> While performing delete operation, when we try to simply delete <code class="language-plaintext highlighter-rouge">key</code>, then the search operation for that key might fail. Hence, deleted key’s slots are marked as “<strong>deleted</strong>” so that we get the status of the key when searched.</li> </ul> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>Performance Analysis
* Load factor, α = n/table_size ( α &lt; 1 )
* Expected time taken to search/insert/delete operation &lt; (1/(1 - α))
* Hence, search/insert/delete operations take at max (1/(1 - α)) time
</code></pre></div> </div> </li> </ul> <h2 id="implementation-details-1">Implementation Details</h2> <p><strong>C++</strong> - Use <code class="language-plaintext highlighter-rouge">unordered_map</code> which are implemented via hashing.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Declaration */</span>
<span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">A</span><span class="p">;</span>
<span class="cm">/* Inserting elements */</span>
<span class="n">A</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">});</span> <span class="c1">// O(1) on average</span>
<span class="cm">/* Finding elements */</span>
<span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">==</span> <span class="n">A</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="k">return</span> <span class="n">null</span><span class="p">;</span>
<span class="k">else</span> <span class="k">return</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>	<span class="c1">// Worst case O(n), Average O(1)</span>
<span class="cm">/* Printing size */</span>
<span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="c1">// O(1)</span>
<span class="cm">/* Erasing keys */</span>
<span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">!=</span> <span class="n">A</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="n">A</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">k</span><span class="p">));</span> <span class="c1">// or A.erase(k);</span>
</code></pre></div></div> <p><strong>Python</strong> - Use Dictionaries.</p> <h1 id="dynamic-programming">Dynamic Programming</h1> <ul> <li>Make sure you write the base cases in recursion!</li> <li>You can use <strong>static</strong> variables in cpp for storing the memory from previous calls to the function. For example, the Fibonacci numbers code can be written as</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">climbStairs</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
       <span class="k">static</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dict</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dict</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> 
            <span class="n">dict</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">climbStairs</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">climbStairs</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">dict</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
</code></pre></div></div> <p>Although, make sure the environment you are using supports static variables correctly.</p> <ul> <li>If you pass constant variables in recursion, pass them by reference rather than value to save memory and time!</li> </ul> <h2 id="longest-increasing-subsequence">Longest Increasing Subsequence</h2> <p>This is not a special problem, and the dynamic programming approach you are thinking of right now works. The time complexity is <code class="language-plaintext highlighter-rouge">O(n^2)</code>. Although, there is another interesting approach to this problem, and I felt it was worth mentioning. Let the given array be <code class="language-plaintext highlighter-rouge">A</code>. Make a sorted copy of <code class="language-plaintext highlighter-rouge">A</code> say <code class="language-plaintext highlighter-rouge">B</code>. Now, the <strong>longest common subsequence</strong> of <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> is our answer (Why?). This approach is also <code class="language-plaintext highlighter-rouge">O(n^2)</code>.</p> <h1 id="greedy-algorithms">Greedy Algorithms</h1> <p>A greedy algorithm is a simple and efficient algorithmic approach for solving any given problem by selecting the best available option at that moment of time, without bothering about the future results.</p> <p>In simple words, here, it is believed that the locally best choices made would be leading towards globally best results.In this approach, we never go back to reverse the decision of selection made which is why this algorithm works in a top-bottom manner.</p> <ul> <li>This approach works well for <strong>job scheduling</strong> problems.</li> </ul> <h1 id="graphs">Graphs</h1> <h2 id="breadth-first-search---ov--e">Breadth First Search - <code class="language-plaintext highlighter-rouge">O(V + E)</code> </h2> <p><strong>Shortest Path:</strong> In an unweighted graph, the shortest path is the path with least number of edges. With BFS, we <strong>always</strong> reach a node from given source in shortest possible path. Example: Dijkstra’s Algorithm.</p> <h3 id="recursive-bfs">Recursive BFS</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
* Pseudo code for recursive BFS
* @Parameters: Graph G represented as adjacency list, 
*  Queue q, boolean[] visited, key
* Initially q has s node in it.
*/</span>

<span class="n">recursiveBFS</span><span class="p">(</span><span class="n">Graph</span> <span class="n">graph</span><span class="p">,</span> <span class="n">Queue</span> <span class="n">q</span><span class="p">,</span> <span class="n">boolean</span><span class="p">[]</span> <span class="n">visited</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">())</span>
        <span class="k">return</span> <span class="s">"Not Found"</span><span class="p">;</span>

    <span class="c1">// pop front node from queue and print it</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">poll</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="o">==</span><span class="n">key</span><span class="p">)</span> <span class="k">return</span> <span class="s">"Found"</span><span class="p">;</span>

    <span class="c1">// do for every neighbors of node v</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">Node</span> <span class="n">u</span> <span class="n">in</span> <span class="n">graph</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">u</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="c1">// mark it visited and push it into queue</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">q</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// recurse for other nodes</span>
    <span class="n">recursiveBFS</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Queue</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Queue</span><span class="p">();</span>
<span class="n">q</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="n">recursiveBFS</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
</code></pre></div></div> <h3 id="iterative-bfs">Iterative BFS</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
* Pseudo code for iterative BFS
* @Parameters: Graph G, source node s, boolean[] visited, key
*/</span>

<span class="n">iterativeBFS</span><span class="p">(</span><span class="n">Graph</span> <span class="n">graph</span><span class="p">,</span> <span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="n">boolean</span><span class="p">[]</span> <span class="n">visited</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">){</span>
    <span class="c1">// create a queue neeeded for BFS</span>
    <span class="n">Queue</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">();</span>

    <span class="c1">// mark source node as discovered</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="c1">// push source node into the queue</span>
    <span class="n">q</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

    <span class="c1">// while queue isnt empty</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="c1">// pop front node from queue and print it</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">poll</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="o">==</span><span class="n">key</span><span class="p">)</span> <span class="k">return</span> <span class="s">"Found"</span><span class="p">;</span>

        <span class="c1">// for every neighboring node of v</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">:</span> <span class="n">graph</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
                <span class="c1">// mark it visited and enqueue to queue</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">q</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">//If key hasnt been found</span>
    <span class="k">return</span> <span class="s">"Not Found"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>Dijkstra’s in an unweighted graph is BFS</strong>.</p> <h2 id="depth-first-search---ov--e">Depth First Search - <code class="language-plaintext highlighter-rouge">O(V + E)</code> </h2> <p>The code is much simpler in this case</p> <h3 id="recursive-dfs">Recursive DFS</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
* Pseudo code for recursive DFS
* @Parameters: adjacent list G, source node, 
* visited array, key (node to be searched)
*/</span>

<span class="n">DFS</span><span class="p">(</span><span class="n">adjacent</span><span class="p">[][],</span> <span class="n">source</span><span class="p">,</span> <span class="n">visited</span><span class="p">[],</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span><span class="p">(</span><span class="n">source</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span> <span class="c1">//We found the key</span>
   <span class="n">visited</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">True</span>
   
   <span class="n">FOR</span> <span class="n">node</span> <span class="n">in</span> <span class="n">adjacent</span><span class="p">[</span><span class="n">source</span><span class="p">]</span><span class="o">:</span>
       <span class="n">IF</span> <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">==</span> <span class="n">False</span><span class="o">:</span>
          <span class="n">DFS</span><span class="p">(</span><span class="n">adjacent</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
       <span class="n">END</span> <span class="n">IF</span>
   <span class="n">END</span> <span class="n">FOR</span>
   <span class="k">return</span> <span class="nb">false</span>    <span class="c1">// If it reaches here, then all nodes have been explored </span>
                  <span class="c1">//and we still havent found the key.</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="iterative-dfs">Iterative DFS</h3> <p>Just replace <code class="language-plaintext highlighter-rouge">queue</code> with <code class="language-plaintext highlighter-rouge">stack</code> in iterative BFS.</p> <h2 id="dijkstras-algorithm">Dijkstra’s Algorithm</h2> <p>It is used to find the <strong>shortest path</strong> between a node/vertex (source node) to any (or every) other nodes/vertices (destination nodes) in a graph. A graph is basically an interconnection of nodes connected by edges. This algorithm is sometimes referred to as <strong>Single Source Shortest Path Algorithm</strong> due to its nature of implementation.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Dijkstra_Algorithm</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">G</span><span class="p">)</span><span class="o">:</span>
    <span class="s">"""</span><span class="err">
</span><span class="s">    parameters: source node--&gt; source, graph--&gt; G</span><span class="err">
</span><span class="s">    return: List of cost from source to all other nodes--&gt; cost</span><span class="err">
</span><span class="s">    """</span>
    <span class="n">unvisited_list</span> <span class="o">=</span> <span class="p">[]</span>			<span class="c1">// List of unvisited vertices</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>              <span class="c1">// Distance (cost) from source to source will be 0</span>
    <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">v</span> <span class="n">in</span> <span class="n">G</span><span class="o">:</span>       <span class="c1">// Assign cost as INFINITY to all vertices</span>
       <span class="k">if</span> <span class="n">v</span> <span class="err">≠</span> <span class="n">source</span>
             <span class="n">cost</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">INFINITY</span>
             <span class="n">add</span> <span class="n">v</span> <span class="n">to</span> <span class="n">unvisited_list</span>    <span class="c1">// All nodes pushed to unvisited_list initially</span>

    <span class="k">while</span> <span class="n">unvisited_list</span> <span class="n">is</span> <span class="n">not</span> <span class="n">empty</span><span class="o">:</span>        	     <span class="c1">// Main loop</span>
       <span class="n">v</span> <span class="o">=</span> <span class="n">vertex</span> <span class="n">in</span> <span class="n">unvisited_list</span> <span class="n">with</span> <span class="n">min</span> <span class="n">cost</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>      <span class="c1">// v is the source node for first iteration</span>
       <span class="n">remove</span> <span class="n">v</span> <span class="n">from</span> <span class="n">unvisited_list</span>		            <span class="c1">// Marking node as visited </span>

       <span class="k">for</span> <span class="n">each</span> <span class="n">neighbor</span> <span class="n">u</span> <span class="n">of</span> <span class="n">v</span><span class="o">:</span>			<span class="c1">// Assign shorter path cost to neigbour u</span>
          <span class="n">cost_value</span> <span class="o">=</span> <span class="n">Min</span><span class="p">(</span> <span class="n">cost</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">cost</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+</span> <span class="n">edge_cost</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">)]</span>
          <span class="n">cost</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost_value</span>            		<span class="c1">// Update cost of vertex u </span>

    <span class="k">return</span> <span class="n">cost</span>
</code></pre></div></div> <h1 id="miscellaneous">Miscellaneous</h1> <ul> <li>Each element in the array appears twice except for one element which appears only once. Use <strong>xor</strong>.</li> <li>Rotate a matrix by sequential reflection operations.</li> <li>32 but integers range from <code class="language-plaintext highlighter-rouge">-2147483648</code> to <code class="language-plaintext highlighter-rouge">2147483647</code>. The small difference may give a wrong answer in your code.</li> <li>Make sure you initialise <strong>flag</strong> variables.</li> <li>When you declare pointers, put a star <code class="language-plaintext highlighter-rouge">*</code> in front of every variable. That is, use <code class="language-plaintext highlighter-rouge">int *p, *q</code> and not <code class="language-plaintext highlighter-rouge">int* p, q</code>.</li> <li>Sometimes, arithmetic operations may cause the result to cross the datatype boundary. Take care of these. For example, instead of <code class="language-plaintext highlighter-rouge">(l + r)/2</code>, use <code class="language-plaintext highlighter-rouge">(l/2 + r/2 + (l%2+ r%2)/2</code>.</li> <li>Missing number from range - Use <code class="language-plaintext highlighter-rouge">xor</code> instead of <code class="language-plaintext highlighter-rouge">sum</code> </li> <li>Define a macro using <code class="language-plaintext highlighter-rouge">typedef pair&lt;int, int&gt; ipair</code> in <strong>C++</strong>.</li> <li>You can find the \(n\)th Fibonacci number in <code class="language-plaintext highlighter-rouge">O(log n)</code> time. Think about it.</li> <li>Don’t assume <em>positive</em> numbers when an integer input is mentioned.</li> <li>Initialise <code class="language-plaintext highlighter-rouge">vector&lt;vector&lt;int&gt;&gt;</code> properly. Specifically, ensure you <strong>allocate</strong> memory before accessing.</li> <li>When you write code for a DP problem, make sure you write the <strong>base cases</strong> first.</li> <li>Checking boxes in Sudoku grid using <code class="language-plaintext highlighter-rouge">1-9</code> loop of <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code> : <code class="language-plaintext highlighter-rouge">int x = (i/3)*3 + j/3, y = (i%3)*3 + j%3;</code> </li> <li>In sequence problems, make sure you test your algorithm in the beginning, the middle and the end. <ul> <li>Continuously check the range of values reached by the variables you declare. It may happen that the value of a <code class="language-plaintext highlighter-rouge">int</code> is going beyond <code class="language-plaintext highlighter-rouge">32</code> bits.</li> </ul> </li> <li>Use <code class="language-plaintext highlighter-rouge">bitset</code> instead of 2D vectors for “visited” matrices. <code class="language-plaintext highlighter-rouge">bitset&lt;n&gt; bits</code> declares <code class="language-plaintext highlighter-rouge">n</code> bits which can be accessed using <code class="language-plaintext highlighter-rouge">bits[i]</code>.</li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/NumAn/">Numerical Analysis Notes</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/ipl/">IPL Notes</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/philosophy/">Philosophy Notes</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/operating-systems/">Operating System Notes</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/dbms/">DiBS Notes</a> </li> </div> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Sudhansh Peddabomma. Last updated: March 21, 2024. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?9b43d6e67ddc7c0855b1478ee4c48c2d" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-0K9MLG0V24"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-0K9MLG0V24");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>