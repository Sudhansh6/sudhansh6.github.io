---
layout: post
title: Large Language Model Reasoning 
categories: [Research]
description: A survey of papers to better understand the workings of Large Language Models.

---

# Introduction

As a part of this article, we delve into the paradigm of Chain of Though reasoning in Large Language Models. The aim is to highlight the importance of this idea and summarize the main research in this area. The blog should provide enough context for the reader in the field of AI to understand the basic concepts and think about the potential research ideas addressing the limitations of the current models.

# Chain of thought Reasoning

Chain of thought (CoT) refers to manifesting the human thought process in large language models by endowing language models with the ability to generate a chain of thought - a coherent series of intermediate reasoning steps.

It is hypothesized that CoT prompting helps LLMs to tackle complex arithmetic, commonsense and symbolic reasoning tasks. The following demonstration highlights this improvement.

![COT](https://www.promptingguide.ai/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fcot.1933d9fe.png&w=1920&q=75)

However, there are some limitations with this paradigm of reasoning with the current models.

- Small models are unable to improve with CoT prompting. LLMs with more than 100B parameters show performance gains with CoT.
- The performance improvements are larger with larger models. In other words, the benefits of CoT scale with the size of the models.
- Sometimes the models arrive at the correct answers with the wrong reasoning. The errors have been classified as
  - **Calculation error** - LLMs are probabilistic models, predicting what token occurs next. So when an LLM tries to do $$3* 25* 8 =$$, it does not really calculate the answer but probabilistically guesses the answer which is the next token. This highlights a fundamental limitation in the current architectures of LLMs.
  - **Symbol mapping error** - When there are too many variables involved, LLMs sometimes mix up the variables and arrive at the wrong answer. Again, the problem arises from the fundamental architecture flaw highlighted in the previous point.
  - Other than these major errors, the models also have semnatic understanding problems, missing steps, incoherent chain of thought errors

# [Large Language Models are Human-level prompt engineers]([[2211.01910] Large Language Models Are Human-Level Prompt Engineers](https://arxiv.org/abs/2211.01910))

The motivation of this paper is as follows - 

- **Human effort in prompt engineering** - Crafting effective prompts for LLMs is time-consuming and requires significant human expertise.

- **Optimization challenge** - Primpts greatly influence LLM performance, but users often lack insight into how to optimize them for specific tasks.

- **Scalability** - As LLMs grow in size and capabilities, manuallt designing prompts becomes less deasible for a wide range of applications.

- **Automating promtp design** - There is a growing need to automate the prompt engineering process to enhance LLM usability and performance.

- **Real-world impact** - Applications in diverse domains (e.g., AI chatbots, automated content generation) can benefit from optimized and automated prompts.

This work promposes an **Automatic Prompt Engineer (APE)** - asystem that automates prompt generationg and selection for Large Language Models. This task is treated as a program synthesis task wherein the input-output pairs (natural language questions and answers) are given to the APE, and it has to generate the instruction needed to generate these pairs. 

In essence, the APE is trying to learn the prompts generated by humans. The framework is as follows -

1. Instruction Generation. An LLM is used as an ingeerence model where the "instruction candidates" are generated based on a small set of input-output demonstrations
   
   Example: The input to APE is of the form -
   
   *Input 1* - Forward generation technique
   
   """
   
   I gave a friend an instruction and five inputs. The friend read the instruction and wrote an output for every one of the inputs. Here are the input-output pairs
   
   Input: [ ] Output: [ ] 
   
   Input: [ ] Output: [ ] 
   
   ...
   
   The instruction was \<COMPLETE\>
   
   """"
   
   *Input 2* - Reverse generation technique
   
   """
   
   I instructed my friend to \<INSERT\>
   
   The friend read the instructions and wrote an output for every one of the inptus. Here are the input-output pairs:
   
   Input: [ ] Output: [ ]
   
   Input: [ ] Output: [ ]
   
   ...
   
   """

2. Scoring Instructions. Evaluate each instruction by computing a score that reflects how well the instruction guides the target LLM for the task. This is simply the confidence score associated with the log likelihoods of token generation. The authors consider a *moving average* score considering the probabilities for a window of tokens.
   
   They also consider an **execution accuracy** - the success of an instruction by checking if the model produces the correct output (0-1 loss). However, this cannot. be used for all kinds of instructions. 
   
   The top $$k$$-percentile prompts are selected and the rest are discarded.

3. LLM as Resampling Model. They apply an Iterative Monte search method to resample more prompts. The LLM generates semnatically similar instructions variants to improve the top-performing candidates. 
   
   Once the prompts are generated, the moving average scores are generated for each of the prompts and the better scoring prompts are selected again.

Can APE be used to guide LLMs?

![](/Users/s/Desktop/Projects/Website/assets/img/bc45f7f43ae9ca99bce80bdc9e40d94dcf50dae6.png)

Although this is a very simple example, the work shows potential in taking such framework forward to work with more complex applications.

Another interesting approach is to not generate the prompts from scratch, but to help humans design better prompts. Essentially, augment with context from humans to generate better prompts. On the flipside, RLHF can be used to improve these APE. 

# [Tree of Thoughts](https://proceedings.neurips.cc/paper_files/paper/2023/file/271db9922b8d1f4dd7aaef84ed5ac703-Paper-Conference.pdf)

The early Language Models were limited by their token-level, left-to-right decision making. However, some tasks require exploration, stratefic lookahead, planning, and backtracking. The vanilla architecture does not support such mechanisms.

## Framework

![](/Users/s/Desktop/Projects/Website/assets/img/3d3c328959cc5f222569e6a4edf2e051da328d61.png)

Mathematically, these models are depicted as

- Input output programming - $$y \sim p_\theta^{IO}(y \vert x)$$

- Chain

Theoretically, the model seems promising. However, there are some intricate details that need to be figured out -

- How to decompose the porcess into steps

- How to generate the potential thoughts from each state
  
  - Need to be small enough so LMs can generate promising and diverse samples
  
  - Big enough so LMs can evaluate the difference contributing to the results

- How to heuristically evaluate each state

- How to navigate through the generated tree

## Thought decomposition

![](/Users/s/Desktop/Projects/Website/assets/img/abc3d35efa56612a4b53dd782c0d4d058c961736.png)

### Method 1 - Direct Prompting

The prompts themselves can ask the LM to segment the problem into multiple problems. Due to the voting mechanism, LM generates multiple possibilities for an answer and chooses the best model. This works better when thought space is rich and i.i.d samples lead to diversity.

### Method 2 - Backtracking

Propose thoughts sequentially using a "propose prompt". When the thought space is constrained, this works better - proposing different thoughts in the same context avoids duplication.

## State Evaluator

There are two strategies to evaluate each generated state

- **Value** each state independently, where a value prompt reasons about the state $$s$$ to generate a scalar value $$v$$. This value is very context dependent.

- **Vote** across states by deliberately comparing different states in $$S$$ in a vote prompt.

## Search Algorithm

- **BFS** is helpful when the tree depth is limited and the initial thought steps can be evaluated and pruned to a small set

- **DFS** explores longer trees well - subtrees are pruned to trade exploration for exploitation.

- More advanced approaches such as $$A^*$$ and MCTS are left to future work in the paper.

An interesting summary of all thought paradigms - [Demytifying Chains, Trees, and Graphs of Thoughts](https://arxiv.org/pdf/2401.14295).

# [On Second Thought, Let's Not Think Step by Step! Bias and Toxicity in Zero-Shot Reasoning](https://urldefense.com/v3/__https://arxiv.org/abs/2212.08061__;!!Mih3wA!FUSiREHKHqULp_GaFY0sSmJRsiVZqYBdk9nJf8WWrKLI4UoxKUzc3ir1rIQaWXw6bk6_UVVe0kXW$)

We have seen how chain of thought improves problem solving capabilities. However, in some cases, CoT actually causes issues -

![](/Users/s/Desktop/Projects/Website/assets/img/2024-10-30-10-17-51-image.png)

The authors explore such effects in the paper. They consider
