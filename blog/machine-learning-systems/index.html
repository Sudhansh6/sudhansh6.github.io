<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Key Works in ML Systems | Sudhansh Peddabomma </title> <meta name="author" content="Sudhansh Peddabomma"> <meta name="description" content="Few keypoints from books other important papers in the field."> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?d0883cd261a1387cbdd04fa5cb9cc690" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%91%BE&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://sudhansh6.github.io/blog/machine-learning-systems/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> <script src="/assets/js/chat.js?e73db4280bae3cbae4d78219277155b9"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Sudhansh Peddabomma </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Articles </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"> </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/challenges/">Challenges</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/misc/">Miscellaneous</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">Key Works in ML Systems</h1> <p class="post-meta"> Created in January 16, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/category/notes"> <i class="fa-solid fa-tag fa-sm"></i> Notes</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <blockquote> <p>Acknowledging use of Perplexity, ChatGPT and the reference books and papers to aid with the content.</p> </blockquote> <h1 id="introduction">Introduction</h1> <p>As with every other article, this one starts with the same remark too - We are at an inflection point in human history. Artificial Intelligence (AI) is everywhere, and its growth has been unparalleled. We are in the AI revolution.</p> <p>At times like these, it is important to think about the future - how do we create systems that work alongside humanity to tackle the biggest problems life faces? We must master a new field of engineering to maintain this unprecedented pace.</p> <h2 id="history-of-ai">History of AI</h2> <p><img src="assets/reading01/2025-01-16-17-56-14-image.png" alt=""></p> <p>Starting with symbolic AI, one of the early approaches, STUDENT system developed by Daniel Bobrow in 1964, demonstrated natural language understanding by converting English text into algebraic equations. However, it was a rule-based system that was very brittle to the grammatical structure - although the solution may appear intelligent, it did not have a genuine understanding of language or the actions it was taking. This issue is the primary problem behind rule-based approaches.</p> <p>Then followed expert systems in 1970s, which focused on domain specific problems over generalized AI. For example, MYCIN developed by Stanford showed a major leap in medical AI with it’s 600 rules-based system. Nevertheless, scaling these rules with newer discoveries is infeasible.</p> <h3 id="statistical-learning">Statistical Learning</h3> <p>In the 1990s, something radical happened - the field moved away from rules to data-driven approaches. With the digital revolution, new capabilities got unlocked. From regression to neural networks, we allowed machines to discover patterns in the data leading to diverse applications. This new paradigm changed the way we approached machine learning. Quality of data, metrics to evaluate performance and trade-offs in design choices - all became relevant research questions.</p> <p>During the 2000s, algorithms like decision trees and KNNs made their way into practical applications. SVMs with their “kernel trick” became very popular. Human engineered features combined with statistical learning was the characteristic in the algorithms, and they had strong mathematical foundations as well. The models performed well with limited data, and produced reliable results. Even modalities like face detection with Viola-Jones algorithm (2001) became feasible.</p> <h3 id="deep-learning">Deep Learning</h3> <p>A double-edged sword, deep learning became the new kid in the block since the 2010s. Deep learning networks automatically discovered features in the data, doing away with feature engineering. Starting with AlexNet in 2012, the successes with deep learning models have never been shy. Researchers realized that bigger models equals better performance. Now, in the 2020s, we have entered the age of large models which have parameters reaching into few hundreds of billions! The datasets are well into the Petabytes stage.</p> <p>The three pillars required for these models to be successful, big data, better compute, and algorithmic breakthroughs, have successfully been put in place over the past few decades.</p> <p>These new depths have raised important questions about the future: how do we store and serve such models and datasets?!</p> <h2 id="ml-systems-engineering">ML Systems Engineering</h2> <p>It is the discipline of designing, implementing, and operating AI systems across computing scales. A machine learning system is an integrated computing system with three main parts - data, models and the compute infrastructure.</p> <p>Software Engineering as a field has been well established over the past decade. Even though the field is not yet mature, it has practices in place to enable reliable development, testing and deployment of software systems. However, these ideas are not entirely applicable to Machine Learning systems. Changes in the data distribution can alter the system behavior - this is a new paradigm we have not addressed before.</p> <p>More than often, the performance requirements guide the design decisions in the architecture. The complexities arise due to the broad spectrum across which ML is deployed today - from edge-devices to massive GPU-cloud clusters, each presents unique challenges and constraints. Operational complexities increase with system distribution. Some applications may have privacy requirements. The budget of the system acts as an important constraint. All these tradeoffs are rarely simple choices.</p> <p>Modern ML systems must seamlessly connect with existing software, process diverse data sources, and operate across organizational boundaries, driving new approaches to system design. FarmBeats by Microsoft, Alphafold by Deepmind and Autonomous vehicles are excellent examples of how proper systems in place can really push the extent of ML applicability.</p> <h2 id="challenges">Challenges</h2> <ol> <li> <p>Data Challenges - How do we store and process different kinds of data, and how to accommodate patterns with time?</p> </li> <li> <p>Model Challenges - How do we create efficient systems for different forms of learning, and test their performance across a wide range of scenarios?</p> </li> <li> <p>Systems Challenges - How do we set up pipelines in place to combine all of this in place? Systems that have monitoring and stats, that allow model updates and handle operational challenges.</p> </li> <li> <p>Ethical and Social Considerations - How do we address bias in such large-scale models? Can we do something about the “black-box” nature? Can we handle data privacy and handle inference attacks?</p> </li> </ol> <p>A major solution to address all these challenges has been to <em>democratize AI technology</em>. Similar to an “all hands-on deck” solution, with the involvement of a large amount of people in this evolution, we are tackling one of the most innovative problem’s humanity has ever faced - how do we achieve AGI?</p> <h1 id="dnn-architectures">DNN Architectures</h1> <p>Assuming the reader’s know enough about different model architectures, we shall now discuss the core computations involved in these models to design the systems around them.</p> <h2 id="architectural-building-blocks">Architectural Building Blocks</h2> <p>So far, we have the following major architectures summarized below -</p> <h3 id="multi-layer-perceptrons-mlps">Multi-Layer Perceptrons (MLPs)</h3> <ul> <li> <p>Purpose: Dense pattern processing</p> </li> <li> <p>Structure: Fully connected layers</p> </li> <li> <p>Key operation: Matrix multiplication</p> </li> <li> <p>System implications:</p> <ul> <li>High memory bandwidth requirements</li> <li>Intensive computation needs</li> <li>Significant data movement</li> </ul> </li> </ul> <h3 id="convolutional-neural-networks-cnns">Convolutional Neural Networks (CNNs)</h3> <ul> <li> <p>Purpose: Spatial pattern processing</p> </li> <li> <p>Key innovations: Parameter sharing, local connectivity</p> </li> <li> <p>Core operation: Convolution (implemented as matrix multiplication)</p> </li> <li> <p>System implications:</p> <ul> <li>Efficient memory access patterns</li> <li>Specialized hardware support (e.g., tensor cores)</li> <li>Opportunity for data reuse</li> </ul> </li> </ul> <h3 id="recurrent-neural-networks-rnns">Recurrent Neural Networks (RNNs)</h3> <ul> <li> <p>Purpose: Sequential pattern processing</p> </li> <li> <p>Key feature: Maintenance of internal state</p> </li> <li> <p>Core operation: Matrix multiplication with state update</p> </li> <li> <p>System implications:</p> <ul> <li>Sequential processing challenges</li> <li>Memory hierarchy optimization for state management</li> <li>Variable-length input handling</li> </ul> </li> </ul> <h3 id="transformers-and-attention-mechanisms">Transformers and Attention Mechanisms</h3> <ul> <li> <p>Purpose: Dynamic pattern processing</p> </li> <li> <p>Key innovation: Self-attention mechanism</p> </li> <li> <p>Core operations: Matrix multiplication and attention computation</p> </li> <li> <p>System implications:</p> <ul> <li>High memory requirements</li> <li>Intensive computation for attention</li> <li>Complex data movement patterns</li> </ul> </li> </ul> <p>Some innovations like skip connections, normalization techniques, and gating mechanisms are highlighted as important building blocks that require specific architectures. With these in mind, we require the following primitives -</p> <ul> <li> <p><strong>Core Computational Primitives</strong> -Matrix multiplication, Sliding window operations, Dynamic computation</p> </li> <li> <p><strong>Memory Access Primitives</strong> - Sequential access, Strided access, Random access</p> </li> <li> <p><strong>Data Movement Primitives</strong> - Broadcast, Scatter, Gather and Reduction</p> </li> </ul> <p>We address these primitives, by designing efficient systems as well as hardware.</p> <ul> <li> <p><strong>Hardware</strong> - Development of specialized processing units (e.g., tensor cores), Complex memory hierarchies and high-bandwidth memory, Flexible interconnects for diverse data movement patterns</p> </li> <li> <p><strong>Software</strong> - Efficient matrix multiplication libraries, Data layout optimizations, Dynamic graph execution support</p> </li> </ul> <h2 id="conclusion">Conclusion</h2> <p>In summary, understanding the relationship between high-level architectural concepts is important for their implementation in computing systems. The future advancements in deep learning will likely stem from both novel architectural designs and innovative approaches to implementing and optimizing fundamental computational patterns.</p> <p>Now that we have understood the basics of Machine Learning Systems, let us delve into the two biggest frameworks that support the ML systems today.</p> <h1 id="tensorflow-a-system-for-large-scale-machine-learning"><a href="https://arxiv.org/pdf/1605.08695" rel="external nofollow noopener" target="_blank">TensorFlow: A system for large-scale machine learning</a></h1> <p>A product of Google brain built to tackle large scale systems in heterogeneous environments. TensorFlow uses data-flow graphs to represent computations, shared states and operations. These can be mapped across many machines giving a flexibility to the developers.</p> <p>TensorFlow is based on a previous product of Google Brain, DistChild, that was used for a large number of research and commercial tasks. The team recognized the recent advances in ML - CNNs that broke records reaching up to millions of parameters and GPUs that accelerated the training processes. They developed a framework that is well-optimized for general scenarios for both training and inference. They also meant for it to be <em>extensible</em> - to allow ability to experiment and scale in production with the same code.</p> <p>Prior to this work, Caffe, Theano and Torch were the major frameworks. Caffe was known for its high-performance, Theano for its data flow model and Torch for its imperative programming model. Along with these works, TensorFlow also draws inspiration from the map-reduce paradigm that improved the performance of data systems significantly.</p> <h2 id="tensorflow-execution-model">TensorFlow execution model</h2> <p>The computation and state of the algorithm, including the mathematical operations are represented in a single dataflow graph. The communications between the subcomputations are made explicitly to execute independent computations in parallel and partition the computation across distributed devices. The key point to note here is that the graph has mutable states for the individual vertices, meaning that data can be shared between different executions of the graph. Although this point may seem trivial now, architectures prior to TensorFlow worked with static computations graphs that did not allow changes to the weights - algorithms such as mini-batch gradient descent were not scalable to large parameter models. Due to this change in the architecture, developers can experiment with different optimization algorithms, consistency schemes and parallelization strategies.</p> <h3 id="dataflow-graph-elements">Dataflow graph elements</h3> <p>Each vertex in the dataflow graph is an atomic unit of computation and each edge is the output or input to a vertex - values flowing through tensors.</p> <p><strong>Tensors</strong> - Notably, <em>tensors</em> as a computational quantity were introduced in this paper. Their work assumes all tensors are dense - this allows simple implementations for memory allocation and serialization.</p> <blockquote> <p>Modern neural networks on the contrary have sparse tensors in many scenarios - can be optimized greatly</p> </blockquote> <p>TensorFlow does allow representing sparse tensors but at the cost of more sophisticated shape inference.</p> <p><strong>Operations</strong> - An operation can simply be thought of as a function that takes \(m \geq 0\) tensors as input and returns \(n \geq 0\) tensors as output. The number of arguments to these operators can be constant or variable (<em>variadic</em> operators). <strong>Stateful operations</strong> (variables and queues) contain mutable states that can be updated every time the operator executes. Variables are mutable buffers storing shared parameters and queues support advanced forms of coordination.</p> <h3 id="partial-and-concurrent-execution">Partial and concurrent execution</h3> <p>The key advantage of storing the dataflow as a graph is the ability to execute independent operations in parallel. Once a graph is defined by the user, the API allows for executing any sub-graph the user queries. Each invocation is a <em>step</em> and TensorFlow supports multiple <em>concurrent steps</em>. This ability shines for the batch-processing workflows in neural networks. Furthermore, TensorFlow has a checkpointing subgraph that runs periodically for fault tolerance.</p> <p>This functionality of running graphs partially and concurrently contribute much to TensorFlow’s flexibility.</p> <h3 id="distributed-execution">Distributed execution</h3> <p>Since the communication between subcomputations is explicit, the distribution of the dataflow becomes simpler. Each operation resides on a particular <em>device</em> (note that this feature has also been adapted in PyTorch), and a device is responsible for executing a <em>kernel</em> for each operation assigned to it. TensorFlow allows multiple kernels to be registered for a single operation.</p> <p>The placement algorithm computes a feasible set of devices for each operation, calculates the sets of operations that must be colocated and selects a satisfying device for each colocation group. In addition, the users can also specify their device preferences for a particular task. <em>Yes, TensorFlow was advanced since the beginning</em>.</p> <p>Once the operations are placed, the partial subgraphs are computed for a step, and are pruned and partitioned across the devices. The communication mechanisms between devices is also put in place with specialized implementations to optimize for latency with large-subgraphs running repeatedly. On the user-end, a <em>client session</em> maintains a mapping from step definitions to cached subgraphs. This computation model performs the best with static, reusable graphs but also supports dynamic computations with control flows.</p> <h3 id="dynamic-control-flow">Dynamic control flow</h3> <p>Although most evaluation in TensorFlow is <em>strict</em>, wherein it requires for all inputs to an operation to be computed before the operation executes, advanced algorithms (such as RNNs), require dynamic control flow, requiring non-strict evaluation. To aid with this, TensorFlow also supports primitive <strong>Switch</strong> (demultiplexer) and <strong>Merge</strong> (multiplexer) operations for dynamic dataflow architectures! These primitives can be used to build a non-strict conditional sub-graph that executes one of two branches based on the runtime values of a tensor. These primitives also support loops with additional structural constraints based on the dataflow!</p> <h2 id="extensibility">Extensibility</h2> <ul> <li> <p><strong>Differentiation</strong> - TensorFlow has a user-level library that <strong>automatically differentiates</strong> expressions. It performs a breadth-first search to identify all of the backwards paths from the target operation (loss function) to a set of parameters in the computation graph, and sums the partial gradients that each path contributes. With optimizations such as batch normalization and gradient clipping, the algorithm also supports backpropagation through conditional and iterative subcomputations! All of this done with memory management on GPU.</p> </li> <li> <p><strong>Optimization</strong> - SGD is a simple algorithm encoded in the framework. However, for more advanced optimization schemes like Momentum, TensorFlow relies on community driven implementations that are easily pluggable without modifying the underlying system. Such a modular framework was not available before.</p> </li> <li> <p><strong>Handling Large models</strong> - Even back then, the language models were too large to store in RAM of a single host. For the language specific case, TensorFlow has <em>sparse embedding layers</em> that is a primitive operation that abstracts storing and reading a tensor across different memory spaces. They are implemented with operators such as <code class="language-plaintext highlighter-rouge">gather</code>, <code class="language-plaintext highlighter-rouge">part</code> and <code class="language-plaintext highlighter-rouge">stitch</code>, and their gradients are also implemented. Along with innovations such as Project Adam, TensorFlow’s training was ultimately made efficient through community driven improvements.</p> </li> <li> <p><strong>Fault Tolerance</strong> - Since many learning algorithms do not require consistency and writing at every step is compute intensive, TensorFlow implements user-level checkpointing for fault tolerance. This design decision leaves it to the user to build their own best fault handling mechanisms. <em>I wish they had an automatic version as well</em>.</p> </li> <li> <p><strong>Synchronous replica coordination</strong> - SGD is robust to asynchrony, and TensorFlow is designed for asynchronous training. In the asynchronous case, each worker reads the current value when the step begins, applies its gradient to the different current value at the end. The synchronous cases use queues to coordinate execution, allowing multiple gradient updates together. Although the throughput is reduced, this way of training is more efficient. TensorFlow implements <em>backup workers</em> to improve the throughput of this synchronous case by 15%.</p> </li> </ul> <h2 id="implementation">Implementation</h2> <p>The core TensorFlow library is implemented in C++ for portability and performance with its implementation being open-source. It consists of</p> <ul> <li> <p>Distributed master - given a graph and a step definition, it prunes and partitions the graphs to each devices, and caches these subgraphs so that they may be reused in subsequent steps.</p> </li> <li> <p>Dataflow executor - Schedules the execution of the kernels that comprise a local subgraph - optimized for running large fine-grained graphs with low overhead.</p> </li> </ul> <p>The API can be accessed both via C++ and Python.</p> <p>The library does not provide huge gains for single-system training but has higher throughput for large models across multiple devices.</p> <h2 id="conclusion-1">Conclusion</h2> <p>When this paper was published, TensorFlow was still a work in progress. Later, the library transformed significantly with the introduction of v2, and other optimizations.</p> <h1 id="pytorch-an-imperative-style-high-performance-deep-learning-library"><a href="https://arxiv.org/abs/1912.01703" rel="external nofollow noopener" target="_blank">PyTorch: An Imperative Style, High-Performance Deep Learning Library</a></h1> <p>A product of Facebook research, PyTorch is the most popular deep-learning library. They addressed the biggest limitation in previous frameworks - usability. They targeted both performance and usability by designing an imperative-style ML framework.</p> <p>In contrast to PyTorch, the previous approaches created a static dataflow graph that represents the computation. Since the whole computation is visible ahead of time, it can be leveraged to improve performance and scalability. However, due to this, the usability is reduced and cannot be used to iteratively build experiments. PyTorch, a python library, performs immediate execution of dynamic tensor computations with automatic differentiation and GPU acceleration while maintaining comparable performance to the static libraries.</p> <h2 id="background">Background</h2> <p>There were four major trends in scientific computing that have become important for deep learning:</p> <ol> <li>Development of domain-specific languages and libraries for tensor manipulation (e.g., APL, MATLAB, NumPy made array-based productive productive)</li> <li>Automatic differentiation, making it easier to experiment with different machine learning approaches</li> <li>Shift towards open-source Python ecosystem from proprietary software. The network effects of Python contributed to its exponential growth.</li> <li>Availability of general-purpose parallel hardware like GPUs</li> </ol> <p>PyTorch builds on these trends by providing an array-based programming model accelerated by GPUs and differentiable via automatic differentiation integrated in the Python ecosystem.</p> <h2 id="design-principles">Design Principles</h2> <p>PyTorch’s design is based on four main principles:</p> <ol> <li>Be Pythonic: Integrate naturally with Python ecosystem, keep interfaces simple and consistent</li> <li>Put researchers first: Make writing models, data loaders, and optimizers easy and productive</li> <li>Provide pragmatic performance: Deliver compelling performance without sacrificing simplicity</li> <li>“Worse is better”: Prefer simple, slightly incomplete solutions over complex, comprehensive designs</li> </ol> <h2 id="usability-centric-design">Usability-centric Design</h2> <p>The approach to PyTorch starts by considering deep-learning models as just another Python program. By considering so, PyTorch maintains the imperative programming model inspired from Chainer and Dynet. Defining layers, composing models, loading data, running optimizers and parallelizing the training process can all be expressed using familiar Python syntax. It allows any new potential neural network architecture to be easily implemented with composability.</p> <p>Mainly, since PyTorch programs execute eagerly, all features of Python like print, debugging and visualization work as expected. In addition, PyTorch has -</p> <ul> <li> <p><strong>Interoperability</strong> - Integrated well with other libraries to allow bidirectional exchange of data (NumPy, Matplotlib, etc).</p> </li> <li> <p><strong>Extensibility</strong> - Supports custom differentiable functions and datasets. The abstractions take care of shuffling, batching, parallelization, and management of pinned CUDA memory to improve the throughput and performance. In general, PyTorch components are completely interchangeable!</p> </li> </ul> <h3 id="automatic-differentiation">Automatic differentiation</h3> <p>Python is a dynamic programming language that has most of the behavior defined at run-time, making it difficult to pre-calculate the differentiation. Instead, PyTorch uses operator overloading approach to build up a representation of the computed function every time it is executed. It notes the difference between forward mode and backward mode automatic differentiation and adopts the latter which is better suited for ML applications.</p> <p>Their system can differentiate through code with mutation on tensors as well. They also have a versioning system for tensors as a failsafe to track the modifications.</p> <h2 id="performance-focused-implementation">Performance-focused Implementation</h2> <p>With all these considerations to usability, the developers implemented many tricks to maintain the performance of the library. Since the models have to run on Python interpreter, which has its own limitations such as the global interpreter lock (ensures only one of any concurrent threads is running at a given time), PyTorch optimized every aspect of execution and also enabled users to add their own optimization strategies. Prior frameworks avoided these constraints by deferring the evaluation to their custom interpreters.</p> <p>Most of PyTorch is implemented C++ for high performance. The core <code class="language-plaintext highlighter-rouge">libtorch</code> library implements the tensor data structure, GPU and CPU operators, automatic differentiation system with gradient formulas for most built-in functions and basic parallel primitives. The pre-computed gradient functions allow computation of gradients of core PyTorch operators in a multithreaded evaluation evading the Python global interpreter lock. The bindings are generated using YAML meta-data files, that allowed the community to create bindings to other languages.</p> <p>PyTorch separates the control (program branches, loops) and the data flow (tensors and the operations). The Control flow handled by Python and optimized C++ code on CPU and Data flow can be executed on CPU or GPU. PyTorch is designed to run asynchronously leveraging the CUDA stream mechanism. This allows overlap of Python code execution on CPU with tensor operations on the GPU, effectively saturating GPU with large tensor operations. The main performance cover-up comes from this design.</p> <p>Since every operator needs to allocate an output tensor to hold the results, the speed of <em>dynamic memory allocators</em> needs to be optimized. CPU has efficient libraries to handle this. However, to avoid the bottleneck of <code class="language-plaintext highlighter-rouge">cudaFree</code> routine that blocks code until all previously queued work on GPU completes, PyTorch implements its custom allocator that incrementally builds up a cache of CUDA memory. It reassigns it to later allocations without CUD APIs for better interoperability allowing users to use other GPU enabled Python packages. This allocator is further optimized with memory usage patterns and its implementation is simplified with the <em>one-pool-per-stream</em> assumption.</p> <p>The <code class="language-plaintext highlighter-rouge">multiprocessing</code> library was developed to evade the global interpreter lock on Python. However, this is inefficient for large arrays, so it is extended as <code class="language-plaintext highlighter-rouge">torch.multiprocessing</code> to allow automatic movement of data to shared memory improving the performance significantly. It also transparently handles sharing of CUDA tensors to build analytical systems on top of this.</p> <p>Since users write models to consume all the memory resources, PyTorch treats memory as a scarce resource and handles it carefully. The overheads of garbage collection are too large. To solve this, PyTorch relies on a reference counting scheme to track the number of uses of each tensors, and frees the underlying memory <em>immediately</em> when this count reaches zero. This ensures immediate freeing of memory when tensors become unneeded.</p> <p>With all these optimizations, PyTorch achieves</p> <ul> <li> <p>ability to asynchronously execute dataflow on GPU with almost perfect device utilization</p> </li> <li> <p>custom memory allocator showing improved performance</p> </li> <li> <p>performance within 17% of the fastest framework across all benchmarks</p> </li> </ul> <h2 id="conclusion-2">Conclusion</h2> <p>The paper concludes by highlighting PyTorch’s success in combining usability with performance. Future work includes:</p> <ul> <li>Developing PyTorch JIT for optimized execution outside the Python interpreter</li> <li>Improving support for distributed computation</li> <li>Providing efficient primitives for data parallelism</li> <li>Developing a Pythonic library for model parallelism based on remote procedure calls</li> </ul> <p>##</p> <h1 id="deep-learning-performance-on-gpus">Deep Learning Performance on GPUs</h1> <blockquote> <p>Source: https://docs.nvidia.com/deeplearning/performance/index.html#performance-background</p> </blockquote> <p>GPUs accelerate computing by performing independent calculations in parallel. Since deep learning operations involve many such operations, they can leverage GPUs very well.</p> <p>It is useful to understand how deep learning operations are utilizing the GPU. For example, operations that are not matrix multiplies, such as activation functions and batch-normalization, often are <em>memory-bound</em>. In these cases, tweaking parameters to more efficiently use the GPU can be ineffective. In these cases, the data movement between the host and the device can limit the performance. By understanding such intricacies, we can design better code to leverage GPUs to the fullest.</p> <blockquote> <p>We shall discuss the concepts in context of NVIDIA GPUs because of the existing monopoly.</p> </blockquote> <h2 id="architecture-fundamentals">Architecture Fundamentals</h2> <p>The core paradigm of GPU is parallel compute. It has processing elements and a memory hierarchy. At a high level, GPUs consist of Streaming Multiprocessors (SMs), on-chip L2 cache, and high-bandwidth RAM.</p> <p>Each SM has its own instruction scheduler and execution pipelines. In a neural network, <em>multiply-add</em> is the most frequent operation. A typical spec sheet shows FLOPS rate of GPU operations - #SMs*SM clock rate*#FLOPs.</p> <h2 id="execution-model">Execution Model</h2> <p>GPUs execute functions in a 2-level hierarchy of threads - a given function’s threads are grouped into equally-sized <em>thread blocks</em>, and a set of thread blocks are launched to execute the function. The latency caused by dependent instructions is hidden by switching to the execution of other threads. As a result, the number of threads needed to effectively use a GPU is much higher than the number of cores or instruction pipelines.</p> <p>At runtime, each thread block is placed on an SM for execution. All the threads in the block communicate via a shared memory in the blocks and synchronize efficiently. To use the GPU to the maximum, we need to execute many SMs (since each threadblock only activates one SM). Furthermore, each SM can execute multiple threadblocks simultaneously. Therefore, we need to launch many threadblocks, a number several times higher than the number of SMs.</p> <p>These thread blocks running concurrently are termed as a <em>wave</em>. In effect, we need to launch functions that execute several waves of thread blocks to minimize the <em>tail effect</em> (towards the end of a function, only a few active thread blocks remain).</p> <h2 id="understanding-performance">Understanding performance</h2> <p>There are three factors determining performance - <strong>memory bandwidth, math bandwidth and latency</strong>. To analyze these better, let \(T_{mem}\) be the time spent in accessing memory and \(T_{math}\) is the time spent performing math operations.</p> \[\begin{align*} T_{mem} &amp;= \text{\# bytes accessed}/ \text{memory bandwidth} \\ T_{math} &amp;= \#\text{ math ops}/\text{math bandwidth} \end{align*}\] <p>If these functions can be overlapped, then the total time is approximately \(\max(T_{mem}, T_{math})\). And based on the dominance, we categorize the functions as <em>math-limited</em> and <em>memory-limited</em>. So if a function is math-limited, we have</p> \[\#\text{ops}/\#\text{bytes} &gt; BW_{math}/BW_{mem}\] <p>The left-hand side of this inequality is known as <strong>arithmetic intensity</strong>, and the right-hand side is called as <em>ops:byte</em> ratio. Based on this description, we have the following data for NVIDIA V100 GPU for FP16 data -</p> <table> <thead> <tr> <th>Operation</th> <th>Arithmetic Intensity</th> <th>Usually limited by…</th> </tr> </thead> <tbody> <tr> <td>Linear layer (4096 outputs, 1024 inputs, batch size 512)</td> <td>315 FLOPS/B</td> <td>arithmetic</td> </tr> <tr> <td>Linear layer (4096 outputs, 1024 inputs, batch size 1)</td> <td>1 FLOPS/B</td> <td>memory</td> </tr> <tr> <td>Max pooling with 3x3 window and unit stride</td> <td>2.25 FLOPS/B</td> <td>memory</td> </tr> <tr> <td>ReLU activation</td> <td>0.25 FLOPS/B</td> <td>memory</td> </tr> <tr> <td>Layer normalization</td> <td>&lt; 10 FLOPS/B</td> <td>memory</td> </tr> </tbody> </table> <p>Many common operations have low arithmetic intensities (memory-limited). <em>Note.</em> This analysis assumes that the workload is large enough to saturate the device and not be limited by latency.</p> <h2 id="operation-categories">Operation Categories</h2> <p>There are three main types of operations in a neural network</p> <ol> <li> <p>Element-wise operations - Unary/binary operations such as ReLU and element-wise addition. These layers tend to be memory-limited as they perform few operations per byte accessed.</p> </li> <li> <p>Reduction operations - Operations that produce values over a range of input tensor values, such as pooling, softmax and normalization layers. These layers usually have low arithmetic intensity (memory limited).</p> </li> <li> <p>Dot-product operations - Operations can be expressed as dot-product of two tensors, such as attention and fully-connected layers. These operations tend to be math-limited if the matrices are large. For smaller operations, these are memory limited.</p> </li> </ol> <h2 id="summary">Summary</h2> <p>The number of SMs in the GPU determines the ops:bytes ratio. To maximize the performance, ensure sufficient parallelism by oversubscribing the SMs. The most likely performance limiter is</p> <ul> <li>Latency if there is not sufficient parallelism</li> <li>Math if there is sufficient parallelism and algorithm arithmetic intensity is higher than the GPU ops:byte ratio</li> <li>Memory if there is sufficient parallelism and algorithm arithmetic intensity is lower than the GPU ops:byte ratio</li> </ul> <h1 id="matrix-multiplication">Matrix Multiplication</h1> <p>As we’ve observed previously, General Matrix Multiplications (GEMMs) is the most frequent operation in neural network layers. For the sake of the discussion, based on the conventions, let \(A \in \mathbb R^{m \times k}, B \in \mathbb R^{k \times n}\) and \(C = A \times \in \mathbb R^{m \times n}\). \(C\) would require a total of \(M*N*K\) fused multiply-adds (FMAs) (twice for the FLOPs). In general, for smaller multiplications, the operation is memory limited, and otherwise it is math-limited. As a consequence, vector products \(M = 1\) or \(N = 1\) are always memory limited and their arithmetic intensity is less than 1.</p> <h2 id="implementation-1">Implementation</h2> <p>Most of the GPUs implement matrix multiplication as a tiling operation - each thread block computes its output tile by stepping through the \(K\) dimension in tiles.</p> <p>The latest NVIDIA GPUs have Tensor Cores to maximize multiplications in tensors. The performance is better when \(M, n&lt; k\) are aligned to multiples of 16 bytes.</p> <p>To aid with the code design, NVIDIA has provided the cuBLAS library that contains its optimized GEMM implementations. The tradeoff arises between parallelism and memory reuse - Larger tiles have fewer memory I/O but reduced parallelism. This is, in particular, a concern for smaller matrices. The library contains a variety of tiling to techniques to best utilize the GPU.</p> <h2 id="dimension-quantization-effects">Dimension Quantization effects</h2> <p>A GPU function is executed by launching a number of thread blocks, each with the same number of threads. This introduces two potential effects on execution efficiency - tile and wave quantization.</p> <ul> <li> <strong>Tile Quantization</strong> - Tile quantization occurs when matrix dimensions are not divisible by the thread block tile size.</li> </ul> <p><img src="/assets/img/Machine%20Learning%20Systems/2025-01-25-23-37-44-image.png" alt=""></p> <ul> <li> <strong>Wave quantization</strong> - The total number of tiles is quantized to the number of multiprocessors on the GPU.</li> </ul> <h1 id="mi300x-vs-h100-vs-h200">MI300X vs H100 vs H200</h1> <blockquote> <p>Source: <a href="https://semianalysis.com/2024/12/22/mi300x-vs-h100-vs-h200-benchmark-part-1-training/" rel="external nofollow noopener" target="_blank">MI300X vs H100 vs H200 Benchmark Part 1: Training; CUDA Moat Still Alive; SemiAnalysis</a></p> </blockquote> <p>A case-study to examine why numbers on paper do not translate to real-life performance.</p> <p><img src="https://i0.wp.com/semianalysis.com/wp-content/uploads/2024/12/10-H100-vs-H200-vs-MI300X-Basic-Specs-initial-1.jpg?resize=2184%2C1088&amp;ssl=1" alt=""></p> <p>Comparing numbers on sheets is similar to comparing the megapixel count of cameras - the software is very important. NVIDIAs real world performance is also quite low compared to the papers. The analysis boils down to this - The potential on paper of AMD’s MI300X is not realized due to lack of AMDs software stack and testing. The gap between AMDs and NVIDIAs software is large - AMD is still catching up while NVIDIA is racing ahead. AMDs PyTorch is unfortunately broken.</p> <h2 id="matrix-multiplication-1">Matrix Multiplication</h2> <p>OpenAI provides a <code class="language-plaintext highlighter-rouge">do_bench</code> function to benchmark matrix multiplications - it provides cache clearing between runs, ways to warmup and execute the benchmark multiple times and takes the median result. The results are as follows -</p> <p><img src="https://i0.wp.com/semianalysis.com/wp-content/uploads/2024/12/71-bf16-gemm-perf-for-real-world-shapes-w-amd-images.png?resize=1489%2C1084&amp;ssl=1" alt=""></p> <p>Notice how the marketed value is much higher than the real-world performance! The main finding from this study is that AMDs software stack is riddled with bugs that lowered its performance quite a lot.</p> <p>It is also important to ensure that the underlying benchmark has no issues. For example, a popular benchmark for GEMM showed comparable performance for AMD and NVIDIA. However, on closer look, it had issues - it did not clear out L2 Cache and displayed the max performance rather than mean/median.</p> <h2 id="hbm-memory-bandwidth-performance">HBM Memory Bandwidth Performance</h2> <p>Higher HBM bandwidth leads to better inference performance. It is also helpful during training, specially with higher batch sizes.</p> <p><img src="https://i0.wp.com/semianalysis.com/wp-content/uploads/2024/12/115-HBM-Copy-Bandwidth-Chart.png?resize=1485%2C1047&amp;ssl=1" alt=""></p> <h2 id="training-large-language-models">Training Large Language Models</h2> <p>MLPerf GPT3 175B training is a good metric to measure the time it takes to train a model. However, this benchmark turned out to be very difficult for the AMD GPUs. Instead, the authors designed a benchmark better representing a user workload. They noted that many AI practitioners do not use Megatron, NeMo and 3D parallelism (advances in modern networks architectures for faster inference) due to their rigidity and complexity.</p> <p>Overall for this test, on a single node, the authors obtained the following results -</p> <p><img src="https://i0.wp.com/semianalysis.com/wp-content/uploads/2024/12/121-bf16-single-node-8gpu-training-perf-with-new-AMD-images.png?resize=1491%2C1180&amp;ssl=1" alt=""></p> <p>The public releases of NVIDIA perform much higher than AMDs bugs-resolved builds. Apart from these single node builds, these providers also have a server cluster availability. NVIDIAs GPUs are merged with the NVLink fabric whereas AMD has xGMI. They connect up to 8GPUs with up to 450GB/s of bandwidth per GPU. This network of GPUs synchronize via the map-reduce command, and NVIDIAs topology performs better than that of AMDs.</p> <p>Ironically, AMDs RCCI team has only 32 GPUs to experiment with the algorithms. Looking at this dismal conditions, TensorWave and SemiAnalysis sponsored some clusters to the team to aid the team in fixing their software.</p> <h2 id="conclusion-3">Conclusion</h2> <p>Due to poor internal testing and a lack of good testing suite internally at AMD, MI300 is not usable out of the box. There have been advanced in attention mechanisms such as the <strong>FlexAttention</strong> that can improve the speed of window attention by 10-20x. However, due to the lacking nature of AMDs software, they are 6 months behind NVIDIA which is a long time in the rapid AI age.</p> <p>In fact, many of AMDs libraries are forked off NVIDIA’s open-source libraries! The authors suggest AMD should hire more software talent to reduce the gap and reshape their user interface.</p> <h1 id="tvm-end-to-end-compiler-for-deep-learning"><a href="https://arxiv.org/pdf/1802.04799" rel="external nofollow noopener" target="_blank">TVM: End-to-end compiler for Deep Learning</a></h1> <p>Current ML frameworks require significant manual effort to deploy on different hardware. TVM exposes the graph-level and operator-level optimizations to provide performance portability. In the current frameworks, techniques such as computational graph representations, auto-differentiation and dynamic memory management have been well established. Optimizing these structures on different hardware is however often infeasible, and developers have resorted to highly engineered and vendor-specific operator libraries. These libraries require significant amount of manual tuning and cannot be ported across devices.</p> <p>How does the hardware matter? The input to hardware instructions are multi-dimensional, with fixed or variable lengths; they dictate different data layout and they have special requirements for memory hierarchy. These different constraints (memory access, threading pattern, hardware primitives - loop tiles and ordering, caching, unrolling) form a large search space that needs to be optimized to get efficient implementation.</p> <p>TVM, an end-to-end ML compiler, has been designed to take a high-level specification of a deep-learning program from existing frameworks and generate a low-level optimized code for a diverse set of hardware backends. To do so, they made the following contributions</p> <ul> <li> <p>A <em>tensor expression language</em> to build operators and provide program transformation primitives to generate equivalent programs</p> </li> <li> <p>An <em>automated program optimization framework</em> to find optimized tensor operators based on an ML cost model that adapts and improves based on the data received from the hardware backend.</p> </li> <li> <p>A <em>graph-rewriter</em> compiler together the high-level and operator-level optimizations.</p> </li> </ul> <p><img src="/assets/img/Machine%20Learning%20Systems/2025-02-04-17-41-07-image.png" alt=""></p> <h2 id="graph-optimization">Graph Optimization</h2> <p>As mentioned previously, DL frameworks represent the data flow with graphs. This is different from the low-level compiler intermediate representation due to the presence of large, multi-dimensional tensors. Similar to compiler graph optimization, TVM also performs similar optimizations on this graph -</p> <ol> <li> <p><strong>Operator Fusion</strong> - Fuse multiple small operations together, reducing the activation energy for executing each operator. The commonly used operators can be classified as injective (one-to-one, e.g., add), reduction (many-to-one, e.g., sum), complex-out-fusable (element-wise map based output, e.g., convolution), and opaque (cannot be fused, e.g., sort).</p> <p>These classifications help us identify operators that can be combined. For example, in general</p> <ul> <li> <p>Multiple injective operators can be fused into one another</p> </li> <li> <p>A reduction operator can be fused with the input injective operators</p> </li> <li> <p>Complex-out-fusable operators can fuse element-wise operators to its output</p> </li> </ul> <p>These fusions generate <strong>up to 1.2x to 2x speedup</strong>!</p> </li> <li> <p><strong>Constant folding</strong> - Pre-compute graph parts that can be determined statically, saving execution costs</p> </li> <li> <p><strong>Static memory planning pass</strong> - Pre-allocate memory to hold each intermediate tensor</p> </li> <li> <p><strong>Data Layout transformations</strong> - Transform internal data layouts into back-end friendly forms. For example, a DL accelerator might exploit \(4\times4\) matrix operations, requiring data to be tiled into \(4\times4\) chunks. The memory hierarchy constraints are also taken into consideration.</p> </li> </ol> <p>These optimizations is where the search-space complexity arises. With more operators being introduced on a regular basis, the number of possible fuses can grow significantly considering the increasing number of various hardware back-ends as well. Doing these optimizations manually is infeasible and we need to automate the process.</p> <h2 id="tensor-operations">Tensor Operations</h2> <p>TVM produces efficient code for each operator by generating many valid implementations for each hardware back-end and choosing an optimized implementation. This process is built on Halide’s idea of decoupling descriptions from computation rules and extends it to support new optimizations (nested parallelism, tensorization and latency hiding).</p> <h3 id="tensor-expression-and-schedule-space">Tensor Expression and Schedule Space</h3> <p>Unlike high-level computation graph representations, where the implementation of tensor operations is opaque, each operation is described in an index formula expression language. For example, matrix multiplication is written as</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="nf">var</span><span class="p">(</span><span class="sh">'</span><span class="s">m</span><span class="sh">'</span><span class="p">),</span> <span class="n">t</span><span class="p">.</span><span class="nf">var</span><span class="p">(</span><span class="sh">'</span><span class="s">n</span><span class="sh">'</span><span class="p">),</span> <span class="n">t</span><span class="p">.</span><span class="nf">var</span><span class="p">(</span><span class="sh">'</span><span class="s">h</span><span class="sh">'</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="nf">placeholder</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="sh">'</span><span class="s">A</span><span class="sh">'</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="nf">placeholder</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="sh">'</span><span class="s">B</span><span class="sh">'</span><span class="p">)</span>
<span class="n">k</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="nf">reduce_axis</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="sh">'</span><span class="s">k</span><span class="sh">'</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="nf">compute</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> 
                <span class="n">t</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">k</span><span class="p">))</span>
</code></pre></div></div> <p>Each compute operation specifies both shape and expression for output. Since the language does not specify the loop structure and other execution details, it provides the flexibility for adding hardware-aware optimizations. <em>Schedules</em> are built incrementally with basic transformations to preserve the program’s logical equivalence. To achieve high performance on many back-ends, the schedule primitives must be diverse enough to cover various hardware backends.</p> <h3 id="nested-parallelism">Nested Parallelism</h3> <p>A common paradigm based on fork-join concept, nested parallelism is present in many existing solutions. Based on memory hierarchies, solutions also consider <em>shared memory spaces</em> and <em>fetching data cooperatively</em>. TVM builds on this idea with the concept of <strong>memory scopes</strong> to the schedule space so that a compute stage can be marked as shared. These shared tasks have <em>memory synchronization barriers</em> to ensure proper read/writes.</p> <h3 id="tensorization">Tensorization</h3> <p>To ensure high arithmetic intensity, hardware developers have started implementing <em>tensor compute primitives</em> that consider the common operations and design specific hardware for their execution. They can improve the performance (similar to vectorization for SIMD architectures), but with more and more accelerators with their own variants of tensor instructions, there is a need for an extensible solution that can seamlessly integrate with all these.</p> <p>To do so, TVM extends the tensor expression language to include hardware intrinsics. Doing so decouples the schedule from specific hardware primitives. The generated schedules are broken into a sequence of micro-kernel calls which can also use the <em>tensorize</em> primitive to make use of accelerators.</p> <h3 id="explicit-memory-latency-hiding">Explicit Memory Latency Hiding</h3> <p>Latency hiding refers to the process of overlapping memory operations with computation to maximize utilization of memory and compute resources. These strategies depend on the underlying hardware -</p> <ul> <li> <p>On CPUs, memory latency hiding is achieved implicitly with simultaneous multithreading or hardware prefetching.</p> </li> <li> <p>GPUs rely on rapid context switching of many warps of threads</p> </li> <li> <p>Specialized DL accelerators such as the TPU usually favor leaner control with a decoupled access-execute (DAE) architecture and offload the problem of fine-grained synchronization to software. This is difficult to program because it requires explicit low-level synchronization. To solve this, TVM introduces a virtual threading scheduling primitive that lets programmers specify a high-level data parallel program. TVM automatically lowers the program to a single instruction stream with low-level explicit synchronization.</p> </li> </ul> <p>Empirically, they observed that peak utilization increased by 25% for ResNet with latency hiding.</p> <h2 id="automating-optimization">Automating Optimization</h2> <p>Now that we have a set of schedule primitives, TVM needs to find the optimal operator implementations for each layer of the DL model. An <em>automated schedule optimizer</em> automates optimizing the hardware parameters through a high-dimensional search space. It consists of</p> <ol> <li> <p>A schedule explorer that proposes new configurations. A <em>schedule template specification</em> API is used to let a developer define the changeable parameters in a code for a given hardware. TVM also has a <em>generic master template</em> to automatically extract possible knobs based on the tensor expression language. More the number of configurations, better optimization is possible.</p> </li> <li> <p>A machine learning cost model that predicts the performance of a given configuration. Defining a perfect cost model is difficult - we need to consider memory access patterns, data reuse, pipeline dependencies, threading patterns, etc for every hardware. So, TVM uses a statistical approach by training an ML model that keeps getting better with newer data. The model has been chosen for <em>quality</em> and <em>speed</em>. The model uses a rank objective to predict the relative order of runtime costs. The model itself is a <em>gradient tree boosting model</em> (based on XGBoost) that makes predictions based on features extracted from the loop program.</p> </li> </ol> <p>The explorer starts with random configurations, and, at each step, randomly walks to a nearby configuration. This exploration method is more efficient than random exploration.</p> <p>A <em>distributed device pool</em> scales up the running of on-hardware trials and enables fine-grained resource sharing among multiple optimization jobs.</p> <h2 id="summary-1">Summary</h2> <p>The core of TVM is implemented in C++ with approximately 50k lines of code. It achieves significantly higher performance as compared to earlier works. However, even with this extensive approach, the models can be designed carefully to achieve much better performance. For example, as seen in Flash Attention, the optimization is a result of human intellectual effort rather than a manual exploration of a partially defined search space by an automated compiler.</p> <h1 id="triton-an-intermediate-language-and-compiler-for-neural-network-computations"><a href="https://www.eecs.harvard.edu/~htk/publication/2019-mapl-tillet-kung-cox.pdf" rel="external nofollow noopener" target="_blank">Triton: An intermediate language and compiler for Neural Network computations</a></h1> <p>As with the previous motivation, Triton was developed to provide a way for users to test new models efficiently without needing to manually optimize it for the hardware. Triton is a language and a compiler centered around the concept of <em>tile</em>, statically shaped multi-dimensional sub-arrays. It is a C-based language for expressing tensor programs in terms of operations on parametric tile variables and provides novel tile-level optimization passes for compiling programs into efficient GPU code.</p> <p>Previous approaches to tackle the wide-variety of deep-learning models include <strong>Domain-Specific Languages (DSLs)</strong> based on polyhedral machinery (tenor comprehensions) and/or loop synthesis techniques (Halide, TVM, PlaidML, etc). These systems perform well for models such as depthwise-separable convolutions, but they are much slower than vendor-based libraries like cuBLAS and cuDNN. The problem with vendor based libraries is that they support only a restricted set of tensor operations.</p> <p>These issues have been addressed by the use of micro-kernels - hand-written tile-level intrinsics, but it requires significant manual labour and cannot be generalized. Compilers do not support these tile-level operators and optimizations. The prior approaches can be summarized as</p> <ol> <li> <p>Tensor level IRs - XLA, Flow to transform tensor programs into predefined LLVM-IR and CUDA-C operation templates (e.g., tensor contractions, element-wise operations, etc) using pattern matching. Triton provides more flexibility.</p> </li> <li> <p>The polyhedral model - Tensor Comprehensions (TC), Diesel to parameterize and automate the compilation of one of many DNN layers into LLVM-IR and CUDA-C programs. Triton supports non-affine tensor indices.</p> </li> <li> <p>Loop synthesizers - Halide, TVM to transform tensor computations into loop nests that can be manually optimized using user-defined schedules. Automatic inference of possible execution schedule in Triton.</p> </li> </ol> <h2 id="triton-c">Triton-C</h2> <p>A C-like language for expressing tensor programs in terms of parametric tile variables. It provides a stable interface for existing DNN trans-compilers and programmers familiar with CUDA. Here is an example of matrix multiplication</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Tile shapes are parametric and can be optimized</span>
<span class="c1">// by compilation backends</span>
<span class="k">const</span> <span class="n">tunable</span> <span class="kt">int</span> <span class="n">TM</span> <span class="o">=</span> <span class="p">{</span><span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">};</span>
<span class="k">const</span> <span class="n">tunable</span> <span class="kt">int</span> <span class="n">TN</span> <span class="o">=</span> <span class="p">{</span><span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">};</span>
<span class="k">const</span> <span class="n">tunable</span> <span class="kt">int</span> <span class="n">TK</span> <span class="o">=</span> <span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">};</span>

<span class="c1">// C = A * B.T</span>
<span class="n">kernel</span> <span class="kt">void</span> <span class="nf">matmul_nt</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">M</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 1D tile of indices</span>
    <span class="kt">int</span> <span class="n">rm</span><span class="p">[</span><span class="n">TM</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_global_range</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">rn</span><span class="p">[</span><span class="n">TN</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_global_range</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">rk</span><span class="p">[</span><span class="n">TK</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">...</span><span class="n">TK</span><span class="p">;</span>
    
    <span class="c1">// 2D tile of accumulators</span>
    <span class="kt">float</span> <span class="n">C</span><span class="p">[</span><span class="n">TM</span><span class="p">,</span> <span class="n">TN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="c1">// 2D tile of pointers</span>
    <span class="kt">float</span><span class="o">*</span> <span class="n">pa</span><span class="p">[</span><span class="n">TM</span><span class="p">,</span> <span class="n">TK</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">rm</span><span class="p">[</span><span class="o">:</span><span class="p">,</span> <span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">rk</span> <span class="o">*</span> <span class="n">M</span><span class="p">;</span>
    <span class="kt">float</span><span class="o">*</span> <span class="n">pb</span><span class="p">[</span><span class="n">TN</span><span class="p">,</span> <span class="n">TK</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">rn</span><span class="p">[</span><span class="o">:</span><span class="p">,</span> <span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">rk</span> <span class="o">*</span> <span class="n">K</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">K</span><span class="p">;</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">-=</span> <span class="n">TK</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">bool</span> <span class="n">check_k</span><span class="p">[</span><span class="n">TK</span><span class="p">]</span> <span class="o">=</span> <span class="n">rk</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span>
        <span class="n">bool</span> <span class="n">check_a</span><span class="p">[</span><span class="n">TM</span><span class="p">,</span> <span class="n">TK</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rm</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">)[</span><span class="o">:</span><span class="p">,</span> <span class="n">newaxis</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">check_k</span><span class="p">;</span>
        <span class="n">bool</span> <span class="n">check_b</span><span class="p">[</span><span class="n">TN</span><span class="p">,</span> <span class="n">TK</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rn</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">)[</span><span class="o">:</span><span class="p">,</span> <span class="n">newaxis</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">check_k</span><span class="p">;</span>
        
        <span class="c1">// Load tile operands</span>
        <span class="kt">float</span> <span class="n">A</span><span class="p">[</span><span class="n">TM</span><span class="p">,</span> <span class="n">TK</span><span class="p">]</span> <span class="o">=</span> <span class="n">check_a</span> <span class="o">?</span> <span class="o">*</span><span class="n">pa</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">B</span><span class="p">[</span><span class="n">TN</span><span class="p">,</span> <span class="n">TK</span><span class="p">]</span> <span class="o">=</span> <span class="n">check_b</span> <span class="o">?</span> <span class="o">*</span><span class="n">pb</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
        
        <span class="c1">// Accumulate</span>
        <span class="n">C</span> <span class="o">+=</span> <span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">trans</span><span class="p">(</span><span class="n">B</span><span class="p">));</span>
        
        <span class="c1">// Update pointers</span>
        <span class="n">pa</span> <span class="o">=</span> <span class="n">pa</span> <span class="o">+</span> <span class="n">TK</span> <span class="o">*</span> <span class="n">M</span><span class="p">;</span>
        <span class="n">pb</span> <span class="o">=</span> <span class="n">pb</span> <span class="o">+</span> <span class="n">TK</span> <span class="o">*</span> <span class="n">N</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// Write-back accumulators</span>
    <span class="kt">float</span><span class="o">*</span> <span class="n">pc</span><span class="p">[</span><span class="n">TM</span><span class="p">,</span> <span class="n">TN</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">rm</span><span class="p">[</span><span class="o">:</span><span class="p">,</span> <span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">rn</span> <span class="o">*</span> <span class="n">M</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">check_c</span><span class="p">[</span><span class="n">TM</span><span class="p">,</span> <span class="n">TN</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rm</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">)[</span><span class="o">:</span><span class="p">,</span> <span class="n">newaxis</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rn</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">);</span>
    <span class="err">@</span><span class="n">check_c</span> <span class="o">*</span> <span class="n">pc</span> <span class="o">=</span> <span class="n">C</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>It is a front-end to describe CUDA like syntax with Numpy like semantics. The syntax is based on ANSI C, and has the following changes</p> <ul> <li> <p>Tile declarations: Syntax for multi-dimensional arrays that can be made parametric with <code class="language-plaintext highlighter-rouge">tunable</code> keyword. Ranges with ellipses.</p> </li> <li> <p>Broadcasting using <code class="language-plaintext highlighter-rouge">newaxis</code> keyword</p> </li> <li> <p>Predicated statements in tiles with <code class="language-plaintext highlighter-rouge">@</code></p> </li> </ul> <p>A tile is an abstraction to hide details involving intra-tile memory coalescing, cache management and specialized hardware utilization.</p> <p>The triton programming model is similar to that of CUDA - each kernel corresponds to a single thread execution.</p> <h2 id="triton-ir">Triton-IR</h2> <p>An LLVM-based Intermediate Representation (IR) that provides an environment suitable for tile-level program analysis, transformation and optimization. Triton-IR programs are constructed directly from Triton-C during parsing, but automatic generation from embedded DSLs is unimplemented. Here is an example for the <code class="language-plaintext highlighter-rouge">max</code> operation</p> <pre><code class="language-C">define kernel void @relu ( float * %A , i32 %M , i32 % N ) {
prologue :
% rm = call i32 &lt;8 &gt; get_global_range (0) ;
% rn = call i32 &lt;8 &gt; get_global_range (1) ;
; broadcast shapes
%1 = reshape i32 &lt;8 , 8 &gt; % M;
% M0 = broadcast i32 &lt;8 , 8 &gt; %1;
%2 = reshape i32 &lt;8 , 8 &gt; % N;
% N0 = broadcast i32 &lt;8 , 8 &gt; %2;
; broadcast global ranges
%3 = reshape i32 &lt;8 , 1 &gt; % rm;
% rm_bc = broadcast i32 &lt;8 , 8 &gt; %3;
%4 = reshape i32 &lt;1 , 8 &gt; % rn;
% rn_bc = broadcast i32 &lt;8 , 8 &gt; %4;
; compute mask
% pm = icmp slt % rm_bc , % M0;
% pn = icmp slt % rn_bc , % N0;
% msk = and % pm , % pn;
; compute pointer
% A0 = splat float * &lt;8 , 8 &gt; % A;
%5 = getelementptr % A0 , % rm_bc ;
%6 = mul % rn_bc , % M0;
% pa = getelementptr %5 , %6;
; compute result
% a = load % pa;
% _0 = splat float &lt;8 , 8 &gt; 0;
% result = max % float %a , % _0;
; write back
store fp32 &lt;8 , 8 &gt; % pa , % result
}
</code></pre> <p>It is similar to LLVM-IR, but it includes the necessary extensions for tile-level data-flow and control-flow.</p> <p>It constructs a data-flow graph including nodes for multi-dimensional tiles and instructions made from basic blocks of code. The control-flow is handled with the use of <em>Predicated SSA</em> and \(\psi\)<em>-functions</em> (compare and merge).</p> <h2 id="triton-jit-compiler">Triton-JIT compiler</h2> <p>A Just-In-Time (JIT) compiler and code generation backend for compiling Triton-IR programs into efficient LLVM bitcode. It includes</p> <ul> <li> <p>A set of tile-level, machine-independent passes aimed at simplifying input compute kernels independently of any compilation target. It involves operations such as pre-fetching to reduce cache misses and tile-level peephole optimization that implement algebraic tricks with tensors.</p> </li> <li> <p>A set of tile-level, machine dependent passes for generating efficient GPU-ready LLVM-IR. It involves</p> <ul> <li> <p>Hierarchical Tiling - The tiles defined by the user are further broken down to the machine’s constraints.</p> </li> <li> <p>Memory coalescing - Making sure that adjacent threads simultaneously access nearby memory locations.</p> </li> <li> <p>Shared memory allocation - To improve memory reuse.</p> </li> <li> <p>Shared memory synchronization - Barriers to preserve program correctness in parallel execution.</p> </li> </ul> </li> <li> <p>An auto-tuner that optimizes any meta-parameters associated with the above passes. Traditional auto-tuners rely on hand-written templates. In contrast, Triton-JIT extracts optimization spaces from Triton-IR (hierarchical tiling parameters only - up to 3 per dimension per tile) and optimizes using an exhaustive search. <strong>This needs to be improved in the future</strong></p> </li> </ul> <h2 id="summary-2">Summary</h2> <p>Triton defeats the other prior solutions achieving performance close to DSLs. However, the authors have highlighted many areas where this framework can be improved in the future - support for tensor cores (the ones TVM talked about), implementation of quantized kernels and integration into higher-level DSLs.</p> <h1 id="deep-compression-compressing-deep-neural-networks-with-pruning-trained-quantization-and-huffman-coding"><a href="https://arxiv.org/pdf/1510.00149" rel="external nofollow noopener" target="_blank">Deep Compression: Compressing Deep Neural Networks with Pruning, Trained Quantization and Huffman Coding</a></h1> <p>Released in 2016, Deep Compression is a three stage-pipeline involving pruning, trained quantization and Huffman coding that reduce the storage of neural networks by \(35\times\) to \(49\times\) without affecting their accuracy! Here are these steps in detail</p> <ul> <li> <p><strong>Network Pruning</strong>- Leveraging the previous successes of pruning CNNs, the authors prune the network by removing all connections with weights below a certain threshold from the network. The model is retrained to learn optimized weights. This step reduces the number of parameters by almost \(10\times\) for AlexNet and \(35\times\) for VGG-16.</p> <p>For further storage savings, these weights are stored as a compressed sparse row/column. Moreover, the authors recommend storing the index different instead of absolute position, and they assign the bits very parsimoniously.</p> </li> <li> <p><strong>Trained Quantization and Weight Sharing</strong> - A quantization technique during training, that essentially shares the weights across multiple neurons. That is, the updates and computes are grouped as centroids. The compression rate with this technique is given by</p> \[r = \frac{nb}{n \log_2(k) + kb}\] <p>where \(k\) is the number of clusters, \(n\) is the number of connections in the network, and \(b\) is the number of bits used to encode these connections. The weights are not shared across layers, and the quantization is done so that the loss across all the weights is minimum. The weights centroids can be accessed through a hash function.</p> <p>The authors go into some more detail about initializing these centroids.</p> <ul> <li> <p>Forgy (Random) - Randomly chooses \(k\) observations from the dataset. These centroids tend to concentrate near the peaks of the weight distribution.</p> </li> <li> <p>Density based initialization - Starts with a uniform distribution of the centroids and then adapts to the PDF of the data distribution. The centroids still gather near the peaks but have a better spread than random initialization.</p> </li> <li> <p>Linear initialization - Most scattered initialization</p> </li> </ul> <p>Why do these matter? In many cases, the larger weights are important but they usually are fewer in number. So, the first two initializations that are centered around the distribution peaks (which are not the large values) can result in poor accuracy. So, linear initialization usually works the best. They also experimentally confirm these hypotheses.</p> </li> <li> <p><strong>Huffman Coding</strong> - Huffman encoding is the optimal encoding standard that relies on a common prefix code for lossless data compression. The intuition is that more common symbols are represented with fewer bits. The authors of this paper use this idea to encode the sparse matrix formed by the quantized weights. The distributions are usually bi-modal and Huffman encoding saves 20-30% in storage with these non-uniform distributions.</p> </li> </ul> <p>Overall, with all these methods combined, the pipeline saves over \(30\times\) in storage for many image models! What’s more? The accuracy is more or less the same as the original models!</p> <p>The authors analyze a bit more on how these methods work together with one another. They noticed that the accuracy of the networks starts dropping sharply after a certain threshold in each method.</p> <p><img src="/assets/img/Machine%20Learning%20Systems/2025-02-12-18-35-58-image.png" alt=""></p> <p>They also point out that quantization works well with pruned networks due to lesser number of parameters to quantize. In fact, they notice that pruning virtually does not affect the performance obtained after quantization. Basically, with more savings, you get the same performance.</p> <p>The target of this paper is to allow models to work on edge devices. They perform experiments on latency, especially with the fully connected layers since they occupy 90% of the parameters in the networks. One must note that benchmarking quantized models is difficult since there are no hardware primitives to support the lookup architecture for centroid codes. They have the following observations</p> <ol> <li> <p>Matrix vector multiplications are more memory-bound than matrix matrix multiplications, and so reducing the memory-footprint for non-batched inferences is important.</p> </li> <li> <p>Pruned networks had \(3\times\) speed-up since larger matrices are able to fit into the caches.</p> </li> <li> <p>They also note that the effect of the quantization codebook is negligible as compared to the other operations.</p> </li> </ol> <p>In the future, they emphasize that to take full-advantage of the method, hardware must support indirect matrix entry lookup and the relative indices in CSC and CSR formats. This can be achieved via custom software kernels or hardware primitives.</p> <h1 id="a-survey-of-quantization-methods-for-efficient-neural-network-inference"><a href="https://arxiv.org/abs/2103.13630" rel="external nofollow noopener" target="_blank">A survey of Quantization methods for Efficient Neural Network Inference</a></h1> <p>The research and development of efficient ML has been a constant interest alongside developing new ML architectures. The earlier works in this space include:</p> <ul> <li> <p>Optimizing the micro-architecture (such as depth-wise convolution, low-rank factorization) and macro-architecture (residual connections, inception). These methods have been a result of manual search that is not scalable. A new line of work called AutoML and Neural Architectural Search methods was developed to automate the search of the right ML architecture under the given constraints of model size. Another line of work in ML compilers tried to optimize a particular architecture for a specific hardware.</p> </li> <li> <p><strong>Pruning</strong> the models by removing the neurons with small saliency (sensitivity - that do not affect the result of the network largely). These methods can be categorized as</p> <ul> <li> <p>Unstructured - Removes neurons with smaller saliency wherever they occur - this tends to be aggressive while having little impact to performance. However, this approach leads to sparse matrix operations that are harder to accelerate and are memory bound.</p> </li> <li> <p>Structured - A group of parameters (e.g., entire convolutional filter) is removed so that the operations are still on dense matrices.</p> </li> </ul> </li> <li> <p><strong>Knowledge distillation</strong> refers to training large models and using it as a teacher to train a compact model. The idea is to use the soft-probabilities generated by the teacher to better train a small model, resulting in high compression. This class of methods can significantly reduce the model size with little to no performance degradation.</p> </li> <li> <p><strong>Quantization</strong> has showed consistent success for both training and inference of Neural Networks. It allowed breakthroughs such as half-precision and mixed prevision training to have a high throughput in AI accelerators.</p> <p>Quantization is loosely related to some works in neuroscience which suggest that information stored in continuous form will inevitably get corrupted by noise. However, discrete signal representations can be more robust.</p> </li> </ul> <p>Quantization is mainly useful for deploying models on edge devices. Quantization, combined with efficient low-precision logic and dedicated deep learning processors can really push edge processors.</p> <h2 id="history-of-quantization">History of Quantization</h2> <p>Quantization maps input values in a large (often continuous) set to output values in a small (often finite) set. The effect of quantization and its use in coding theory was formalized with the seminal paper by Shannon in 1948. It evolved into different concepts such as Pulse Code Modulation in signal processing.</p> <p>In digital systems, numerical optimization methods showed that having quantization effects produces roundoff errors in applications that we know to have closed form solutions. These realizations led to a shift towards approximation algorithms.</p> <p>Neural Network (NN) quantization is different from these earlier considerations. Since inference and training of NNs is expensive and NNs are typically over-parameterized, there is a huge opportunity to reduce the precision without impacting accuracy. The nature of NNs allows high error/distance between quantized and non-quantized models. Also, the layered nature of NNs allows exploration of more types of quantizing techniques.</p> <p>There are two kinds of quantization</p> <ol> <li> <p><strong>Uniform quantization</strong> - \(Q(r) = Int(r/S) - Z\) where \(Q\) is the quantization operator, \(r\) is a real valued input (activations and weights), \(S\) is a real-valued scaling factor and \(Z\) is an integer zero-point. The resulting quantized values are uniformly spaced. An important factor is the choice of the scaling factor \(S\). It is determined by the clipping range that can be determined from calibration. Based on the clipping range, symmetric quantization results in easier implementation since it results in \(Z = 0\). These calibration ranges can be computed dynamically for every activation map or done statically during inference.</p> </li> <li> <p><strong>Non-uniform quantization</strong> - Essentially, the quantized values are not necessarily uniformly spaced. It typically achieves higher accuracy for cases involving non-uniform distributions. Neural networks usually have bell-shaped distributions with long tails. These methods can be generally considered as optimizing the difference between the original tensor and quantized counterpart. The quantizer itself can also be jointly trained with the model parameters.</p> <p>These prior approaches can be classified as rule-based and optimization-based quantizations. In addition, there can be clustering based quantizations such as K-means to minimize the performance loss.</p> </li> </ol> <p>The granularity of quantization is also an important choice -</p> <ol> <li> <p>Layerwise quantization - The clipping range is determined by considering all the weights in convolutional filters of a layer.</p> </li> <li> <p>Groupwise quantization - The clipping range is determined by grouping multiple channels inside a layer to account for cases where the distribution of the parameters across a single convolution/activation varies a lot.</p> </li> <li> <p>Channelwise quantization - Each channel is assigned a dedicated scaling factor.</p> </li> <li> <p>Sub-channelwise quantization - Each channel is partitioned into groups that have their own scaling factor.</p> </li> </ol> <p>These quantization methods can also be applied during training and after training</p> <ol> <li> <p><strong>Quantization-aware training (QAT)</strong> - The NN is re-trained with quantized parameters to improve the accuracy that degrades due to the perturbations caused by quantization. In one such method, the forward and backward passes are performed on the quantized model in floating point and then quantized after each gradient update. The back-propagation through a quantization operator is approximated via <em>Straight-Through Estimator (STE)</em> that ignores the rounding operation and approximates with an identity operation. It often works well in practice except for binary quantization. Other approaches include combinatorial optimization, target propagation or Gumbel-softmax. There has been a lot of work with regards to this aspect of quantization.</p> <p>The other kind of approaches tried learning quantization parameters during the training. These are recent works and there is not much to summarize here. In summary QAT methods require retraining efforts which may not be worth it for short-lived models.</p> </li> <li> <p><strong>Post-training quantization (PTQ)</strong> - In contrast to QAT, the overhead is very low, does not require retraining, and it can be applied in situations where data is limited or unlabeled. However, it comes at a cost of lower accuracy. To prevent this, many approaches were proposed - bias correction methods for post-quantization ranges, analytically optimizing the clipping ranges, L2 distance optimization, outlier channel splitting, adaptive rounding methods, etc.</p> </li> <li> <p><strong>Zero-shot quantization</strong> - In cases where the original data is not available to find the clipping range, zero shot quantization is used. It can again be classified into two levels based on if the approach has fine-tuning after quantization. Some approaches try to generate synthetic data to mimic the real data (earlier approaches included GANs for this) and calibrate the clipping ranges. In summary, these methods are useful for Machine Learning as a Service providers where security and privacy are a concern.</p> </li> </ol> <p>Finally, there is a notion of stochastic quantization wherein the floating numbers are mapped up or down with a probability associated to the magnitude of the weight update. Phew, that finishes the background.</p> <h2 id="quantization-below-8-bits">Quantization below 8 bits</h2> <ul> <li> <p><strong>Simulated and Integer-only Quantization</strong> - Simulated quantization refers to storing parameters as lower precision but carrying out calculations as floating point. This method can lead to higher stability while training and better inference performance, but results in mixed representation calculations. It is useful for problems that are bandwidth-bound rather than compute-bound such as in recommendation systems. The latter method which uses only a single format can exploit some hardware optimizations and be more energy efficient.</p> </li> <li> <p><strong>Mixed-Precision Quantization</strong> - In this method, each layer is quantized with different bit precision to improve the accuracy. Searching the mixed-precisions for the layers is essentially a search problem. Researchers have tried RL abased exploration methods or using a neural network to achieve this, but these can be computationally intensive with their performance being sensitive to hyperparameters and initialization.</p> <p>Another class of mixed-precision methods uses periodic function regularization by automatically distinguishing different layers and their importance wrt accuracy to learn their bandwidths. Some approaches also proposed a linear programming formulation for this approach. With hardware supporting these types of methods, it can be a feasible option for many cases.</p> </li> <li> <p><strong>Hardware Aware Quantization</strong> - Essentially considering hardware factors such as on-chip memory, bandwidth and cache hierarchy to choose the quantization parameters. Again, it is a search problem.</p> </li> <li> <p><strong>Distillation-Assisted Quantization</strong> - Some approaches tried to use model distillation to boost quantization accuracy. This method has to be studied separately since it was not covered in the survey.</p> </li> <li> <p><strong>Extreme Quantization</strong> - Binarization. Many researchers have been bold enough to try this. Important works include</p> <ul> <li> <p>Binary Connect - Weights are +1 or - 1</p> </li> <li> <p>Binarized NN - Binarizes both activations and weights. Has improved latency due to matrix multiplications being replaced by XNORs and bit-counting.</p> </li> <li> <p>XNOR-Net - Same as before but the weights have a scaling factor. Further works noted that weights tend to be close to 0, and adopted a ternarization (yes, that’s a word).</p> </li> </ul> <p>Nevertheless, these result in significant performance degradation. The works in this field can be classified as Quantization error minimization, Improved loss function formulations, and improved training methods. People tried to do this with BERT and GPT models as well!</p> </li> <li> <p><strong>Vector Quantization</strong> - Borrowing ideas from signal processing, these approaches include clustering weights or methods such as product quantization that subgroups the vectors.</p> </li> </ul> <h2 id="future-directions-summary-and-conclusion">Future Directions, Summary and Conclusion</h2> <ol> <li> <p>Quantization should be provided as a plug-and-play module in software packages to improve the accessibility.</p> </li> <li> <p>Hardware and Neural networks should be co-designed to optimize the computations.</p> </li> <li> <p>As mentioned in the previous article, coupling compression methods can have a huge impact!</p> </li> </ol> <h1 id="distributed-training-and-efficient-finetuning">Distributed Training and Efficient Finetuning</h1> <p>The growth of machine learning is much faster than what hardware can catch up with. We cannot fit our models in a single GPU anymore, and we need to learn how to use distributed training systems to satisfy our training needs.</p> <p>Typically, we deal with large model sizes (10B+) and large dataset sizes (1T+ tokens while pre-training, 1M+ in supervised fine-tuning). The goal is to maximize <em>throughput</em> by using smart distributed training strategies, where each GPU worker only deals with the fraction od training state and date. The main strategies used for this are -</p> <ol> <li> <p><strong>Data Parallelism</strong> (DP) - Each GPU worker gets a fraction of the total mini-batch of data, and computes the gradients on that data. these are then averaged across the workers to update the weights. In the most basic form, each worker has a copy of model weights, optimizer state and gradients for the fraction of the data it’s working on</p> </li> <li> <p><strong>Model Parallelism</strong> (MP, Vertical) - Models are <em>vertically sliced</em> with different layers placed on different GPUs. In the naïve form, the GPUs wait for the previous GPU to finish the computation. To improve this, people use <strong>pipeline parallelism</strong> where the execution is pipelined across micro-batches.</p> </li> <li> <p><strong>Tensor Parallelism</strong> (TP) - Each GPU processes only a slice of a tensor by <em>horizontally slicing</em> the model across GPU workers. Each worker process the same batch of data but for different activations. They exchange parts when needed.</p> </li> </ol> <p>These are the core strategies but there can be hybrid approaches based on the needs.</p> <h2 id="zero-powered-data-parallelism">ZeRO-powered Data Parallelism</h2> <p><a href="[[1910.02054]%20ZeRO:%20Memory%20Optimizations%20Toward%20Training%20Trillion%20Parameter%20Models](https://arxiv.org/abs/1910.02054)">DeepSpeed’s ZeRO</a> (Zero-Redundancy) is one of the most efficient and popular strategies for distributed training. It is a data parallelization strategy that leverages memory redundancy in data-parallel training and the inter-GPU connects to improve throughput. It comprises of two components - ZeRO-DP (data parallelism) and ZeRO-R (residual memory). The team has also proposed newer architectures such as ZeRO-Offload/Infinity (offloading computation to CPU/ NVMe disk) and ZeRO++ (with flexible multi-node training and quantized weights).</p> <p>It boasts up to 64x memory reduction for a specific example across different hardware setups and model sizes!</p> <p>The base method is PyTorch DDP that has been described before. Each GPU worker has <strong>a copy</strong> of the model weights, optimizer state and gradients. To average the gradients, <strong>all-reduce</strong> step is used. All-reduce is a two-step approach - <em>reduce-scatter</em> operation to reduce different parts of the data on different processes and an <em>all-gather</em> operation to gather the reduced data on all the processes. It requires \(2\psi\) amount of communication cost for \(\psi\) number of parameters. The paper suggests three ways of doing this -</p> <ul> <li> <p><strong>ZeRO Stage 1 /</strong> \(P_{os}\) <strong>(Optimizer state partitioning)</strong> - The optimizer state is partitioned/sharded across the workers, with model weights and gradients replicated across all the workers. Previously, the all-reduce step gets the average gradient value across all the workers. Now, each worker updates the optimizer state with the Adam equations that is in it’s partition. The key savings come from using a sharded optimizer state rather than having copies. Recall that Adam optimizer uses 2x as many weight parameters as the model.</p> </li> <li> <p><strong>ZeRO Stage 2 /</strong> \(P_{os + g}\) <strong>(Optimizer State + Gradient Partitioning)</strong> - As the name suggests the gradients are sharded along with the optimizer state. So each worker calculates its gradient and the gradients are averaged with reduce-scatter at the worker (instead of all-reduce).</p> </li> <li> <p><strong>ZeRO Stage 3 /</strong> \(P_{os + g}\) <strong>(Optimizer State + Gradient Partitioning)</strong> - The partitioning of the model weights is done horizontally. That is, each layer of the model is split across the GPUs and there is a parameter communication on-demand. The communication volume increases (since there is an extra all-gather for model parameters, the communication becomes 3x the number of parameters). As a consequence, the memory consumption is cut down by the number of GPU workers \(N\) which is huge! So if you have enough number of GPUs, you can get good savings on the memory.</p> </li> </ul> <p>These were the base methods. The authors proposed a wide-array of variations on top of this.</p> <ol> <li> <p><strong>ZeRO-R</strong> - Improves on ZeRO-DP by reducing the memory consumptions by activations and managing memory fragmentation. It essentially shards the activations as well. it also uses some temporary buffers to store intermediate results during gradient accumulation and reduction across workers.</p> </li> <li> <p><a href="https://arxiv.org/abs/2101.06840" rel="external nofollow noopener" target="_blank"><strong>Zero-Offload</strong></a> - The idea is to offload optimizer and computation from GPUs to the host CPU. Back in 2021, this obtained magnitudes of higher performance over PyTorch DDP. CPU computation is much slower, so only the less-intensive operations are offloaded so that the total compute complexity stays the same. So, operations such as norm calculations, weight updates, etc are done on the CPU, while the forward and backward pass are done on the GPU. It works with all stages of ZeRO (1, 2 and 3).</p> </li> <li> <p><strong>Zero-Infinity</strong> - An improvement on the previous approach to allow offloading to disk and some more improvements to CPU offloading. It could fit 10-100T parameters on just one DGX-2 node! This method is specifically built on top of ZeRO-3, and they achieved 49 Tflops/GPU for a 20 trillion model spread across 512 GPUs. This is insane!</p> </li> <li> <p><a href="https://arxiv.org/abs/2306.10209" rel="external nofollow noopener" target="_blank"><strong>ZeRO++</strong></a> - The latest improvement in this saga of approaches. The major changes are quantized weights (reduces communication by half), hierarchical partitioning (a hybrid sharing technique) and quantized gradients.</p> </li> </ol> <h2 id="fully-sharded-data-parallel">Fully-Sharded Data Parallel</h2> <p>FSDP is another data-parallelism technique aimed at improving memory efficiency with limited communication overhead. It’s based on the previous approaches and has two sharding strategies - Full Sharding and Hybrid Sharding.</p> <ul> <li> <strong>Full-sharding</strong> - Similar to ZeRO-3, the parameters, optimizer state and gradient are sharded across workers.</li> </ul> <p>    The high level procedure is -</p> <blockquote> <p>In forward path</p> </blockquote> <blockquote> <ul> <li>Run all_gather to collect all shards from all ranks to recover the full parameter in this FSDP unit</li> <li>Run forward computation</li> <li>Discard parameter shards it has just collected</li> </ul> </blockquote> <blockquote> <p>In backward path</p> </blockquote> <blockquote> <ul> <li>Run all_gather to collect all shards from all ranks to recover the full parameter in this FSDP unit</li> <li>Run backward computation</li> <li>Run reduce_scatter to sync gradients</li> <li>Discard parameters</li> </ul> </blockquote> <ul> <li> <strong>Hybrid Sharding</strong> - It consists of both sharding and replication based on the tradeoff between communication latency and memory savings. This option is useful when the only way out is sharding parameters.</li> </ul> <h2 id="implementation-in-practice">Implementation in Practice</h2> <p>ZeRO and FSDP integrate well with existing architectures. ZeRO is implemented in Microsoft’s DeepSpeed library and is integrated into the 🤗 Accelerate library. FSDP is a part of PyTorch itself, and again has an integration in the 🤗 Accelerate library.</p> <p>Pipeline parallelism requires architectural changes in the forward pass of the model. For this, the best option right now is Megatron-LM that is discussed next. A recent update in 2024 pushed nanotron that has 3D parallelism support.</p> <h2 id="efficient-fine-tuning">Efficient Fine-tuning</h2> <p>Some popular optimizations -</p> <ol> <li> <p><strong>Mixed precision</strong> - It has been widely adopted form LLMs wherein there is a master copy that is updated from the gradients of quantized copies.</p> </li> <li> <p><strong>Parameter Efficient Fine Tuning (PEFT)</strong> - Various methods to reduce the finetuning effort.</p> <ol> <li> <p><a href="https://arxiv.org/abs/2106.09685" rel="external nofollow noopener" target="_blank">LoRA</a> - Low-rank version of weight updates to the model parameters. Works as well as full fine-tuning.</p> </li> <li> <p><a href="https://huggingface.co/docs/peft/conceptual_guides/ia3" rel="external nofollow noopener" target="_blank">\(IA^3\)</a> - Injects trainable vectors into key, value and feed forward layers. Is working as well as LoRA with a lower order of parameters but requires more experimentation.</p> </li> </ol> </li> <li> <p><strong>Flash-attention</strong> - It is a fast, memory efficient, exact, IO-aware attention mechanism. <a href="https://tridao.me/publications/flash2/flash2.pdf" rel="external nofollow noopener" target="_blank">FlashAttention 2</a> achieves 220+ TFLOPS on A100! FlashAttention 1 achieved 124 TFLOPs before. However, these only support Ampere, Ada and Hopper NVIDIA GPUs and half prevision data types.</p> </li> <li> <p><strong>Gradient and Activation Checkpointing</strong> - A technique wherein only a subset of intermediate activations are stored and others are recomputed when needed. However, it can slow down the training by 20% for \(O(\sqrt N)\) memory savings. <a href="https://medium.com/tensorflow/fitting-larger-networks-into-memory-583e3c758ff9" rel="external nofollow noopener" target="_blank">Check this site</a> for better info.</p> </li> <li> <p><strong>Quantization</strong> - Post-training quantization refers to savings at inference since weights don’t change. During training, there can be updates with quantized parameters. <a href="https://arxiv.org/abs/2305.14314" rel="external nofollow noopener" target="_blank">QLoRA</a> is one such technique that quantizes the base model and trains half precision low-rank weights on this. The throughput actually decreases due to the de-quantization step for each activation. Nevertheless, it can reach the performance of full fine-tuning.</p> </li> <li> <p><strong>Gradient accumulation</strong> - The intuition behind this approach is to run the network in micro-batches, accumulate the gradients across these micro-batches and update the model for a full batch-size. The idea is to get the same output as with large batches but with much lower memory consumption (the time increases accordingly). Larger batches usually have lower convergence time and the technique is especially useful when using multiple GPUs. However, one should be conservative with this approach. <a href="https://openreview.net/forum?id=H1oyRlYgg" rel="external nofollow noopener" target="_blank">A pre-transformers era paper</a> showed larger batch sizes can reduces the generalization abilities of a model.</p> </li> </ol> <h2 id="summary-3">Summary</h2> <p>The final tips for training these large models from this article are -</p> <blockquote> <ul> <li> <p>BF16/ FP16 by default. BF16 comes with basically no other config parameters and usually without any overflow issues (as opposed to FP16, where you can get different results with different loss scaling factors and have more overflow issues because of smaller dynamic range), so it’s very convenient.</p> </li> <li> <p>Use (Q)LoRA with trainable parameters added to all the linear layers.</p> </li> <li> <p>Use Flash Attention if your GPU supports it. Currently, Flash Attention 2 is supported for Llama 2 and Falcon in HuggingFace, with other models requiring monkey patches.</p> </li> <li> <p>Use Gradient/Activation Checkpointing. This will reduce throughput slightly. If you’ve got Flash attention, gradient checkpointing might not be required (they use a selective gradient checkpointing in the softmax of the attention layer).</p> </li> <li> <p>Use an efficient sampler in your dataloader, like the <a href="https://github.com/imoneoi/multipack_sampler" rel="external nofollow noopener" target="_blank">multi-pack sampler</a>.</p> </li> <li> <p>If you have multiple GPUs, always try BF16 + LoRA + Gradient Checkpointing + DeepSpeed ZeRO 3 first. <strong>Megatron stuff from the next part too</strong></p> </li> <li> <p>Use quantization when you have very limited GPU memory. QLoRA-style training currently works for DeepSpeed ZeRO 1/2 only. Thus, even though it is memory efficient when it comes to model parameters, you still have parameter redundancy with ZeRO 1/2, and you also get reduced throughput.</p> </li> <li> <p>With more and more GPUs (say 8 V100s or A100s), DS ZeRO-3 should be the way to go. DS ZeRO-2 is also good, but you can start to hit CPU RAM limits (during model initialization) because of model parameters being replicated across all workers.</p> </li> <li> <p>In a small-scale multi-node setup, with a few nodes, the best option seems to be DeepSpeed ZeRO-3 with hierarching partitioning enabled (or FSDP with hybrid sharding). If you’ve got Infiniband interconnect, you can mostly use plain DeepSpeed ZeRO-3 and push for larger model sizes as well.</p> </li> <li> <p>Gradient accumulation should be used if you’re still short on batch size after all the above optimizations. Training times with gradient accumulation can be faster with large models and multi-GPU/ multi-node settings.</p> </li> <li> <p>If you’re really short on GPU memory, then you would activate CPU/ disk offloading (and by disk, this has to be NVMe for ZeRO-Infinity). With the advent of Flash Attention 2, we need another study on the throughput gap between plain GPU-based training and GPU + NVMe/CPU-offloading. ZeRO-Infinity is better than ZeRO-Offload.</p> </li> <li> <p>Calculate the effective batch size and adjust hyperparameters accordingly. A general guideline is to scale up the learning rate with the effective batch size. This seems to hold true even for 100B+ models, <a href="https://platform.openai.com/docs/guides/legacy-fine-tuning/hyperparameters" rel="external nofollow noopener" target="_blank">as seen in OpenAI’s finetuning docs</a>.</p> </li> <li> <p>Finally, when you do start training, monitor <code class="language-plaintext highlighter-rouge">htop</code> to check on RAM usage (sometimes RAM OOM can be an issue), along with <code class="language-plaintext highlighter-rouge">nvidia-smi</code> to make sure GPUs aren’t bottlenecked by data preprocessing (you should aim for close to 100% volatile GPU utilization, even if GPU memory usage is lesser).</p> </li> <li> <p>Lower learning rate during pre-training works better in practice for GPT-3 and Bloom paper. The intuition/explanation for this effect is still pending.</p> </li> </ul> </blockquote> <h1 id="megatron-lm">Megatron-LM</h1> <p>A simple model parallel approach that is orthogonal and complementary to pipeline model parallelism. They also show that larger models do indeed result in higher performance by demonstrating larger models trained with their approach.</p> <p>Their approach exploits the inherent structure of transformer based language models that trains efficiently with PyTorch. Compared to the baseline that trains a 1.2 billion parameter model on a single NVIDIA V100 32GB GPU that sustains 39 TFLOPs (30% of the peak possible value), their method obtains 15.1 PetaFLOPs with an 8.3 billion model on 512 GPUs with 8-way parallelism - 76% scaling efficiency.</p> <p>The paper mentions the previous approaches <em>gradient accummulation</em> (Valiant, 1990) and <em>gradient/activation checkpointing</em> (Chen et. al., 2016), and that they are constrained to fit the model on a single GPU. They also mention that layer parallelism suffers from pipeline bubbles that reduce efficient or changes to the optimizer that impacts accuracy. Distributed tensor computation is a more general approach, and the authors use this technique for transformer’s attention heads to parallelize. No framework, no compiler, simple PyTorch modifications.</p> <h2 id="model-parallel-transformers">Model Parallel Transformers</h2> <p>The core idea is to parallelize the transformer architecture with some synchronization primitives.</p> <ol> <li> <p>The MLP part is a GEMM followed by a GeLU non-linearity.</p> \[\begin{align*} Y &amp;= GeLU(XA) \\ &amp;= GeLU (\begin{bmatrix} X_1 &amp; X_2\end{bmatrix}\begin{bmatrix}A_1 \\A_2\end{bmatrix}) \\ &amp; \neq GeLU(X_1A_1) + GeLU(X_2A_2) \end{align*}\] <p>The matrix \(A\) can be split across rows and \(X\) across columns. Due to the non-linearity of \(GeLU\), this method would need a synchronization point before the non-linear layer.</p> <p>The other approach is to split \(A\) across columns, and then \(GeLU\) can be applied independently. It doesn’t require any synchronization point.</p> \[\begin{align*} Y &amp;= GeLU(XA) \\ &amp;= GeLU (X \begin{bmatrix} A_1 &amp; A_2\end{bmatrix}) \\ &amp;= GeLU(XA_1) + GeLU(XA_2) \end{align*}\] <p>This approach splits both GEMMs in the MLP block across GPUs and requires a single all-reduce operation in the forward and backward passes.</p> </li> <li> <p>For the self-attention block, the partitioning of GEMMs is done in a similar column parallel fashion for \(K, Q, V\). These outputs can directly be passed into the linear layer to parallelize across rows evading communication latency here as well. The final answers after the FFN can be fused within two all-reduce operations.</p> </li> </ol> <p>Furthermore, since vocabulary sizes can be large, it is beneficial to parallelize the output embedding GEMM. However, since the output embedding layer shares weights with the input embedding, the input embedding matrix is also parallelized across the vocabulary dimension. These splits would add two all-reduce operations. However, in the output layer the all-gather operation can be optimized by fusing with the cross-entropy loss - reduces parameter communication from \(b\times s\times v\) to \(b \times s\). That is, communicating scalar losses instead of logits is a huge reduction in communication.</p> <p>The paper further reduces the communication by replicating dropouts, layer normalization, and residual connections across GPUs and only the results are communicated.</p> <blockquote> <p>Specifically, each worker maintains duplicate copies of layer normalization parameters on each GPU, and run dropout and residual connection on the output of the model parallel region before feeding them as input to the next model parallel regions. To optimize the model, each worker optimizes its own set of parameters. Since all values are either local to or duplicated on a GPU, there is no need for communicating updated parameter values in this formulation.</p> </blockquote> <h2 id="conclusion-4">Conclusion</h2> <p>The authors provide comprehensive set of results to demonstrate their method with GPT-2 and BERT, showcasing that they are able to scale the compute much higher with these simple optimizations while achieving higher accuracy with larger models. They also found that BERT like models perform better with layer normalization.</p> <h1 id="gpipe"><a href="https://arxiv.org/pdf/1811.06965" rel="external nofollow noopener" target="_blank">GPipe</a></h1> <p>GPipe is an attempt to democratize model parallelism through pipeline algorithms for layered networks. It was proposed towards the end of 2018, when transformers started getting popular and the hardware could not catch up. The high-level idea is that each model can be specified as a sequence of layers and consecutive groups of layers can be partitioned into cells that are each placed on a separate accelerator. A novel pipeline parallelism algorithm with micro-batch splitting is used to maximize the utility of the hardware.</p> <p>It was released to the public as an open-source library. The interface consists of user-selectable parameters such as estimate of the computation cost \(C_k\), number of partitions \(K\), number of micro-batches \(M\), and layers \(L\) that define the model etc.</p> <p>GPipe is a synchronous pipeline based parallelism technique. There are other approaches that split the operators across the accelerators (GPipe splits the layers), akin to SIMD approach for data parallelism. They call this the Single Program Multiple Data (<strong>SPMD</strong>) paradigm, and Mesh-Tensorflow is one method existing at that time. They note that these methods have high communication overhead and there are variety of ways of splitting the operators some of which may not be generalizable or scalable. Along similar lines, PipeDream pipelines the execution of forward passes and intersperses them with backward passes to maximize hardware utilization. However, it suffers from update staleness introduced by asynchronous backward updates. Some versions suggested maintaining multiple versions of the model, but that greatly hampers the scaling abilities of the technique.</p> <h2 id="algorithm">Algorithm</h2> <p>GPipe partitions the network into \(K\) sequential cells and each of them are placed on the available devices. Communication primitives are inserted at the boundaries to allow data transfer. The partitions are split so that the variance across all the cells is minimized to sync the computation time across all partitions.</p> <p>During the forward pass, every mini-batch of size \(N\) is split into \(M\) micro-batches that are pipelined through \(K\) accelerators. During the backward pass, gradients for each micro-batch are computed with the weights used for the forward pass, and these gradients are accumulated to update the model parameters across all accelerators.</p> <p>For batch-normalization layers, the statistics of inputs across micro-batches and moving averages across the mini-batch are calculated and communicated.</p> <p><img src="/assets/img/Machine%20Learning%20Systems/2025-02-25-22-13-11-image.png" alt=""></p> <p>To further decrease the memory consumption, GPipe supports gradient checkpointing - each accelerator only stores the output activates at the partition boundaries. As a result, the peak activation memory is reduced to \(O(N + \frac{L N }{KM})\) from \(O(NL)\) (without gradient checkpointing and partitioning) where \(N/M\) is the micro-batch size and \(L/K\) is the number of layers per partition.</p> <p>The bubble overhead with this method is \(O(\frac{K - 1}{M + K - 1})\) amortized over the number of micro-steps \(M\). It is negligible in practice when \(M \geq 4\times K\). Note that increasing the number of micro-batches would underutilize the GPUs.</p> <p>GPipe has low communication overhead allowing efficient scaling on accelerators without high-speed interconnects. However, the memory requirements and computation flops at different layers are usually very imbalanced leading to inefficiencies. The authors left this problem of better partitioning algorithms to future works.</p> <h2 id="results-and-conclusion">Results and Conclusion</h2> <p>GPipe is able to reduce the memory requirements by half allowing training of almost 25x larger models. These savings are even more significant with architectures such as transformers where the savings can be 250 times. The speed-up is almost linear barring the pipeline bubbles and communication overheads. They obtained significant savings even with a low-speed communication device (PCI-E vs NVLink).</p> <p>These savings translate into the model performance as well. Giant networks can improve the accuracy, also allowing models to be trained on larger datasets. The authors tests this hypothesis with image classification and machine translation tasks. This work opened new avenues to analyze model architectures such as studying depth-width trade-offs in transformers (the deeper model outperforms by huge margins on low-resource languages, suggesting that it may be better for generalization).</p> <p>They also tested higher batch sizes that were not possible previously, and they observed that larger batch sizes improved the performance!</p> <p>GPipe assumes that a single layer fits within the memory requirements of a single accelerator and some layers (such as batch norm) require complicated computations and communications across accelerators which have been solved by future works.</p> <h1 id="alpa---automated-parallelism"><a href="https://arxiv.org/pdf/2201.12023" rel="external nofollow noopener" target="_blank">Alpa - Automated Parallelism</a></h1> <p>A given model can be parallelized in many ways. There are intra-operation and inter-operation splitting mechanisms that need to be considered based on the model architecture and the underlying hardware. These choices are interdependent, and it is difficult to consider all the variations to manually find the best way to parallelize every time.</p> <p>Alpa automates model-parallel training of deep-learning models by generating execution plans that unify data, operation and pipeline parallelism! They observed that all the parallelization techniques can be organized in a hierarchical space and be mapped to the hierarchical structure of the compute cluster. Different parallelization techniques have different bandwidth requirements for communication. On this note, they consider two types of parallelization</p> <ol> <li> <p><strong>Intra-operator parallelism</strong> - Partition ML operators along one or more tensor axes (batch or non-batch) and dispatch the partitions across the devices. Note that it involves data parallelism as well.</p> <p>Intra-operator parallelism has better device utilization, but results in communicating at every split and merge of partitioned operators in each training iteration.</p> </li> <li> <p><strong>Inter-operator parallelism</strong> - Slice the model into disjoint stages and pipeline the execution of stages on different devices.</p> <p>Inter-operator parallelism only requires communication between adjacent stages which can be light if sliced efficiently. However, it results in device idle time due to pipeline bubbles as we discussed before.</p> </li> </ol> <p><img src="/assets/img/Machine%20Learning%20Systems/2025-02-25-23-05-39-image.png" alt=""></p> <p>Parallel to these tradeoffs, the communication bandwidth on the device cluster also has an asymmetric nature. The intra-operator parallelism can use the high communication bandwidth, while the inter-operator parallelism is handled between distance devices with relatively lower bandwidth. The joint execution plan may not be globally optimal, it obtains high performance across different large models.</p> <p>Alpa essentially is a compiler for parallel execution plans that partitions the cluster into device meshes based on the bandwidth hierarchy and performs inter-operator and intra-operator splitting.</p> <h2 id="background-1">Background</h2> <p>As mentioned previously, the authors consider a new view of ML parallelism that differs from the conventional views. Previously, the parallelism was one of the following types</p> <ol> <li> <p>Data parallelism - Data is distributed, but the model is replicated. The parameter updates are synchronized before the next iteration.</p> </li> <li> <p>Operator parallelism - When the models are too large to fit in a device, the operators involved are split across the non-batch axes and the computations are performed in parallel across devices. This method usually requires large amount of communication across devices. When the tensors are partitioned evenly, i.e., SPMD, all devices follow the same communication patterns.</p> </li> <li> <p>Pipeline parallelism - The model is split into stages which are placed on different workers. The training batch is split into microbatches for overlapped iterations of forward and backward passes across workers.</p> </li> <li> <p>Hybrid parallelism - Researchers manually combined the above techniques to obtain much higher performance. One notable work is the Megatron-LM that optimizes the parallelization for transformer models (3D Parallelism).</p> </li> <li> <p>Automatic combination of parallelism - Prior to this work, auto-parallelization was limited to combining data parallelism with at most one model parallelism approach missing improvement opportunities.</p> </li> </ol> <p>In contrast to this view, the authors consider inter-op and intra-op parallelisms as described before. With such a view, techniques such as Megatron-LM, ZeRO (that involves updates sharding) can be viewed as intra-op parallelism. On the other hand, techniques such as GPipe, 1F1B and PipeDream are all pipeline optimizations that come under inter-op parallelism. The authors of this paper adopt synchronous 1F1B for pipeline parallelism.</p> <h2 id="method-overview">Method Overview</h2> <p>As mentioned previously, Alpa considers two-level planning</p> <ol> <li> <p>At the intra-op level, minimize the cost of executing a stage of the computational graph on a given device mesh (that have high bandwidth between each other)</p> </li> <li> <p>At the inter-op level, minimize the inter-op parallelization latency with respect to slicing the model and mapping the stage-mesh pairs. The inter-op optimization depends on knowing the execution cost of each stage-mesh pair reported by the intra-op optimizer.</p> </li> </ol> <p>Alpa does this by generating an intermediate representation similar to Jax which is used by the optimization steps.</p> <p>A device mesh is a 2-dimensional logical view of a set of physical devices (all having same compute capability) which communicate with different bandwidths in each dimension. We will delve deeper into the two stages below.</p> <h2 id="intra-operator-parallelism">Intra-operator Parallelism</h2> <p>Alpa adopts the SPMD-style intra-op parallelism that partitions operators evenly across devices and executes the same instructions on all devices assuming that the devices in the mesh have equivalent compute capability. This decision greatly reduces the search space and unifies approaches such as data parallelism, ZeRO and Megatron LM. Alpa formalizes the problem as an integer linear programming problem.</p> <p>The goal of intra-op pass is to pick one parallel algorithm for every operator to minimize the execution time of the entire graph. The authors use a <strong>sharding spec</strong> to define the layout of a tensor - each dimension of a tensor is <em>S</em> (sharded) or <em>R</em> (replicated). The partitioned tensor axes must be mapped to mesh axes.</p> <p>Through this, we can succinctly represent different ways of partitioning a matmul.</p> <p><img src="/assets/img/Machine%20Learning%20Systems/2025-02-25-23-31-35-image.png" alt=""></p> <p>The model graph is represented in XLA’s HLO format, that summarizes common DL operators into less than 80 primitive operators whose parallel algorithms can be manually enumerated.</p> <p>The ILP then considers the node and edge communication costs which can be solved by an off-the-shelf solver.</p> <p>The equation is given by</p> \[\min_s \sum_{v \in V} s^T_v (c_v + d_v) + \sum_{(v, u) \in E} s^T_v R_{vu} s_u\] <p>Although these different costs can be obtained by profiling, the authors suggest heuristic calculations to prevent executing multiple operators on the cluster wasting resources. There can be post-ILP optimizations similar to the ones in ZeRO to further improve the efficiency.</p> <h2 id="inter-op-parallelism">Inter-op Parallelism</h2> <p>Previous works consider a simplified problem where the device for each stage is pre-assigned and all stages have fixed data or operator parallelism plan. Alpa jointly optimizes everything considering a much general scenario.</p> <p>The computational graph is split based on the topology order, and each stage has its own intra-op cost obtained from the intra-op pass. The cost is minimized considering the micro-batches inn the pipeline. The latency is given by</p> \[T^* = \min_{s_1, \dots, s_S} \left\{ \sum_{i = 1}^S t_i + (B - 1) \cdot \max_{1 \leq j \leq S} \{t_j\}\right\}\] <p>The first term is the total latency of all stages, interpreted as the latency of the first micro-batch groin through the pipeline; the second term is the pipelined execution time for the rest of the micro-batches which is bounded by the slowest stage in the 1F1B pipeline.</p> <p>Additionally, for an operator in the forward pass of the graph, the corresponding backward operator should be in the same submesh - the backward propagation usually uses the similar set of tensors during the forward pass, reducing the communication.</p> <p>The authors formulate this as a DP formulation, cleverly considering primitive sub-mesh sizes to reduce the search-space significantly! These were the high level ideas, and there are considerations for cases where the operators do not fit into one device, etc. They introduce further techniques to prune the search space</p> <ol> <li> <p>Early pruning - Get rid of states that have higher cost than the current best</p> </li> <li> <p>Operator clustering - Element-wise operators can be merged without much change in the cost. Greatly reduces the search space.</p> </li> </ol> <h2 id="parallelism-orchestration">Parallelism Orchestration</h2> <p>Once the optimal assignment is found, XLA and GSPMD are used to generate parallel executables. Alpa implements additional parallelism orchestration pass to address cross-mesh communications. They introduce cross-mesh resharding for different sharding specs - P2P send/recv primitives.</p> <h1 id="language-models-are-few-shot-learners">Language Models are Few-Shot Learners</h1> <p>The paper from OpenAI that started it all. The after-effects of this work are still rapidly progressing. Let’s dive in.</p> <p>The focus in NLP shifted from specialized models to task-agnostic systems for downstream applications. What started out as single layer representations, got converted to RNNs with multiple layers of representations and contextual states for stronger representations, and finally in the form of a transformer language model that seem to have amazing generalizing capabilities.</p> <p>When this paper was proposed, people were still training these models on labeled datasets, and with the unavailability of large scale general datasets outside task-specific ones, developing a large generalizable model was a challenge. Furthermore, the narrowness of the datasets can also inhibit the capabilities of the model. The authors of this paper argue that humans do not require such large scale datasets to perform these general capabilities, and quickly learn from only a few demonstrations. To counter these limitations, the previous works experimented with meta-learning and scaling the size of the language models. The authors note the smooth trend in improvement with scale, and they double down on this hypothesis.</p> <p>The largest model trained prior to this had 17B parameters. In this paper, the authors trained a 175B parameter model!</p> <h2 id="approach-model-and-dataset">Approach, Model and Dataset</h2> <p>The pre-training of GPT follows a similar procedure to previous models at a larger scale. With this paper, they introduce new paradigms to evaluate/tune the model for in-context learning</p> <ol> <li> <p>Fine-tuning - Curating datasets for specific tasks for better performance. The authors mention that they don’t use this paradigm with GPT-3 to test it’s generalizing capabilities.</p> </li> <li> <p>Few-Shot - Model is given a few input demonstrations as part of the prompt to adapt to a new task</p> </li> <li> <p>One-shot - Same as above, but only one example if provided</p> </li> <li> <p>Zero-shot - Testing the capabilities of the model for new tasks without providing any new demonstrations</p> </li> </ol> <p>The model architecture is same as GPT-2 that uses alternating dense and locally banded sparse attention patterns similar to Sparse Transformer.</p> <p>Many datasets for language models rapidly expanded and culminated into the Common Crawl dataset consisting of nearly a trillion words. The authors improved the dataset by</p> <ol> <li> <p>Filtering based on similarly to a range of high-quality reference corpora</p> </li> <li> <p>Fuzzy deduplication at the document level to prevent redundancy and preserve the integrity of the validation set</p> </li> <li> <p>Addition of high-quality reference corpora into the training mix</p> </li> </ol> <p>One concern people have with large datasets is the memorization of downstream test tasks. To reduce this effect, the authors tried to remove all benchmark test instances from the training set. They mention that due to a bug they did not do this perfectly, and there was contamination in some cases.</p> <h2 id="training-and-evaluation-details">Training and Evaluation Details</h2> <p>Previous works showed that larger datasets perform better with larger batch sizes and a smaller learning rate. The authors use a gradient noise scale during training to guide the choice of the batch size. They use model parallelism (both intra-op and inter-op) to reduce the peak memory usage. All models were trained on V100 GPUs from Microsoft.</p> <p><img src="/assets/img/Machine%20Learning%20Systems/2025-03-04-16-31-21-image.png" alt=""></p> <p>With this experiment, a strong paradigm in this field of research has been established - <strong>scaling both compute and model size has a power-law effect on the performance</strong>.</p> <p>The authors test GPT-3 on multiple benchmarks carefully omitting cases that were a subset of the training dataset. They see that the few-shot setting achieves significantly higher performance that both one-shot and zero-shot. One-shot also shows improved performance with this model. in many cases, GPT-3 beat the SOTA model performance in multiple benchmarks. They test on generation, evaluation, reasoning and many other genres of tasks.</p> <h2 id="limitations">Limitations</h2> <p>The authors noticed that GPT-3 tends to repeat itself and in some cases the few-shot does not perform much better than one-shot inference. In a more architectural sense, they note that GPT-3 does not specifically cater to tasks with bidirectional language flow requirements. They also mention that large models such as these reach the limits of their pre-training objective that itself does not place importance on some task-specific needs. That is, more useful language systems may be better due to goal-directed actions rather than just making predictions. Furthermore, language models are not grounded in other forms of information such as video and audio.</p> <p>Compared to humans, GPT-3 has much lower sample efficiency (it does meh with much much more samples seen during pre-training). Finally, both training and inference on such large models is very expensive and inconvenient. This has been changing in the recent times due to the advancements in RLHF and distillation techniques.</p> <p>The authors also mention the broader impact of this paper, and warn the readers about the potential misuses of language models. The biases in the training datasets like certain stereotypes can propagate into the model and also about the energy due to the rise in this domain.</p> <h1 id="training-compute-optimal-large-language-models">Training Compute-optimal Large Language Models</h1> <p>The paper tries to answer an important dilemma in training language models - is it better to train bigger models that are potentially undertrained or train smaller models on more data? The authors noted the trends in model and tried to derive an empirical law for the trends observed. They note that the budget for model training is known apriori, and the training can only be done once, estimating the best hyperparameters is critical.</p> <p>So, the question we are concerned with is - Given a fixed FLOPs budget, how should one trade-off model size and the number of training tokens?</p> <p>There have been some previous works around this. A 10x increase in the computational budget should increase 5.5x while the number of training tokens should only increase 1.8x. However, the authors note that the previous works did not consider the variations in tokens, learning rate schedule and other hyper-parameters to better model the behaviors.</p> <p><strong>Note.</strong> This work is mainly for dense transformer architectures. They mention that there are orthogonal works like RAG and MoE that improve the models, but the motivation for this paper is to understand the behavior of dense transformers.</p> <h2 id="approach">Approach</h2> <p>In the first method, the authors tried to vary the number of training steps for a fixed family of models. They obtained the minimum loss achieved for a given number of training FLOPs. Using the interpolants, they obtain a mapping from any FLOP count C to most efficient model size N and training tokens D. They obtain the relationship \(N_{opt} \propto C^{0.5}\) and \(D_{opt} \propto C^{0.5}\) contradicting previous results.</p> <p>In their second approach, they vary the model size for a fixed set of training FLOP counts and consider the final training loss for each point. It essentially answers the question for a given FLOP budget, what is the optimal parameter count. These are the IsoFLOPs experiments, and they obtain \(N_{opt} \propto C^{0.49}\) and \(D_{opt} \propto C^{0.51}\).</p> <p>In the final approach, they modeled all the final losses considering the previous experiments, and considering a classical <strong>risk decomposition</strong>, they propose</p> \[\hat L(N, D) = E + \frac{A}{N^\alpha} + \frac{B}{D^\beta}\] <ul> <li> <p>The first term captures the loss for an ideal generative process on the data distribution and corresponds to the entropy of the natural text.</p> </li> <li> <p>The second term captures the fact that a perfectly trained transformer with \(N\) parameters underperforms the ideal generative process.</p> </li> <li> <p>The final term captures the fact that the transformer is not trained to convergence, as we only make a finite number of optimisation steps, on a sample of the dataset distribution.</p> </li> </ul> <p>To fit the empirical observations, they minimize a Huber loss on this formulation and also consider possible local minimas. Finally, they obtain the following results -</p> <table> <thead> <tr> <th>Approach</th> <th>Coeff. \(a\) where \(N_{\text{opt}} \propto C^a\)</th> <th>Coeff. \(b\) where \(D_{\text{opt}} \propto C^b\)</th> </tr> </thead> <tbody> <tr> <td>1. Minimum over training curves</td> <td>0.50 (0.488, 0.502)</td> <td>0.50 (0.501, 0.512)</td> </tr> <tr> <td>2. IsoFLOP profiles</td> <td>0.49 (0.462, 0.534)</td> <td>0.51 (0.483, 0.529)</td> </tr> <tr> <td>3. Parametric modelling of the loss</td> <td>0.46 (0.454, 0.455)</td> <td>0.54 (0.542, 0.543)</td> </tr> <tr> <td>Kaplan et al. (2020)</td> <td>0.73</td> <td>0.27</td> </tr> </tbody> </table> <p>The key insights they obtain are -</p> <ol> <li> <p>The current language models are considerably over-sized given the compute budges.</p> </li> <li> <p>The amount of training data that is projected to be needed is far beyond what is current used to train LLMs.</p> </li> </ol> <p>So the authors recommend that for a given training compute budget, smaller models should be trained on more tokens to achieve the most performant model.</p> <h2 id="chinchilla">Chinchilla</h2> <p>Considering the optimal hyperparameters they obtained, the authors trained a language model called <em>Chinchilla</em> as a competitor to Gopher. It is 4\(\times\) smaller than Gopher, and similarly the memory footprint and inference costs are reduced too. They follow a mixed-precision training procedure.</p> <p>The results obtained are very impressive - Chinchilla significantly outperforms Gopher on many evaluation subsets.</p> <h2 id="conclusion-5">Conclusion</h2> <p>The authors assert that scaling data instead of scaling models is the right way to obtain the best performance. We need to curate high-quality data - current models (e.g., GPT-3, MT-NLG) use only ~300B tokens, far below optimal recommendations (e.g., 1.5T tokens for 70B models).</p> <p>They mention that such results and methodologies can also be extended to other kinds of models outside autoregressive language models.</p> <p>Overall, this paper pushes towards an experimental based theoretical analysis of models and establishes a framework for compute-optimal training, demonstrating that <strong>equal scaling of parameters and tokens</strong> maximizes model performance. Chinchilla validates this hypothesis, achieving SOTA results with reduced computational overhead. Future work must prioritize dataset quality and ethical considerations alongside scaling.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/data-systems-for-ml/">Data Systems for Machine Learning</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/ai-agents/">AI Agents</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/rl-theory/">Reinforcement Learning Theory</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/brains-and-ai/">Brains and AI</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/Statistical-NLP/">Statistical Natural Language Processing</a> </li> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Sudhansh Peddabomma. Last updated: March 09, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script src="/assets/js/tooltips-setup.js?53023e960fbc64cccb90d32e9363de2b"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-0K9MLG0V24"></script> <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag('js', new Date());

    gtag('config', 'G-0K9MLG0V24');
  </script> <script defer src="/assets/js/google-analytics-setup.js?12374742c4b1801ba82226e617af7e2d"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> <div id="chat-window" class="chat-window"> <div class="chat-header"> <h5 class="mb-0">Talk to my AI</h5> <button id="close-chat" class="btn-close"> <i class="fas fa-times"></i> </button> </div> <div id="chat-messages" class="chat-messages"></div> <div class="chat-input-container"> <input type="text" id="chat-input" class="form-control" placeholder="Type a message..."> <button id="send-btn" class="btn btn-primary"> <i class="fas fa-paper-plane"></i> </button> </div> </div> </body> </html>