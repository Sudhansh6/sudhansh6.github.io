<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Machine Learning Systems | Sudhansh Peddabomma</title> <meta name="author" content="Sudhansh Peddabomma"> <meta name="description" content="Few keypoints from the amazing book at mlsysbook.ai and other important papers in the field."> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%91%BE&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://sudhansh6.github.io/blog/machine-learning-systems/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?6185d15ea1982787ad7f435576553d64"></script> <script src="/assets/js/chat.js?e73db4280bae3cbae4d78219277155b9"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Sudhansh Peddabomma</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">Articles</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"></a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/challenges/">Challenges</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/misc/">Miscellaneous</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">Machine Learning Systems</h1> <p class="post-meta">January 16, 2025</p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/category/notes"> <i class="fa-solid fa-tag fa-sm"></i> Notes</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <blockquote> <p>Acknowledging use of Perplexity, ChatGPT and the reference books and papers to aid with the content.</p> </blockquote> <h1 id="introduction">Introduction</h1> <p>As with every other article, this one starts with the same remark too - We are at an inflection point in human history. Artificial Intelligence (AI) is everywhere, and its growth has been unparalleled. We are in the AI revolution.</p> <p>At times like these, it is important to think about the future - how do we create systems that work alongside humanity to tackle the biggest problems life faces? We must master a new field of engineering to maintain this unprecedented pace.</p> <h2 id="history-of-ai">History of AI</h2> <p><img src="assets/reading01/2025-01-16-17-56-14-image.png" alt=""></p> <p>Starting with symbolic AI, one of the early approaches, STUDENT system developed by Daniel Bobrow in 1964, demonstrated natural language understanding by converting English text into algebraic equations. However, it was a rule-based system that was very brittle to the grammatical structure - although the solution may appear intelligent, it did not have a genuine understanding of language or the actions it was taking. This issue is the primary problem behind rule-based approaches.</p> <p>Then followed expert systems in 1970s, which focused on domain specific problems over generalized AI. For example, MYCIN developed by Stanford showed a major leap in medical AI with it’s 600 rules-based system. Nevertheless, scaling these rules with newer discoveries is infeasible.</p> <h3 id="statistical-learning">Statistical Learning</h3> <p>In the 1990s, something radical happened - the field moved away from rules to data-driven approaches. With the digital revolution, new capabilities got unlocked. From regression to neural networks, we allowed machines to discover patterns in the data leading to diverse applications. This new paradigm changed the way we approached machine learning. Quality of data, metrics to evaluate performance and trade-offs in design choices - all became relevant research questions.</p> <p>During the 2000s, algorithms like decision trees and KNNs made their way into practical applications. SVMs with their “kernel trick” became very popular. Human engineered features combined with statistical learning was the characteristic in the algorithms, and they had strong mathematical foundations as well. The models performed well with limited data, and produced reliable results. Even modalities like face detection with Viola-Jones algorithm (2001) became feasible.</p> <h3 id="deep-learning">Deep Learning</h3> <p>A double-edged sword, deep learning became the new kid in the block since the 2010s. Deep learning networks automatically discovered features in the data, doing away with feature engineering. Starting with AlexNet in 2012, the successes with deep learning models have never been shy. Researchers realized that bigger models equals better performance. Now, in the 2020s, we have entered the age of large models which have parameters reaching into few hundreds of billions! The datasets are well into the Petabytes stage.</p> <p>The three pillars required for these models to be successful, big data, better compute, and algorithmic breakthroughs, have successfully been put in place over the past few decades.</p> <p>These new depths have raised important questions about the future: how do we store and serve such models and datasets?!</p> <h2 id="ml-systems-engineering">ML Systems Engineering</h2> <p>It is the discipline of designing, implementing, and operating AI systems across computing scales. A machine learning system is an integrated computing system with three main parts - data, models and the compute infrastructure.</p> <p>Software Engineering as a field has been well established over the past decade. Even though the field is not yet mature, it has practices in place to enable reliable development, testing and deployment of software systems. However, these ideas are not entirely applicable to Machine Learning systems. Changes in the data distribution can alter the system behavior - this is a new paradigm we have not addressed before.</p> <p>More than often, the performance requirements guide the design decisions in the architecture. The complexities arise due to the broad spectrum across which ML is deployed today - from edge-devices to massive GPU-cloud clusters, each presents unique challenges and constraints. Operational complexities increase with system distribution. Some applications may have privacy requirements. The budget of the system acts as an important constraint. All these tradeoffs are rarely simple choices.</p> <p>Modern ML systems must seamlessly connect with existing software, process diverse data sources, and operate across organizational boundaries, driving new approaches to system design. FarmBeats by Microsoft, Alphafold by Deepmind and Autonomous vehicles are excellent examples of how proper systems in place can really push the extent of ML applicability.</p> <h2 id="challenges">Challenges</h2> <ol> <li> <p>Data Challenges - How do we store and process different kinds of data, and how to accommodate patterns with time?</p> </li> <li> <p>Model Challenges - How do we create efficient systems for different forms of learning, and test their performance across a wide range of scenarios?</p> </li> <li> <p>Systems Challenges - How do we set up pipelines in place to combine all of this in place? Systems that have monitoring and stats, that allow model updates and handle operational challenges.</p> </li> <li> <p>Ethical and Social Considerations - How do we address bias in such large-scale models? Can we do something about the “black-box” nature? Can we handle data privacy and handle inference attacks?</p> </li> </ol> <p>A major solution to address all these challenges has been to <em>democratize AI technology</em>. Similar to an “all hands-on deck” solution, with the involvement of a large amount of people in this evolution, we are tackling one of the most innovative problem’s humanity has ever faced - how do we achieve AGI?</p> <h1 id="dnn-architectures">DNN Architectures</h1> <p>Assuming the reader’s know enough about different model architectures, we shall now discuss the core computations involved in these models to design the systems around them.</p> <h2 id="architectural-building-blocks">Architectural Building Blocks</h2> <p>So far, we have the following major architectures summarized below -</p> <h3 id="multi-layer-perceptrons-mlps">Multi-Layer Perceptrons (MLPs)</h3> <ul> <li> <p>Purpose: Dense pattern processing</p> </li> <li> <p>Structure: Fully connected layers</p> </li> <li> <p>Key operation: Matrix multiplication</p> </li> <li> <p>System implications:</p> <ul> <li>High memory bandwidth requirements</li> <li>Intensive computation needs</li> <li>Significant data movement</li> </ul> </li> </ul> <h3 id="convolutional-neural-networks-cnns">Convolutional Neural Networks (CNNs)</h3> <ul> <li> <p>Purpose: Spatial pattern processing</p> </li> <li> <p>Key innovations: Parameter sharing, local connectivity</p> </li> <li> <p>Core operation: Convolution (implemented as matrix multiplication)</p> </li> <li> <p>System implications:</p> <ul> <li>Efficient memory access patterns</li> <li>Specialized hardware support (e.g., tensor cores)</li> <li>Opportunity for data reuse</li> </ul> </li> </ul> <h3 id="recurrent-neural-networks-rnns">Recurrent Neural Networks (RNNs)</h3> <ul> <li> <p>Purpose: Sequential pattern processing</p> </li> <li> <p>Key feature: Maintenance of internal state</p> </li> <li> <p>Core operation: Matrix multiplication with state update</p> </li> <li> <p>System implications:</p> <ul> <li>Sequential processing challenges</li> <li>Memory hierarchy optimization for state management</li> <li>Variable-length input handling</li> </ul> </li> </ul> <h3 id="transformers-and-attention-mechanisms">Transformers and Attention Mechanisms</h3> <ul> <li> <p>Purpose: Dynamic pattern processing</p> </li> <li> <p>Key innovation: Self-attention mechanism</p> </li> <li> <p>Core operations: Matrix multiplication and attention computation</p> </li> <li> <p>System implications:</p> <ul> <li>High memory requirements</li> <li>Intensive computation for attention</li> <li>Complex data movement patterns</li> </ul> </li> </ul> <p>Some innovations like skip connections, normalization techniques, and gating mechanisms are highlighted as important building blocks that require specific architectures. With these in mind, we require the following primitives -</p> <ul> <li> <p><strong>Core Computational Primitives</strong> -Matrix multiplication, Sliding window operations, Dynamic computation</p> </li> <li> <p><strong>Memory Access Primitives</strong> - Sequential access, Strided access, Random access</p> </li> <li> <p><strong>Data Movement Primitives</strong> - Broadcast, Scatter, Gather and Reduction</p> </li> </ul> <p>We address these primitives, by designing efficient systems as well as hardware.</p> <ul> <li> <p><strong>Hardware</strong> - Development of specialized processing units (e.g., tensor cores), Complex memory hierarchies and high-bandwidth memory, Flexible interconnects for diverse data movement patterns</p> </li> <li> <p><strong>Software</strong> - Efficient matrix multiplication libraries, Data layout optimizations, Dynamic graph execution support</p> </li> </ul> <h2 id="conclusion">Conclusion</h2> <p>In summary, understanding the relationship between high-level architectural concepts is important for their implementation in computing systems. The future advancements in deep learning will likely stem from both novel architectural designs and innovative approaches to implementing and optimizing fundamental computational patterns.</p> <p>Now that we have understood the basics of Machine Learning Systems, let us delve into the two biggest frameworks that support the ML systems today.</p> <h1 id="tensorflow-a-system-for-large-scale-machine-learning"><a href="https://arxiv.org/pdf/1605.08695" rel="external nofollow noopener" target="_blank">TensorFlow: A system for large-scale machine learning</a></h1> <p>A product of Google brain built to tackle large scale systems in heterogeneous environments. TensorFlow uses data-flow graphs to represent computations, shared states and operations. These can be mapped across many machines giving a flexibility to the developers.</p> <p>TensorFlow is based on a previous product of Google Brain, DistChild, that was used for a large number of research and commercial tasks. The team recognized the recent advances in ML - CNNs that broke records reaching up to millions of parameters and GPUs that accelerated the training processes. They developed a framework that is well-optimized for general scenarios for both training and inference. They also meant for it to be <em>extensible</em> - to allow ability to experiment and scale in production with the same code.</p> <p>Prior to this work, Caffe, Theano and Torch were the major frameworks. Caffe was known for its high-performance, Theano for its data flow model and Torch for its imperative programming model. Along with these works, TensorFlow also draws inspiration from the map-reduce paradigm that improved the performance of data systems significantly.</p> <h2 id="tensorflow-execution-model">TensorFlow execution model</h2> <p>The computation and state of the algorithm, including the mathematical operations are represented in a single dataflow graph. The communications between the subcomputations are made explicitly to execute independent computations in parallel and partition the computation across distributed devices. The key point to note here is that the graph has mutable states for the individual vertices, meaning that data can be shared between different executions of the graph. Although this point may seem trivial now, architectures prior to TensorFlow worked with static computations graphs that did not allow changes to the weights - algorithms such as mini-batch gradient descent were not scalable to large parameter models. Due to this change in the architecture, developers can experiment with different optimization algorithms, consistency schemes and parallelization strategies.</p> <h3 id="dataflow-graph-elements">Dataflow graph elements</h3> <p>Each vertex in the dataflow graph is an atomic unit of computation and each edge is the output or input to a vertex - values flowing through tensors.</p> <p><strong>Tensors</strong> - Notably, <em>tensors</em> as a computational quantity were introduced in this paper. Their work assumes all tensors are dense - this allows simple implementations for memory allocation and serialization.</p> <blockquote> <p>Modern neural networks on the contrary have sparse tensors in many scenarios - can be optimized greatly</p> </blockquote> <p>TensorFlow does allow representing sparse tensors but at the cost of more sophisticated shape inference.</p> <p><strong>Operations</strong> - An operation can simply be thought of as a function that takes \(m \geq 0\) tensors as input and returns \(n \geq 0\) tensors as output. The number of arguments to these operators can be constant or variable (<em>variadic</em> operators). <strong>Stateful operations</strong> (variables and queues) contain mutable states that can be updated every time the operator executes. Variables are mutable buffers storing shared parameters and queues support advanced forms of coordination.</p> <h3 id="partial-and-concurrent-execution">Partial and concurrent execution</h3> <p>The key advantage of storing the dataflow as a graph is the ability to execute independent operations in parallel. Once a graph is defined by the user, the API allows for executing any sub-graph the user queries. Each invocation is a <em>step</em> and TensorFlow supports multiple <em>concurrent steps</em>. This ability shines for the batch-processing workflows in neural networks. Furthermore, TensorFlow has a checkpointing subgraph that runs periodically for fault tolerance.</p> <p>This functionality of running graphs partially and concurrently contribute much to TensorFlow’s flexibility.</p> <h3 id="distributed-execution">Distributed execution</h3> <p>Since the communication between subcomputations is explicit, the distribution of the dataflow becomes simpler. Each operation resides on a particular <em>device</em> (note that this feature has also been adapted in PyTorch), and a device is responsible for executing a <em>kernel</em> for each operation assigned to it. TensorFlow allows multiple kernels to be registered for a single operation.</p> <p>The placement algorithm computes a feasible set of devices for each operation, calculates the sets of operations that must be colocated and selects a satisfying device for each colocation group. In addition, the users can also specify their device preferences for a particular task. <em>Yes, TensorFlow was advanced since the beginning</em>.</p> <p>Once the operations are placed, the partial subgraphs are computed for a step, and are pruned and partitioned across the devices. The communication mechanisms between devices is also put in place with specialized implementations to optimize for latency with large-subgraphs running repeatedly. On the user-end, a <em>client session</em> maintains a mapping from step definitions to cached subgraphs. This computation model performs the best with static, reusable graphs but also supports dynamic computations with control flows.</p> <h3 id="dynamic-control-flow">Dynamic control flow</h3> <p>Although most evaluation in TensorFlow is <em>strict</em>, wherein it requires for all inputs to an operation to be computed before the operation executes, advanced algorithms (such as RNNs), require dynamic control flow, requiring non-strict evaluation. To aid with this, TensorFlow also supports primitive <strong>Switch</strong> (demultiplexer) and <strong>Merge</strong> (multiplexer) operations for dynamic dataflow architectures! These primitives can be used to build a non-strict conditional sub-graph that executes one of two branches based on the runtime values of a tensor. These primitives also support loops with additional structural constraints based on the dataflow!</p> <h2 id="extensibility">Extensibility</h2> <ul> <li> <p><strong>Differentiation</strong> - TensorFlow has a user-level library that <strong>automatically differentiates</strong> expressions. It performs a breadth-first search to identify all of the backwards paths from the target operation (loss function) to a set of parameters in the computation graph, and sums the partial gradients that each path contributes. With optimizations such as batch normalization and gradient clipping, the algorithm also supports backpropagation through conditional and iterative subcomputations! All of this done with memory management on GPU.</p> </li> <li> <p><strong>Optimization</strong> - SGD is a simple algorithm encoded in the framework. However, for more advanced optimization schemes like Momentum, TensorFlow relies on community driven implementations that are easily pluggable without modifying the underlying system. Such a modular framework was not available before.</p> </li> <li> <p><strong>Handling Large models</strong> - Even back then, the language models were too large to store in RAM of a single host. For the language specific case, TensorFlow has <em>sparse embedding layers</em> that is a primitive operation that abstracts storing and reading a tensor across different memory spaces. They are implemented with operators such as <code class="language-plaintext highlighter-rouge">gather</code>, <code class="language-plaintext highlighter-rouge">part</code> and <code class="language-plaintext highlighter-rouge">stitch</code>, and their gradients are also implemented. Along with innovations such as Project Adam, TensorFlow’s training was ultimately made efficient through community driven improvements.</p> </li> <li> <p><strong>Fault Tolerance</strong> - Since many learning algorithms do not require consistency and writing at every step is compute intensive, TensorFlow implements user-level checkpointing for fault tolerance. This design decision leaves it to the user to build their own best fault handling mechanisms. <em>I wish they had an automatic version as well</em>.</p> </li> <li> <p><strong>Synchronous replica coordination</strong> - SGD is robust to asynchrony, and TensorFlow is designed for asynchronous training. In the asynchronous case, each worker reads the current value when the step begins, applies its gradient to the different current value at the end. The synchronous cases use queues to coordinate execution, allowing multiple gradient updates together. Although the throughput is reduced, this way of training is more efficient. TensorFlow implements <em>backup workers</em> to improve the throughput of this synchronous case by 15%.</p> </li> </ul> <h2 id="implementation">Implementation</h2> <p>The core TensorFlow library is implemented in C++ for portability and performance with its implementation being open-source. It consists of</p> <ul> <li> <p>Distributed master - given a graph and a step definition, it prunes and partitions the graphs to each devices, and caches these subgraphs so that they may be reused in subsequent steps.</p> </li> <li> <p>Dataflow executor - Schedules the execution of the kernels that comprise a local subgraph - optimized for running large fine-grained graphs with low overhead.</p> </li> </ul> <p>The API can be accessed both via C++ and Python.</p> <p>The library does not provide huge gains for single-system training but has higher throughput for large models across multiple devices.</p> <h2 id="conclusion-1">Conclusion</h2> <p>When this paper was published, TensorFlow was still a work in progress. Later, the library transformed significantly with the introduction of v2, and other optimizations.</p> <h1 id="pytorch-an-imperative-style-high-performance-deep-learning-library"><a href="https://arxiv.org/abs/1912.01703" rel="external nofollow noopener" target="_blank">PyTorch: An Imperative Style, High-Performance Deep Learning Library</a></h1> <p>A product of Facebook research, PyTorch is the most popular deep-learning library. They addressed the biggest limitation in previous frameworks - usability. They targeted both performance and usability by designing an imperative-style ML framework.</p> <p>In contrast to PyTorch, the previous approaches created a static dataflow graph that represents the computation. Since the whole computation is visible ahead of time, it can be leveraged to improve performance and scalability. However, due to this, the usability is reduced and cannot be used to iteratively build experiments. PyTorch, a python library, performs immediate execution of dynamic tensor computations with automatic differentiation and GPU acceleration while maintaining comparable performance to the static libraries.</p> <h2 id="background">Background</h2> <p>There were four major trends in scientific computing that have become important for deep learning:</p> <ol> <li>Development of domain-specific languages and libraries for tensor manipulation (e.g., APL, MATLAB, NumPy made array-based productive productive)</li> <li>Automatic differentiation, making it easier to experiment with different machine learning approaches</li> <li>Shift towards open-source Python ecosystem from proprietary software. The network effects of Python contributed to its exponential growth.</li> <li>Availability of general-purpose parallel hardware like GPUs</li> </ol> <p>PyTorch builds on these trends by providing an array-based programming model accelerated by GPUs and differentiable via automatic differentiation integrated in the Python ecosystem.</p> <h2 id="design-principles">Design Principles</h2> <p>PyTorch’s design is based on four main principles:</p> <ol> <li>Be Pythonic: Integrate naturally with Python ecosystem, keep interfaces simple and consistent</li> <li>Put researchers first: Make writing models, data loaders, and optimizers easy and productive</li> <li>Provide pragmatic performance: Deliver compelling performance without sacrificing simplicity</li> <li>“Worse is better”: Prefer simple, slightly incomplete solutions over complex, comprehensive designs</li> </ol> <h2 id="usability-centric-design">Usability-centric Design</h2> <p>The approach to PyTorch starts by considering deep-learning models as just another Python program. By considering so, PyTorch maintains the imperative programming model inspired from Chainer and Dynet. Defining layers, composing models, loading data, running optimizers and parallelizing the training process can all be expressed using familiar Python syntax. It allows any new potential neural network architecture to be easily implemented with composability.</p> <p>Mainly, since PyTorch programs execute eagerly, all features of Python like print, debugging and visualization work as expected. In addition, PyTorch has -</p> <ul> <li> <p><strong>Interoperability</strong> - Integrated well with other libraries to allow bidirectional exchange of data (NumPy, Matplotlib, etc).</p> </li> <li> <p><strong>Extensibility</strong> - Supports custom differentiable functions and datasets. The abstractions take care of shuffling, batching, parallelization, and management of pinned CUDA memory to improve the throughput and performance. In general, PyTorch components are completely interchangeable!</p> </li> </ul> <h3 id="automatic-differentiation">Automatic differentiation</h3> <p>Python is a dynamic programming language that has most of the behavior defined at run-time, making it difficult to pre-calculate the differentiation. Instead, PyTorch uses operator overloading approach to build up a representation of the computed function every time it is executed. It notes the difference between forward mode and backward mode automatic differentiation and adopts the latter which is better suited for ML applications.</p> <p>Their system can differentiate through code with mutation on tensors as well. They also have a versioning system for tensors as a failsafe to track the modifications.</p> <h2 id="performance-focused-implementation">Performance-focused Implementation</h2> <p>With all these considerations to usability, the developers implemented many tricks to maintain the performance of the library. Since the models have to run on Python interpreter, which has its own limitations such as the global interpreter lock (ensures only one of any concurrent threads is running at a given time), PyTorch optimized every aspect of execution and also enabled users to add their own optimization strategies. Prior frameworks avoided these constraints by deferring the evaluation to their custom interpreters.</p> <p>Most of PyTorch is implemented C++ for high performance. The core <code class="language-plaintext highlighter-rouge">libtorch</code> library implements the tensor data structure, GPU and CPU operators, automatic differentiation system with gradient formulas for most built-in functions and basic parallel primitives. The pre-computed gradient functions allow computation of gradients of core PyTorch operators in a multithreaded evaluation evading the Python global interpreter lock. The bindings are generated using YAML meta-data files, that allowed the community to create bindings to other languages.</p> <p>PyTorch separates the control (program branches, loops) and the data flow (tensors and the operations). The Control flow handled by Python and optimized C++ code on CPU and Data flow can be executed on CPU or GPU. PyTorch is designed to run asynchronously leveraging the CUDA stream mechanism. This allows overlap of Python code execution on CPU with tensor operations on the GPU, effectively saturating GPU with large tensor operations. The main performance cover-up comes from this design.</p> <p>Since every operator needs to allocate an output tensor to hold the results, the speed of <em>dynamic memory allocators</em> needs to be optimized. CPU has efficient libraries to handle this. However, to avoid the bottleneck of <code class="language-plaintext highlighter-rouge">cudaFree</code> routine that blocks code until all previously queued work on GPU completes, PyTorch implements its custom allocator that incrementally builds up a cache of CUDA memory. It reassigns it to later allocations without CUD APIs for better interoperability allowing users to use other GPU enabled Python packages. This allocator is further optimized with memory usage patterns and its implementation is simplified with the <em>one-pool-per-stream</em> assumption.</p> <p>The <code class="language-plaintext highlighter-rouge">multiprocessing</code> library was developed to evade the global interpreter lock on Python. However, this is inefficient for large arrays, so it is extended as <code class="language-plaintext highlighter-rouge">torch.multiprocessing</code> to allow automatic movement of data to shared memory improving the performance significantly. It also transparently handles sharing of CUDA tensors to build analytical systems on top of this.</p> <p>Since users write models to consume all the memory resources, PyTorch treats memory as a scarce resource and handles it carefully. The overheads of garbage collection are too large. To solve this, PyTorch relies on a reference counting scheme to track the number of uses of each tensors, and frees the underlying memory <em>immediately</em> when this count reaches zero. This ensures immediate freeing of memory when tensors become unneeded.</p> <p>With all these optimizations, PyTorch achieves</p> <ul> <li> <p>ability to asynchronously execute dataflow on GPU with almost perfect device utilization</p> </li> <li> <p>custom memory allocator showing improved performance</p> </li> <li> <p>performance within 17% of the fastest framework across all benchmarks</p> </li> </ul> <h2 id="conclusion-2">Conclusion</h2> <p>The paper concludes by highlighting PyTorch’s success in combining usability with performance. Future work includes:</p> <ul> <li>Developing PyTorch JIT for optimized execution outside the Python interpreter</li> <li>Improving support for distributed computation</li> <li>Providing efficient primitives for data parallelism</li> <li>Developing a Pythonic library for model parallelism based on remote procedure calls</li> </ul> <p>##</p> <h1 id="deep-learning-performance-on-gpus">Deep Learning Performance on GPUs</h1> <blockquote> <p>Source: https://docs.nvidia.com/deeplearning/performance/index.html#performance-background</p> </blockquote> <p>GPUs accelerate computing by performing independent calculations in parallel. Since deep learning operations involve many such operations, they can leverage GPUs very well.</p> <p>It is useful to understand how deep learning operations are utilizing the GPU. For example, operations that are not matrix multiplies, such as activation functions and batch-normalization, often are <em>memory-bound</em>. In these cases, tweaking parameters to more efficiently use the GPU can be ineffective. In these cases, the data movement between the host and the device can limit the performance. By understanding such intricacies, we can design better code to leverage GPUs to the fullest.</p> <blockquote> <p>We shall discuss the concepts in context of NVIDIA GPUs because of the existing monopoly.</p> </blockquote> <h2 id="architecture-fundamentals">Architecture Fundamentals</h2> <p>The core paradigm of GPU is parallel compute. It has processing elements and a memory hierarchy. At a high level, GPUs consist of Streaming Multiprocessors (SMs), on-chip L2 cache, and high-bandwidth RAM.</p> <p>Each SM has its own instruction scheduler and execution pipelines. In a neural network, <em>multiply-add</em> is the most frequent operation. A typical spec sheet shows FLOPS rate of GPU operations - #SMs*SM clock rate*#FLOPs.</p> <h2 id="execution-model">Execution Model</h2> <p>GPUs execute functions in a 2-level hierarchy of threads - a given function’s threads are grouped into equally-sized <em>thread blocks</em>, and a set of thread blocks are launched to execute the function. The latency caused by dependent instructions is hidden by switching to the execution of other threads. As a result, the number of threads needed to effectively use a GPU is much higher than the number of cores or instruction pipelines.</p> <p>At runtime, each thread block is placed on an SM for execution. All the threads in the block communicate via a shared memory in the blocks and synchronize efficiently. To use the GPU to the maximum, we need to execute many SMs (since each threadblock only activates one SM). Furthermore, each SM can execute multiple threadblocks simultaneously. Therefore, we need to launch many threadblocks, a number several times higher than the number of SMs.</p> <p>These thread blocks running concurrently are termed as a <em>wave</em>. In effect, we need to launch functions that execute several waves of thread blocks to minimize the <em>tail effect</em> (towards the end of a function, only a few active thread blocks remain).</p> <h2 id="understanding-performance">Understanding performance</h2> <p>There are three factors determining performance - <strong>memory bandwidth, math bandwidth and latency</strong>. To analyze these better, let \(T_{mem}\) be the time spent in accessing memory and \(T_{math}\) is the time spent performing math operations.</p> \[\begin{align*} T_{mem} &amp;= \text{\# bytes accessed}/ \text{memory bandwidth} \\ T_{math} &amp;= \#\text{ math ops}/\text{math bandwidth} \end{align*}\] <p>If these functions can be overlapped, then the total time is approximately \(\max(T_{mem}, T_{math})\). And based on the dominance, we categorize the functions as <em>math-limited</em> and <em>memory-limited</em>. So if a function is math-limited, we have</p> \[\#\text{ops}/\#\text{bytes} &gt; BW_{math}/BW_{mem}\] <p>The left-hand side of this inequality is known as <strong>arithmetic intensity</strong>, and the right-hand side is called as <em>ops:byte</em> ratio. Based on this description, we have the following data for NVIDIA V100 GPU for FP16 data -</p> <table> <thead> <tr> <th>Operation</th> <th>Arithmetic Intensity</th> <th>Usually limited by…</th> </tr> </thead> <tbody> <tr> <td>Linear layer (4096 outputs, 1024 inputs, batch size 512)</td> <td>315 FLOPS/B</td> <td>arithmetic</td> </tr> <tr> <td>Linear layer (4096 outputs, 1024 inputs, batch size 1)</td> <td>1 FLOPS/B</td> <td>memory</td> </tr> <tr> <td>Max pooling with 3x3 window and unit stride</td> <td>2.25 FLOPS/B</td> <td>memory</td> </tr> <tr> <td>ReLU activation</td> <td>0.25 FLOPS/B</td> <td>memory</td> </tr> <tr> <td>Layer normalization</td> <td>&lt; 10 FLOPS/B</td> <td>memory</td> </tr> </tbody> </table> <p>Many common operations have low arithmetic intensities (memory-limited). <em>Note.</em> This analysis assumes that the workload is large enough to saturate the device and not be limited by latency.</p> <h2 id="operation-categories">Operation Categories</h2> <p>There are three main types of operations in a neural network</p> <ol> <li> <p>Element-wise operations - Unary/binary operations such as ReLU and element-wise addition. These layers tend to be memory-limited as they perform few operations per byte accessed.</p> </li> <li> <p>Reduction operations - Operations that produce values over a range of input tensor values, such as pooling, softmax and normalization layers. These layers usually have low arithmetic intensity (memory limited).</p> </li> <li> <p>Dot-product operations - Operations can be expressed as dot-product of two tensors, such as attention and fully-connected layers. These operations tend to be math-limited if the matrices are large. For smaller operations, these are memory limited.</p> </li> </ol> <h2 id="summary">Summary</h2> <p>The number of SMs in the GPU determines the ops:bytes ratio. To maximize the performance, ensure sufficient parallelism by oversubscribing the SMs. The most likely performance limiter is</p> <ul> <li>Latency if there is not sufficient parallelism</li> <li>Math if there is sufficient parallelism and algorithm arithmetic intensity is higher than the GPU ops:byte ratio</li> <li>Memory if there is sufficient parallelism and algorithm arithmetic intensity is lower than the GPU ops:byte ratio</li> </ul> <h1 id="matrix-multiplication">Matrix Multiplication</h1> <p>As we’ve observed previously, General Matrix Multiplications (GEMMs) is the most frequent operation in neural network layers. For the sake of the discussion, based on the conventions, let \(A \in \mathbb R^{m \times k}, B \in \mathbb R^{k \times n}\) and \(C = A \times \in \mathbb R^{m \times n}\). \(C\) would require a total of \(M*N*K\) fused multiply-adds (FMAs) (twice for the FLOPs). In general, for smaller multiplications, the operation is memory limited, and otherwise it is math-limited. As a consequence, vector products \(M = 1\) or \(N = 1\) are always memory limited and their arithmetic intensity is less than 1.</p> <h2 id="implementation-1">Implementation</h2> <p>Most of the GPUs implement matrix multiplication as a tiling operation - each thread block computes its output tile by stepping through the \(K\) dimension in tiles.</p> <p>The latest NVIDIA GPUs have Tensor Cores to maximize multiplications in tensors. The performance is better when \(M, n&lt; k\) are aligned to multiples of 16 bytes.</p> <p>To aid with the code design, NVIDIA has provided the cuBLAS library that contains its optimized GEMM implementations. The tradeoff arises between parallelism and memory reuse - Larger tiles have fewer memory I/O but reduced parallelism. This is, in particular, a concern for smaller matrices. The library contains a variety of tiling to techniques to best utilize the GPU.</p> <h2 id="dimension-quantization-effects">Dimension Quantization effects</h2> <p>A GPU function is executed by launching a number of thread blocks, each with the same number of threads. This introduces two potential effects on execution efficiency - tile and wave quantization.</p> <ul> <li> <strong>Tile Quantization</strong> - Tile quantization occurs when matrix dimensions are not divisible by the thread block tile size.</li> </ul> <p><img src="/assets/img/Machine%20Learning%20Systems/2025-01-25-23-37-44-image.png" alt=""></p> <ul> <li> <strong>Wave quantization</strong> - The total number of tiles is quantized to the number of multiprocessors on the GPU.</li> </ul> <h1 id="mi300x-vs-h100-vs-h200">MI300X vs H100 vs H200</h1> <blockquote> <p>Source: <a href="https://semianalysis.com/2024/12/22/mi300x-vs-h100-vs-h200-benchmark-part-1-training/" rel="external nofollow noopener" target="_blank">MI300X vs H100 vs H200 Benchmark Part 1: Training; CUDA Moat Still Alive; SemiAnalysis</a></p> </blockquote> <p>A case-study to examine why numbers on paper do not translate to real-life performance.</p> <p><img src="https://i0.wp.com/semianalysis.com/wp-content/uploads/2024/12/10-H100-vs-H200-vs-MI300X-Basic-Specs-initial-1.jpg?resize=2184%2C1088&amp;ssl=1" alt=""></p> <p>Comparing numbers on sheets is similar to comparing the megapixel count of cameras - the software is very important. NVIDIAs real world performance is also quite low compared to the papers. The analysis boils down to this - The potential on paper of AMD’s MI300X is not realized due to lack of AMDs software stack and testing. The gap between AMDs and NVIDIAs software is large - AMD is still catching up while NVIDIA is racing ahead. AMDs PyTorch is unfortunately broken.</p> <h2 id="matrix-multiplication-1">Matrix Multiplication</h2> <p>OpenAI provides a <code class="language-plaintext highlighter-rouge">do_bench</code> function to benchmark matrix multiplications - it provides cache clearing between runs, ways to warmup and execute the benchmark multiple times and takes the median result. The results are as follows -</p> <p><img src="https://i0.wp.com/semianalysis.com/wp-content/uploads/2024/12/71-bf16-gemm-perf-for-real-world-shapes-w-amd-images.png?resize=1489%2C1084&amp;ssl=1" alt=""></p> <p>Notice how the marketed value is much higher than the real-world performance! The main finding from this study is that AMDs software stack is riddled with bugs that lowered its performance quite a lot.</p> <p>It is also important to ensure that the underlying benchmark has no issues. For example, a popular benchmark for GEMM showed comparable performance for AMD and NVIDIA. However, on closer look, it had issues - it did not clear out L2 Cache and displayed the max performance rather than mean/median.</p> <h2 id="hbm-memory-bandwidth-performance">HBM Memory Bandwidth Performance</h2> <p>Higher HBM bandwidth leads to better inference performance. It is also helpful during training, specially with higher batch sizes.</p> <p><img src="https://i0.wp.com/semianalysis.com/wp-content/uploads/2024/12/115-HBM-Copy-Bandwidth-Chart.png?resize=1485%2C1047&amp;ssl=1" alt=""></p> <h2 id="training-large-language-models">Training Large Language Models</h2> <p>MLPerf GPT3 175B training is a good metric to measure the time it takes to train a model. However, this benchmark turned out to be very difficult for the AMD GPUs. Instead, the authors designed a benchmark better representing a user workload. They noted that many AI practitioners do not use Megatron, NeMo and 3D parallelism (advances in modern networks architectures for faster inference) due to their rigidity and complexity.</p> <p>Overall for this test, on a single node, the authors obtained the following results -</p> <p><img src="https://i0.wp.com/semianalysis.com/wp-content/uploads/2024/12/121-bf16-single-node-8gpu-training-perf-with-new-AMD-images.png?resize=1491%2C1180&amp;ssl=1" alt=""></p> <p>The public releases of NVIDIA perform much higher than AMDs bugs-resolved builds. Apart from these single node builds, these providers also have a server cluster availability. NVIDIAs GPUs are merged with the NVLink fabric whereas AMD has xGMI. They connect up to 8GPUs with up to 450GB/s of bandwidth per GPU. This network of GPUs synchronize via the map-reduce command, and NVIDIAs topology performs better than that of AMDs.</p> <p>Ironically, AMDs RCCI team has only 32 GPUs to experiment with the algorithms. Looking at this dismal conditions, TensorWave and SemiAnalysis sponsored some clusters to the team to aid the team in fixing their software.</p> <h2 id="conclusion-3">Conclusion</h2> <p>Due to poor internal testing and a lack of good testing suite internally at AMD, MI300 is not usable out of the box. There have been advanced in attention mechanisms such as the <strong>FlexAttention</strong> that can improve the speed of window attention by 10-20x. However, due to the lacking nature of AMDs software, they are 6 months behind NVIDIA which is a long time in the rapid AI age.</p> <p>In fact, many of AMDs libraries are forked off NVIDIA’s open-source libraries! The authors suggest AMD should hire more software talent to reduce the gap and reshape their user interface.</p> <h1 id="tvm-end-to-end-compiler-for-deep-learning"><a href="https://arxiv.org/pdf/1802.04799" rel="external nofollow noopener" target="_blank">TVM: End-to-end compiler for Deep Learning</a></h1> <p>Current ML frameworks require significant manual effort to deploy on different hardware. TVM exposes the graph-level and operator-level optimizations to provide performance portability. In the current frameworks, techniques such as computational graph representations, auto-differentiation and dynamic memory management have been well established. Optimizing these structures on different hardware is however often infeasible, and developers have resorted to highly engineered and vendor-specific operator libraries. These libraries require significant amount of manual tuning and cannot be ported across devices.</p> <p>How does the hardware matter? The input to hardware instructions are multi-dimensional, with fixed or variable lengths; they dictate different data layout and they have special requirements for memory hierarchy. These different constraints (memory access, threading pattern, hardware primitives - loop tiles and ordering, caching, unrolling) form a large search space that needs to be optimized to get efficient implementation.</p> <p>TVM, an end-to-end ML compiler, has been designed to take a high-level specification of a deep-learning program from existing frameworks and generate a low-level optimized code for a diverse set of hardware backends. To do so, they made the following contributions</p> <ul> <li> <p>A <em>tensor expression language</em> to build operators and provide program transformation primitives to generate equivalent programs</p> </li> <li> <p>An <em>automated program optimization framework</em> to find optimized tensor operators based on an ML cost model that adapts and improves based on the data received from the hardware backend.</p> </li> <li> <p>A <em>graph-rewriter</em> compiler together the high-level and operator-level optimizations.</p> </li> </ul> <p><img src="/assets/img/Machine%20Learning%20Systems/2025-02-04-17-41-07-image.png" alt=""></p> <h2 id="graph-optimization">Graph Optimization</h2> <p>As mentioned previously, DL frameworks represent the data flow with graphs. This is different from the low-level compiler intermediate representation due to the presence of large, multi-dimensional tensors. Similar to compiler graph optimization, TVM also performs similar optimizations on this graph -</p> <ol> <li> <p><strong>Operator Fusion</strong> - Fuse multiple small operations together, reducing the activation energy for executing each operator. The commonly used operators can be classified as injective (one-to-one, e.g., add), reduction (many-to-one, e.g., sum), complex-out-fusable (element-wise map based output, e.g., convolution), and opaque (cannot be fused, e.g., sort).</p> <p>These classifications help us identify operators that can be combined. For example, in general</p> <ul> <li> <p>Multiple injective operators can be fused into one another</p> </li> <li> <p>A reduction operator can be fused with the input injective operators</p> </li> <li> <p>Complex-out-fusable operators can fuse element-wise operators to its output</p> </li> </ul> <p>These fusions generate <strong>up to 1.2x to 2x speedup</strong>!</p> </li> <li> <p><strong>Constant folding</strong> - Pre-compute graph parts that can be determined statically, saving execution costs</p> </li> <li> <p><strong>Static memory planning pass</strong> - Pre-allocate memory to hold each intermediate tensor</p> </li> <li> <p><strong>Data Layout transformations</strong> - Transform internal data layouts into back-end friendly forms. For example, a DL accelerator might exploit \(4\times4\) matrix operations, requiring data to be tiled into \(4\times4\) chunks. The memory hierarchy constraints are also taken into consideration.</p> </li> </ol> <p>These optimizations is where the search-space complexity arises. With more operators being introduced on a regular basis, the number of possible fuses can grow significantly considering the increasing number of various hardware back-ends as well. Doing these optimizations manually is infeasible and we need to automate the process.</p> <h2 id="tensor-operations">Tensor Operations</h2> <p>TVM produces efficient code for each operator by generating many valid implementations for each hardware back-end and choosing an optimized implementation. This process is built on Halide’s idea of decoupling descriptions from computation rules and extends it to support new optimizations (nested parallelism, tensorization and latency hiding).</p> <h3 id="tensor-expression-and-schedule-space">Tensor Expression and Schedule Space</h3> <p>Unlike high-level computation graph representations, where the implementation of tensor operations is opaque, each operation is described in an index formula expression language. For example, matrix multiplication is written as</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="nf">var</span><span class="p">(</span><span class="sh">'</span><span class="s">m</span><span class="sh">'</span><span class="p">),</span> <span class="n">t</span><span class="p">.</span><span class="nf">var</span><span class="p">(</span><span class="sh">'</span><span class="s">n</span><span class="sh">'</span><span class="p">),</span> <span class="n">t</span><span class="p">.</span><span class="nf">var</span><span class="p">(</span><span class="sh">'</span><span class="s">h</span><span class="sh">'</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="nf">placeholder</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="sh">'</span><span class="s">A</span><span class="sh">'</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="nf">placeholder</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="sh">'</span><span class="s">B</span><span class="sh">'</span><span class="p">)</span>
<span class="n">k</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="nf">reduce_axis</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="sh">'</span><span class="s">k</span><span class="sh">'</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="nf">compute</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> 
                <span class="n">t</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">k</span><span class="p">))</span>
</code></pre></div></div> <p>Each compute operation specifies both shape and expression for output. Since the language does not specify the loop structure and other execution details, it provides the flexibility for adding hardware-aware optimizations. <em>Schedules</em> are built incrementally with basic transformations to preserve the program’s logical equivalence. To achieve high performance on many back-ends, the schedule primitives must be diverse enough to cover various hardware backends.</p> <h3 id="nested-parallelism">Nested Parallelism</h3> <p>A common paradigm based on fork-join concept, nested parallelism is present in many existing solutions. Based on memory hierarchies, solutions also consider <em>shared memory spaces</em> and <em>fetching data cooperatively</em>. TVM builds on this idea with the concept of <strong>memory scopes</strong> to the schedule space so that a compute stage can be marked as shared. These shared tasks have <em>memory synchronization barriers</em> to ensure proper read/writes.</p> <h3 id="tensorization">Tensorization</h3> <p>To ensure high arithmetic intensity, hardware developers have started implementing <em>tensor compute primitives</em> that consider the common operations and design specific hardware for their execution. They can improve the performance (similar to vectorization for SIMD architectures), but with more and more accelerators with their own variants of tensor instructions, there is a need for an extensible solution that can seamlessly integrate with all these.</p> <p>To do so, TVM extends the tensor expression language to include hardware intrinsics. Doing so decouples the schedule from specific hardware primitives. The generated schedules are broken into a sequence of micro-kernel calls which can also use the <em>tensorize</em> primitive to make use of accelerators.</p> <h3 id="explicit-memory-latency-hiding">Explicit Memory Latency Hiding</h3> <p>Latency hiding refers to the process of overlapping memory operations with computation to maximize utilization of memory and compute resources. These strategies depend on the underlying hardware -</p> <ul> <li> <p>On CPUs, memory latency hiding is achieved implicitly with simultaneous multithreading or hardware prefetching.</p> </li> <li> <p>GPUs rely on rapid context switching of many warps of threads</p> </li> <li> <p>Specialized DL accelerators such as the TPU usually favor leaner control with a decoupled access-execute (DAE) architecture and offload the problem of fine-grained synchronization to software. This is difficult to program because it requires explicit low-level synchronization. To solve this, TVM introduces a virtual threading scheduling primitive that lets programmers specify a high-level data parallel program. TVM automatically lowers the program to a single instruction stream with low-level explicit synchronization.</p> </li> </ul> <p>Empirically, they observed that peak utilization increased by 25% for ResNet with latency hiding.</p> <h2 id="automating-optimization">Automating Optimization</h2> <p>Now that we have a set of schedule primitives, TVM needs to find the optimal operator implementations for each layer of the DL model. An <em>automated schedule optimizer</em> automates optimizing the hardware parameters through a high-dimensional search space. It consists of</p> <ol> <li> <p>A schedule explorer that proposes new configurations. A <em>schedule template specification</em> API is used to let a developer define the changeable parameters in a code for a given hardware. TVM also has a <em>generic master template</em> to automatically extract possible knobs based on the tensor expression language. More the number of configurations, better optimization is possible.</p> </li> <li> <p>A machine learning cost model that predicts the performance of a given configuration. Defining a perfect cost model is difficult - we need to consider memory access patterns, data reuse, pipeline dependencies, threading patterns, etc for every hardware. So, TVM uses a statistical approach by training an ML model that keeps getting better with newer data. The model has been chosen for <em>quality</em> and <em>speed</em>. The model uses a rank objective to predict the relative order of runtime costs. The model itself is a <em>gradient tree boosting model</em> (based on XGBoost) that makes predictions based on features extracted from the loop program.</p> </li> </ol> <p>The explorer starts with random configurations, and, at each step, randomly walks to a nearby configuration. This exploration method is more efficient than random exploration.</p> <p>A <em>distributed device pool</em> scales up the running of on-hardware trials and enables fine-grained resource sharing among multiple optimization jobs.</p> <h2 id="summary-1">Summary</h2> <p>The core of TVM is implemented in C++ with approximately 50k lines of code. It achieves significantly higher performance as compared to earlier works. However, even with this extensive approach, the models can be designed carefully to achieve much better performance. For example, as seen in Flash Attention, the optimization is a result of human intellectual effort rather than a manual exploration of a partially defined search space by an automated compiler.</p> <h1 id="triton-an-intermediate-language-and-compiler-for-neural-network-computations"><a href="https://www.eecs.harvard.edu/~htk/publication/2019-mapl-tillet-kung-cox.pdf" rel="external nofollow noopener" target="_blank">Triton: An intermediate language and compiler for Neural Network computations</a></h1> <p>As with the previous motivation, Triton was developed to provide a way for users to test new models efficiently without needing to manually optimize it for the hardware. Triton is a language and a compiler centered around the concept of <em>tile</em>, statically shaped multi-dimensional sub-arrays. It is a C-based language for expressing tensor programs in terms of operations on parametric tile variables and provides novel tile-level optimization passes for compiling programs into efficient GPU code.</p> <p>Previous approaches to tackle the wide-variety of deep-learning models include <strong>Domain-Specific Languages (DSLs)</strong> based on polyhedral machinery (tenor comprehensions) and/or loop synthesis techniques (Halide, TVM, PlaidML, etc). These systems perform well for models such as depthwise-separable convolutions, but they are much slower than vendor-based libraries like cuBLAS and cuDNN. The problem with vendor based libraries is that they support only a restricted set of tensor operations.</p> <p>These issues have been addressed by the use of micro-kernels - hand-written tile-level intrinsics, but it requires significant manual labour and cannot be generalized. Compilers do not support these tile-level operators and optimizations. The prior approaches can be summarized as</p> <ol> <li> <p>Tensor level IRs - XLA, Flow to transform tensor programs into predefined LLVM-IR and CUDA-C operation templates (e.g., tensor contractions, element-wise operations, etc) using pattern matching. Triton provides more flexibility.</p> </li> <li> <p>The polyhedral model - Tensor Comprehensions (TC), Diesel to parameterize and automate the compilation of one of many DNN layers into LLVM-IR and CUDA-C programs. Triton supports non-affine tensor indices.</p> </li> <li> <p>Loop synthesizers - Halide, TVM to transform tensor computations into loop nests that can be manually optimized using user-defined schedules. Automatic inference of possible execution schedule in Triton.</p> </li> </ol> <h2 id="triton-c">Triton-C</h2> <p>A C-like language for expressing tensor programs in terms of parametric tile variables. It provides a stable interface for existing DNN trans-compilers and programmers familiar with CUDA. Here is an example of matrix multiplication</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Tile shapes are parametric and can be optimized</span>
<span class="c1">// by compilation backends</span>
<span class="k">const</span> <span class="n">tunable</span> <span class="kt">int</span> <span class="n">TM</span> <span class="o">=</span> <span class="p">{</span><span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">};</span>
<span class="k">const</span> <span class="n">tunable</span> <span class="kt">int</span> <span class="n">TN</span> <span class="o">=</span> <span class="p">{</span><span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">};</span>
<span class="k">const</span> <span class="n">tunable</span> <span class="kt">int</span> <span class="n">TK</span> <span class="o">=</span> <span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">};</span>

<span class="c1">// C = A * B.T</span>
<span class="n">kernel</span> <span class="kt">void</span> <span class="nf">matmul_nt</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">M</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 1D tile of indices</span>
    <span class="kt">int</span> <span class="n">rm</span><span class="p">[</span><span class="n">TM</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_global_range</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">rn</span><span class="p">[</span><span class="n">TN</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_global_range</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">rk</span><span class="p">[</span><span class="n">TK</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">...</span><span class="n">TK</span><span class="p">;</span>
    
    <span class="c1">// 2D tile of accumulators</span>
    <span class="kt">float</span> <span class="n">C</span><span class="p">[</span><span class="n">TM</span><span class="p">,</span> <span class="n">TN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="c1">// 2D tile of pointers</span>
    <span class="kt">float</span><span class="o">*</span> <span class="n">pa</span><span class="p">[</span><span class="n">TM</span><span class="p">,</span> <span class="n">TK</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">rm</span><span class="p">[</span><span class="o">:</span><span class="p">,</span> <span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">rk</span> <span class="o">*</span> <span class="n">M</span><span class="p">;</span>
    <span class="kt">float</span><span class="o">*</span> <span class="n">pb</span><span class="p">[</span><span class="n">TN</span><span class="p">,</span> <span class="n">TK</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">rn</span><span class="p">[</span><span class="o">:</span><span class="p">,</span> <span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">rk</span> <span class="o">*</span> <span class="n">K</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">K</span><span class="p">;</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">-=</span> <span class="n">TK</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">bool</span> <span class="n">check_k</span><span class="p">[</span><span class="n">TK</span><span class="p">]</span> <span class="o">=</span> <span class="n">rk</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span>
        <span class="n">bool</span> <span class="n">check_a</span><span class="p">[</span><span class="n">TM</span><span class="p">,</span> <span class="n">TK</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rm</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">)[</span><span class="o">:</span><span class="p">,</span> <span class="n">newaxis</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">check_k</span><span class="p">;</span>
        <span class="n">bool</span> <span class="n">check_b</span><span class="p">[</span><span class="n">TN</span><span class="p">,</span> <span class="n">TK</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rn</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">)[</span><span class="o">:</span><span class="p">,</span> <span class="n">newaxis</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">check_k</span><span class="p">;</span>
        
        <span class="c1">// Load tile operands</span>
        <span class="kt">float</span> <span class="n">A</span><span class="p">[</span><span class="n">TM</span><span class="p">,</span> <span class="n">TK</span><span class="p">]</span> <span class="o">=</span> <span class="n">check_a</span> <span class="o">?</span> <span class="o">*</span><span class="n">pa</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">B</span><span class="p">[</span><span class="n">TN</span><span class="p">,</span> <span class="n">TK</span><span class="p">]</span> <span class="o">=</span> <span class="n">check_b</span> <span class="o">?</span> <span class="o">*</span><span class="n">pb</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
        
        <span class="c1">// Accumulate</span>
        <span class="n">C</span> <span class="o">+=</span> <span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">trans</span><span class="p">(</span><span class="n">B</span><span class="p">));</span>
        
        <span class="c1">// Update pointers</span>
        <span class="n">pa</span> <span class="o">=</span> <span class="n">pa</span> <span class="o">+</span> <span class="n">TK</span> <span class="o">*</span> <span class="n">M</span><span class="p">;</span>
        <span class="n">pb</span> <span class="o">=</span> <span class="n">pb</span> <span class="o">+</span> <span class="n">TK</span> <span class="o">*</span> <span class="n">N</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// Write-back accumulators</span>
    <span class="kt">float</span><span class="o">*</span> <span class="n">pc</span><span class="p">[</span><span class="n">TM</span><span class="p">,</span> <span class="n">TN</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">rm</span><span class="p">[</span><span class="o">:</span><span class="p">,</span> <span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">rn</span> <span class="o">*</span> <span class="n">M</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">check_c</span><span class="p">[</span><span class="n">TM</span><span class="p">,</span> <span class="n">TN</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rm</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">)[</span><span class="o">:</span><span class="p">,</span> <span class="n">newaxis</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rn</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">);</span>
    <span class="err">@</span><span class="n">check_c</span> <span class="o">*</span> <span class="n">pc</span> <span class="o">=</span> <span class="n">C</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>It is a front-end to describe CUDA like syntax with Numpy like semantics. The syntax is based on ANSI C, and has the following changes</p> <ul> <li> <p>Tile declarations: Syntax for multi-dimensional arrays that can be made parametric with <code class="language-plaintext highlighter-rouge">tunable</code> keyword. Ranges with ellipses.</p> </li> <li> <p>Broadcasting using <code class="language-plaintext highlighter-rouge">newaxis</code> keyword</p> </li> <li> <p>Predicated statements in tiles with <code class="language-plaintext highlighter-rouge">@</code></p> </li> </ul> <p>A tile is an abstraction to hide details involving intra-tile memory coalescing, cache management and specialized hardware utilization.</p> <p>The triton programming model is similar to that of CUDA - each kernel corresponds to a single thread execution.</p> <h2 id="triton-ir">Triton-IR</h2> <p>An LLVM-based Intermediate Representation (IR) that provides an environment suitable for tile-level program analysis, transformation and optimization. Triton-IR programs are constructed directly from Triton-C during parsing, but automatic generation from embedded DSLs is unimplemented. Here is an example for the <code class="language-plaintext highlighter-rouge">max</code> operation</p> <pre><code class="language-C">define kernel void @relu ( float * %A , i32 %M , i32 % N ) {
prologue :
% rm = call i32 &lt;8 &gt; get_global_range (0) ;
% rn = call i32 &lt;8 &gt; get_global_range (1) ;
; broadcast shapes
%1 = reshape i32 &lt;8 , 8 &gt; % M;
% M0 = broadcast i32 &lt;8 , 8 &gt; %1;
%2 = reshape i32 &lt;8 , 8 &gt; % N;
% N0 = broadcast i32 &lt;8 , 8 &gt; %2;
; broadcast global ranges
%3 = reshape i32 &lt;8 , 1 &gt; % rm;
% rm_bc = broadcast i32 &lt;8 , 8 &gt; %3;
%4 = reshape i32 &lt;1 , 8 &gt; % rn;
% rn_bc = broadcast i32 &lt;8 , 8 &gt; %4;
; compute mask
% pm = icmp slt % rm_bc , % M0;
% pn = icmp slt % rn_bc , % N0;
% msk = and % pm , % pn;
; compute pointer
% A0 = splat float * &lt;8 , 8 &gt; % A;
%5 = getelementptr % A0 , % rm_bc ;
%6 = mul % rn_bc , % M0;
% pa = getelementptr %5 , %6;
; compute result
% a = load % pa;
% _0 = splat float &lt;8 , 8 &gt; 0;
% result = max % float %a , % _0;
; write back
store fp32 &lt;8 , 8 &gt; % pa , % result
}
</code></pre> <p>It is similar to LLVM-IR, but it includes the necessary extensions for tile-level data-flow and control-flow.</p> <p>It constructs a data-flow graph including nodes for multi-dimensional tiles and instructions made from basic blocks of code. The control-flow is handled with the use of <em>Predicated SSA</em> and \(\psi\)<em>-functions</em> (compare and merge).</p> <h2 id="triton-jit-compiler">Triton-JIT compiler</h2> <p>A Just-In-Time (JIT) compiler and code generation backend for compiling Triton-IR programs into efficient LLVM bitcode. It includes</p> <ul> <li> <p>A set of tile-level, machine-independent passes aimed at simplifying input compute kernels independently of any compilation target. It involves operations such as pre-fetching to reduce cache misses and tile-level peephole optimization that implement algebraic tricks with tensors.</p> </li> <li> <p>A set of tile-level, machine dependent passes for generating efficient GPU-ready LLVM-IR. It involves</p> <ul> <li> <p>Hierarchical Tiling - The tiles defined by the user are further broken down to the machine’s constraints.</p> </li> <li> <p>Memory coalescing - Making sure that adjacent threads simultaneously access nearby memory locations.</p> </li> <li> <p>Shared memory allocation - To improve memory reuse.</p> </li> <li> <p>Shared memory synchronization - Barriers to preserve program correctness in parallel execution.</p> </li> </ul> </li> <li> <p>An auto-tuner that optimizes any meta-parameters associated with the above passes. Traditional auto-tuners rely on hand-written templates. In contrast, Triton-JIT extracts optimization spaces from Triton-IR (hierarchical tiling parameters only - up to 3 per dimension per tile) and optimizes using an exhaustive search. <strong>This needs to be improved in the future</strong></p> </li> </ul> <h2 id="summary-2">Summary</h2> <p>Triton defeats the other prior solutions achieving performance close to DSLs. However, the authors have highlighted many areas where this framework can be improved in the future - support for tensor cores (the ones TVM talked about), implementation of quantized kernels and integration into higher-level DSLs.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/philosophy/">Philosophy Notes</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/dbms/">DiBS Notes</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/automata/">Automata Notes</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/ipl/">IPL Notes</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/Advanced-Computer-Vision/">Advanced Computer Vision</a> </li> </div> <script>document.querySelectorAll("#table-of-contents a").forEach(function(e){e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substring(1);document.querySelectorAll(".content-section").forEach(function(e){e.classList.add("hidden")});var n=document.getElementById(t);n&&n.classList.remove("hidden")})});</script> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Sudhansh Peddabomma. Last updated: February 05, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?9b43d6e67ddc7c0855b1478ee4c48c2d" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-0K9MLG0V24"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-0K9MLG0V24");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <div class="chat-toggle-container"> <button id="chat-toggle-btn" class="chat-toggle-btn"> <i class="fas fa-comments"></i> </button> </div> <div id="chat-window" class="chat-window"> <div class="chat-header"> <h5 class="mb-0">Talk to my AI</h5> <button id="close-chat" class="btn-close"> <i class="fas fa-times"></i> </button> </div> <div id="chat-messages" class="chat-messages"></div> <div class="chat-input-container"> <input type="text" id="chat-input" class="form-control" placeholder="Type a message..."> <button id="send-btn" class="btn btn-primary"> <i class="fas fa-paper-plane"></i> </button> </div> </div> </body> </html>