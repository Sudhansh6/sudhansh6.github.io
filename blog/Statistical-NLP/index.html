<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Statistical Natural Language Processing | Sudhansh Peddabomma</title> <meta name="author" content="Sudhansh Peddabomma"> <meta name="description" content="Enter the world of Natural Language Processing."> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%91%BE&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://sudhansh6.github.io/blog/Statistical-NLP/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?6185d15ea1982787ad7f435576553d64"></script> <script src="/assets/js/chat.js?e73db4280bae3cbae4d78219277155b9"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Sudhansh Peddabomma</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">Articles</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"></a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/challenges/">Challenges</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/misc/">Miscellaneous</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Statistical Natural Language Processing</h1> <p class="post-meta">November 3, 2024</p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/category/notes"> <i class="fa-solid fa-tag fa-sm"></i> Notes</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <h1 id="introduction">Introduction</h1> <p><strong>Natural Language Processing (NLP)</strong> is the study of computer systems that take as input or produce as output natural language - languages created by humans. The goal is to give machines the power to understand not just words, but entire sentences, paragraphs and documents.</p> <p>It it worth keeping in mind that the notion of “understanding” is contrived. There is no clear definition - when we claim Large Language Models (LLMs) understand our language, we really don’t know if it is understanding.</p> <p>NLP develops systems for</p> <ol> <li> <p>Analysis of language (NL to some useful output) - text classification, question answering, etc.</p> </li> <li> <p>Generation of language (NL to NL; Image to NL, etc) - summarization, image captioning, machine translation</p> </li> <li> <p>Representation of language (NL to some representation) - learning word embeddings</p> </li> </ol> <p>In the part, systems were task-specific, now we have more general purpose systems capable of all of the above and more.</p> <h3 id="origins">Origins</h3> <p>Back in 1949, Warren Weaver, a wartime US mathematician and scientist, brought the idea of the first computer based application related to natural language - machine translation (MT). He considered the problem of translation as a problem in cryptography. We still use the notation of encoder and decoder in the present techniques. He developed a rule-based program to convert Russian to English.</p> <p>Over time, it became obvious that human language are <strong>ambiguous</strong> (unlike programming and other formal languages) and they are <strong>rich</strong> - any meaning may be expressed in many ways. Human language interpretation depends on the real world, common sense and <strong>contextual knowledge</strong>. Furthermore, there is <strong>linguistic diversity</strong> across genres, styles, and so more.</p> <p>In 1957, Chomsky proposed a <em>generative grammar</em>, a rule based system of syntactic structures, brought insight into how linguistics can help MT. Since the results were not satisfactory, funding was cut-off and then came the winter of AI in 1966.</p> <p>In 1971, Terry Winograd’s MIT thesis has motivated the notion of <strong>grounded language understanding</strong>. In late 80’s, statistical techniques revolutionized NLP. They used early ML algorithms - decision trees with rule based systems.</p> <p>From 90’s to early 2000s, methods like logistic regression, Support Vector Machines (SVM), Hidden Markov Models (HMMs), Conditional Random Fields (CRFs), etc were introduced. Moreover, papers introduced feature engineering for specific tasks - POS tagging, Named Entity Recognition, Parsing, etc.</p> <p>The main language models during this time were n-grams with smoothing.</p> <p><img src="/assets/2024-11-03-Statistical-NLP/2024-11-09-15-15-16-image.png" alt=""></p> <h3 id="dawn-of-deep-learning-era">Dawn of Deep Learning Era</h3> <p>Bengio et al. in 2003 proposed first neural language models with 1-hidden layer feed-forward neural network. It introduced the notion of <strong>word embeddings</strong> with a real-valued feature vector in \(\mathbb R^d\). In 2008, a new paper proposed training neural network along with a word embedding matrix jointly. There was no need of feature engineering anymore.</p> <p>In 2013, Mikolov et al. introduced arguably the most popular word embedding model - <strong>Word2Vec</strong> - they got rid of hidden layer in the model as well.</p> <p>From 2013 to 2018, Recurrent Neural Networks (RNNs; Elman 1990), Long-Short Term Memory Models (LSTMs), Convolution Neural Networks (CNNs), recursive neural networks (Socher et al.), etc were used for NLP. There were feats of Architectural engineering as well - combining RNNS with CRFs for sequence labeling, CNNs for text classification, summarization with pointer-generators RNNs (2017). <em>In present date, there are little to no changes in the model architecture.</em></p> <p>In 2014, Google introduced <strong>Sequence-to-sequence</strong> learning, a general end-to-end approach for mapping one sequence to another using a single neural network (encoder-decoder architecture). This proved very important for NLP tasks going forward. It was a fundamental shift in paradigm to perform tasks like translation with a single model instead of complicated designed models.</p> <p>Then, in 2015 came the notion of <strong>Attention</strong> - to reduce the bottleneck of sequence-to-sequence models that was compressing the entire content of source sequence into a fixed-size vector. This notion still required sequential processing with RNNs. Finally in 2017, <strong>Transformers</strong> were proposed which eschewed recurrence and relied entirely on attention mechanisms. The parallel nature of the model enabled fast computations.</p> <p>In 2020, people realized instead of just pre-training the word-embedding layer they could just pre-train the whole network and add a layer-head in the end if required for other specialized tasks. Pre-trained LMs then acted as an initialization for fine-tuning on downstream tasks - ELMo (Peters et al., 2018), ULMFiT (Howard and Ruder, 2018), GPT (Radford et al., 2018), and BERT (Devlin et al,. 2019). The impact of pre-training all the layers was significant.</p> <p><img src="/assets/2024-11-03-Statistical-NLP/2024-11-09-15-15-02-image.png" alt=""></p> <h3 id="present-date">Present Date</h3> <p>NLP systems are increasing used in everyday life - in the form of chatbots and other AI assistants. Consider ChatGPT - fastest growing consumer computing applications in history.</p> <p>The key advantage os language models is that there is no need of annotation - nearly unlimited training data*. People also realized that using larger and larger models gives higher performance as data scales. The final ingredient to achieve all this is compute - GPU gave a huge advantage over CPU to train these networks. These three key ingredient - hardware scalability (GPUs), Model scalability (Transformer with many deep layers) and Data scalability (Large datasets with lots of text) enabled the success of GPT models.</p> <p><img src="/assets/2024-11-03-Statistical-NLP/2024-11-09-15-14-43-image.png" alt=""></p> <p>Realizing the power of scale, GPT1 was trained with a few million parameters and now GPT4 has a few hundred billion parameters. In 2022, researchers at OpenAI realized some tasks were only possible at larger scales - scaling LMs leads to emergent abilities. Another paper (one of the best papers in NeurIPS) questioned this asking whether this finding is just an artifact of how we designed our metrics. The metrics used in the OpenAI paper did not allow continuous rewards which caused the sudden jump in performance after a certain point in scale. With a more continuous metric, the gains due to scale increase continuously without sudden jumps.</p> <p>Then came the question of prompting - how do we talk to these LMs? <strong>Prompt</strong> is a cue given to the pre-trained LM to allow it to better understand people’s questions (Best paper in NeurIPS 2020).</p> <p>GPT3.5 introduced the notion of <strong>Instruction Tuning</strong> - collect examples of (instruction, output) pairs across many tasks and then evaluate on unseen tasks. Furthermore, the output of LMs can be tuned with <strong>Reinforcement Learning with Human Feedback</strong> (RLHF) - explicitly attempt to satisfy human preferences using RL. This was implemented in an ingenious manner -</p> <p><img src="/assets/2024-11-03-Statistical-NLP/2024-11-09-15-13-21-image.png" alt=""></p> <p>After adding some safety features, GPT3.5 was transformed into ChatGPT.</p> <p><strong>LLM as a reasoning engine</strong> - The knowledge base of LLMs is large but incomplete. To address this limitation, they need to retrieve information from elsewhere, add it to the prompt and then ask the LLM to process it to get an answer. This is the idea behind <strong>Retrieval Augmented Generation (RAG)</strong> for knowledge intensive NLP tasks. The pipeline is more sophisticated, and will be described later.</p> <h3 id="summary">Summary</h3> <p>We have the following big picture -</p> <ol> <li> <p>Feature Engineering in 1990s to 2000s</p> </li> <li> <p>Architecture Engineering - 2010 - 2018 (LSTMs, CNNs, Transformers)</p> </li> <li> <p>Objective Engineering - 2018 (ELMo, BERT, GPT)</p> </li> <li> <p>Prompt Engineering - 2020s - present (instruction-tuning, chain-of-thought, etc)</p> </li> </ol> <p><strong>NLP vs Humans.</strong> General language understanding is still a bit difficult for LLMs</p> <ul> <li> <p>Sample efficiency - LLMs require a lot of data</p> </li> <li> <p>Robustness - LLMs are brittle, can be easily fooled</p> </li> <li> <p>Originality - LLMs lack ability to create truly original content</p> </li> <li> <p>Causality and other forms of reasoning - LLMs have limited understanding of logic</p> </li> </ul> <p>In the following post, we will start from the basis such as text classification with simple neural networks and make our way to the modern sophisticated techniques being used. Although the initial part of the article may seem very straightforward, it is important to understand the motivations and ideas behind the approaches.</p> <h1 id="text-classification">Text Classification</h1> <p>The task is to assign a text document to one or more categories from a predefined set of labels. For example, Sentiment Analysis, Spam Detection, Topic Classification, Authorship Attribution and Language Identification fall under this domain of tasks.</p> <p>Unlike tasks like sorting numbers which have clear rules, text classification does not have a standard algorithm. The issues with rule-based algorithms are as follows -</p> <ol> <li> <p>Semantic Gap - Computer does not know what words mean - their relationships, sentiment, etc.</p> </li> <li> <p>Intra-class variations - There are many ways to be a particular label.</p> </li> <li> <p>Scalability - Have to write rules for every class label</p> </li> </ol> <p>The task rather requires a data-driven approach (in the form of machine learning) -</p> <ol> <li> <p>Collect a dataset of example text inputs and their labels - <strong>training data</strong></p> </li> <li> <p>Use Machine Learning algorithms to train a classifier on the training examples</p> </li> <li> <p>Evaluate the classifier of new text data - <strong>test data</strong> - a good classifier generalizes well.</p> </li> </ol> <p>This is the standard process (used to be) to work with machine learning models. Another important aspect with this approach is modeling of data - i.e., input representation. Machine Learning models require numerical input.</p> <blockquote> <p>At their core, machine learning models are optimization models relying on mathematical operations - cannot be done with text data.</p> </blockquote> <p>Therefore, we need to create a <em>feature vector</em> for the input text for text classification. By creating feature vectors, we are essentially creating another veil of abstraction to reduce the semantic and other complexities in text data.</p> <p><strong>Bag of words</strong> is one such early idea that represents text as an unordered collection of words, disregarding grammar and word order. The vector essentially contains the frequency of each word occurring in the training text. For unseen words in test data, we just treat them as a separate entity under the unknown tag.</p> <p>These feature vectors although being one of the simplest forms of representation have some limitations (owing to the simplicity)</p> <ol> <li> <p>Sparsity - high-dimensional, sparse vectors (size of vocabulary)</p> </li> <li> <p>Loss of sentence structure - This context is very important in some tasks</p> </li> <li> <p>Semantic Gap - Lacks the word meanings</p> </li> </ol> <h3 id="nearest-neighbor-classifier">Nearest Neighbor Classifier</h3> <p>The idea is to represent all training examples in a feature space. Given a test instance, we find the closest training example based on a <strong>distance metric</strong> and assign its label to the test instance. This algorithm does not have any training of sorts and takes constant time. However, the inference time is \(\mathcal O(n)\) since it has to be compared against every test instance. We do not want such behavior with ML models - even if the training is slow, we want the inference to be very fast.</p> <p>Furthermore, the decision boundaries created by this algorithm are not smooth - <em>from experience this is a bad outcome, and we ideally want a smooth decision boundary</em> without too many changes. Motivating from this idea, then came along \(k\)-Nearest Neighbor classification where the nearest \(k\) neighbors are chosen to decide the label. The parameter \(k\) is called as a <strong>hyperparameter</strong> that is tuned based on the dataset, model, etc. There is no clear answer as to which hyper-parameter gives the best performance; they have to be chosen empirically. The distance metric and word representation are other hyperparameters in this algorithm.</p> <p>Suppose we choose the hyperparameter that works best on the <em>test data</em>, it may not perform that well on other test/unseen data. To overcome this, a new split called <strong>validation</strong> is introduced. The hyperparameters are chosen with the validation data and the algorithm is tested on the test data. The golden rule is to run the model on the test set once after everything (training and hyper-parameter tuning) is completed.</p> <p>The advantages of these models are that they are non-parametric - they make no assumptions about the underlying data. Now, we see another form of classifier that does not have this property.</p> <h3 id="linear-classifier">Linear classifier</h3> <p>A linear classifier assumes a specific form of the decision boundary - predefined model complexity. These boundaries are defined by a set of fixed parameters - intercept \(b\) and slope \(m\). This form of a classifier is still used today in practice.</p> <p>The mathematical model can be represented as</p> \[y \text{ (label) } = \underbrace{f(x)}_{n \times 1} = \underbrace{W}_{n \times m} \underbrace{x}_{m \times 1} + b\] <p>Here, \(n\) is the number of classes and \(m\) is the feature dimension. The bias term \(b\) essentially incorporates prior knowledge into the model.</p> <p>Linear layers are the building block of <strong>neural networks</strong>. Neural networks consist of small functions that are stacked together to form a complex function, and linear layers are a common building block in these architectures.</p> <p>How do we find the best \(W, b\)? We define a <strong>loss function</strong> that quantifies our unhappiness with the scores across the training data. This loss function is minimized via <strong>optimization</strong> to get these best values. We typically average the loss function across all the training examples to get the total loss in a training dataset.</p> <p>Finally, the output from a classifier is unnormalized, and we generally want to interpret these raw scores as probabilities. To normalize the outputs, we use a softmax function -</p> \[P(Y = k, X = x_i) = \frac{e^{s_k}}{\sum_j e^{s_j}}\] <p>where \(e\) is the raw output from the model. This interpretation allows us to now define a loss-function for (binary class) classifiers - <strong>negative log likelihood</strong>.</p> \[L_i = - \log P(y = y_i \vert X = x_i)\] <p>Such method of classification is termed as <strong>logistic regression</strong>.</p> <blockquote> <p>For logistic regression, with a small initialization of weights, the expected initial loss is \(\log (# classes)\). A good sanity check to look out for.</p> </blockquote> <p>The above loss function is essentially doing <strong>maximum likelihood estimation</strong> on the training data. Given training samples \((x_i, y_i)\), the maximum likelihood is given by \(W_{ML} = {\arg \max}_{W \in \mathbb R^{\gamma \times C}} \mathcal L(\bf W)\).</p> <p>The likelihood of the data is given as \(\mathcal L(\bf W) = \sum_{i = 1}^n \log p (Y_i \vert x_i; \bf W)\).</p> <h3 id="feed-forward-neural-networks">Feed-forward Neural Networks</h3> <p>Neural networks introduce a powerful regime of data-driven methods. These models are essentially linear layers stacked (without the softmax) against one another to form a huge network. Each linear layer is associated with an <strong>activation function</strong> that introduces non-linearity in the models. For example, the linear output \(Wx + b\) from a linear classifier layer is sent through a sigmoid activation function which essentially maps the input \(x\) to \((1 + e^{-x})^{-1}\). Each weight row in the network is referred to as a <strong>neuron</strong>.</p> <p>Note that we want our models to generalize well on unseen data. Since neural networks are powerful models, they can <em>overfit</em> on the training data to perform really well on the training set but poorly on the test set. Through <strong>regularization</strong>, we prevent overfitting by discouraging the model from fitting the training data too closely. This occurs frequently when in deep and complicated models. With regularization, we are no longer doing Maximum Likelihood Estimation (MLE) with our models. The loss function then becomes</p> \[L(W) = \frac{1}{N} \sum_{i = 1}^N L_i (F(x_i, W), y_i) + \lambda R(W)\] <p>where \(R(W)\) is the regularization function and \(\lambda\) is a <em>regularization parameter</em>, and it represents the regularization strength. There are more complex methods like <strong>dropout</strong> and <strong>batch normalization</strong> to prevent overfitting. Dropout refers to <em>randomly dropping</em> neurons in the network while training to simplify the model complexity during training time.</p> <p>With this model, we have described the basic recipe for supervised machine learning!</p> <p>How do we find the best \(W\) with these building blocks? Start with a random \(W\) and iteratively improve it to lower the loss function - <strong>gradient descent</strong>. The size of iterative improvement is given by the <strong>learning rate</strong> - another important hyperparameter. A small learning rate leads to slower convergence whereas a high learning rate can overshoot the minimum. Typically, the learning rate is changed across training epochs based on a <strong>learning rate schedules</strong> (ex. cosine learning).</p> <p>The gradient function is pre-computed to prevent recomputing the gradient for every example in practice. <strong>Backpropagation</strong> is a method to compute the gradient of the loss function with respect to the weights in the network - it is an application of the chain rule of calculus.</p> <p>The naïve version of gradient descent can be optimized much further using better convergence algorithms like ADAM and using stochasticity to descent over batches rather than the whole training dataset to increase speed.</p> <h1 id="word-embeddings-and-tokenization">Word Embeddings and Tokenization</h1> <p>How do we convert words to numerical values? A simple idea is to consider a <strong>one-hot vector</strong> - maps words into fixed length vectors and they contain only the identity information of the object without any semantic information. <strong>Bag-of-words</strong> is essentially the summation of one-hot vectors across the input text.</p> <p>An interesting result is that word meanings can also be captured through vectors of real numbers - a vector space where similar words (by meaning) have similar vectors (by some distance metric). How do we come up with such vectors that also have a reasonable size?</p> <h3 id="distributional-semantics">Distributional Semantics</h3> <p>Words that appear in similar contexts have similar meanings. The idea is to understand the context around the word and their relative ordering to understand the meaning of the word itself. To do so, we will build a dense vector for each word, chosen so that it is similar to vectors of words that appear in similar contexts, measuring similarity as the vector dot (scalar) product.</p> <h3 id="word2vec">Word2Vec</h3> <p>A simple and fast model to capture semantic meanings. They use two algorithms - skip-gram and Continuous Bag of Words (CBOW).</p> <p><strong>Skip-gram</strong> - Given a corpus of text as the input, the output is a set of embeddings which is a real valued vector. To generate these embeddings, we set up a fake prediction task - predict a word’s context from that word. For example, in the sentence “the dog bit the man”, for the <em>word</em> “bit”, the <em>context</em> can be “dog” or “the”.</p> <p>For each position $t = 1, \dots, T$ in the corpus, we predict context words within a window of fixed size \(m\) (<em>context window size</em>), given a center word \(w_j\). The joint probability expression is given by</p> \[\text{ Data Likelihood } = \prod_{t = 1}^{T} \prod_{-m \leq j \leq m; j \neq 0} P(w_{t + j} \vert w_t; \theta)\] <p>where \(\theta\) are all the parameters of the model. The loss function can be chosen as</p> \[L(\theta) = -\frac{1}{T} \sum_{t = 1}^T \sum_{-m \leq j \leq m; j \neq 0}\log P(W_{t + j} \vert w_t; \theta)\] <p>The ground truth probability is calculated by looking at all examples of the word occurring in the training corpus. The original paper predicts two vectors per word \(w\) - \(v_w\) when \(w\) is a center word, \(u_w\) when \(w\) is a context word. The probability is then given by</p> \[P(o \vert c) = \frac{\exp (u_o^T v_c)}{\sum_{w \in V} \exp(u^T_w v_c)}\] <p>The gradient of this loss function comes out to be expected context vector subtracted from the observed context vector. The center word is pulled towards words that are observed in its context and away from those that are not</p> \[v_c^{new } = v_c^{old} + \text{observed} - \text{expected}\] <h1 id="low-rank-adaptation-lora">Low-rank Adaptation (LoRA)</h1> \[h = W\] <h1 id="multi-layer-prompt-tuning">Multi-layer Prompt Tuning</h1> <p>Continuous prompts \(\phi_i\) are concatenated with the keys and values in the self-attention layer</p> <h1 id="adapters-in-transformer-models">Adapters in Transformer Models</h1> <p>An adapter in a Transformer layer</p> \[f_{\phi_i}(x) = W^U(\sigma(W^D x))\] <p>where \(W_^D \in \mathbb R^{d\times r},\)W^U$$</p> <h1 id="towards-a-unified-view-for-parameter-efficient-fine-tuning">Towards a Unified View for Parameter Efficient fine-tuning</h1> <p>This works shoes that LoRA, prefix-tuning, and adapters can be expressed with a similar functional form - all methods can be expressed as modifying a model’s hidden representation \(h\)</p> <h3 id="optimizer-state-comparison">Optimizer State comparison</h3> <h2 id="model-compression">Model compression</h2> <h3 id="knowledge-distillation">Knowledge Distillation</h3> <p>A classic approach from Hinton et. al</p> <h3 id="distilbert">DistilBERT</h3> <p>The idea is to use the classification model with output \(P_{\text{teacher}} (y \vert x)\) to minimize \(KL(P_{\text{teacher}}\vert\vert P_{\text{student}})\) to bring student distribution close to the teacher. Note that this approach does not require any labels since the student uses <em>pseudo-labels</em> that the teacher has.</p> <p>For example, we can choose BERT as the teacher model and create a small student model that has half the layers of BERT. The number of parameters reduce by half and so does the inference time. The performance difference is negligible and this is a huge gain for efficiency.</p> <h1 id="knowledge-representation-in-transformer-lms">Knowledge Representation in Transformer LMs</h1> <p>Factual knowledge is captured by the model during the training is stored in the form of model parameters. Which part of the transformer is this information stored? Token embeddings, feedforward laters or attention layers?</p> <h3 id="parameter-distribution-in-transformers">Parameter Distribution in Transformers</h3> <ul> <li> <p>Self-attention layers</p> <ul> <li> <p>Query, Key, Value matrices - \(W_q, W_k, W_v\) each of dimension \(d \times d\)</p> </li> <li> <p>Output matrix is \(W_o\) of dimension \(d \times d\)</p> </li> <li> <p>\(4d^2\) attention parameters per layer.</p> </li> </ul> </li> <li> <p>Feed-forward Network Layers</p> <ul> <li> <p>First linear transformation via \(W_1: 4d^s\) (input to \(4d\))</p> </li> <li> <p>Second linear transformation via \(W_2: 4d^2\) (\(4d\) to output)</p> </li> <li> <p>\(8d^2\) feedforward parameters per layer</p> </li> </ul> </li> <li> <p>The embedding parameters are not usually considered since the vocabulary across all the models is assumed to be the same</p> </li> </ul> <p>Note that feedforward layers have much higher number of parameters than the attention layers - they account for 2/3 of the total parameters.</p> <h2 id="transformer-feed-forward-layers-are-key-values-memories">Transformer Feed-Forward Layers Are Key-Values Memories</h2> <p>An interesting paper that explores the previous ideas. The feedforward layer is represented as \(y = W_2 \sigma(W_1 x)\).</p> <p>\(W_1\) corresponds to keys, and \(W_2\) to values - when the output from the first weight matrix is passed through ReLU - it is similar to <em>selecting</em> some entries of the vector (positive ones) which then choose the corresponding rows in \(W_2\).</p> <p>The authors tested this idea by considering which neurons are selected in the feedforward layers for different tokens - <strong>key trigger analysis</strong>. They analyzed the patterns in the activations to categorize them.</p> <p>Given a key \(k_i^l\) corresponding to \(i\)th row of the \(l\)th feed-forward layer \(W_1\) computer memory efficient for every prefix \(x_1, \dots, x_j\) of every sentence in the training data.</p> <p><strong>Memory coefficient calculation</strong> - calculate \(ReLU(x_j^l \cdot k)\) - incomplete</p> <p>They found the following results -</p> <ul> <li> <p>Shallow layers detect shallow patterns</p> </li> <li> <p>Middle FF layers store knowledge; Upper attention layers “aggregate” relevant knowledge for prediction</p> </li> </ul> <h2 id="editing-knowledge-in-transformer-lms">Editing Knowledge in Transformer LMs</h2> <p>Can we directly edit LM parameters to fix incorrect, obsolete facts? The edits must be deep -</p> <ul> <li> <p>Eiffel tower is located in the city ____ (change from Paris to Rome)</p> </li> <li> <p>Model should understand full implications - The tallest building in Rome is <em>__Eiffel Tower</em>__</p> </li> </ul> <p>The edit must be robust, should not edit all the facts in the model.</p> <p>Can we simply modify the columns of \(W_2\) to change the model’s behavior? This ends up breaking the model. Another work, Meg et al., suggested applying a rank-1 update \(W_2 \to W_1 + uv^T\) to maximize the probability of the edit output. This change minimizes the change in the behavior of \(W_2\) on other inputs.</p> <p>It works well in some scenarios and does not in some other - it is a new research direction!</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/Design-and-Analysis-of-Algorithms/">Design and Analysis of Algorithms</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/Large-Language-Models-Research/">Large Language Model Reasoning</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/Object-Detection/">Object Detection</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/Lattices-in-Cryptography/">Lattices in Cryptography and Quantum Computers</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/GANs-for-Compressed-Sensing/">Generative Adversarial Networks for Compressed Sensing</a> </li> </div> <script>document.querySelectorAll("#table-of-contents a").forEach(function(e){e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substring(1);document.querySelectorAll(".content-section").forEach(function(e){e.classList.add("hidden")});var n=document.getElementById(t);n&&n.classList.remove("hidden")})});</script> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Sudhansh Peddabomma. Last updated: January 11, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?9b43d6e67ddc7c0855b1478ee4c48c2d" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-0K9MLG0V24"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-0K9MLG0V24");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <div class="chat-toggle-container"> <button id="chat-toggle-btn" class="chat-toggle-btn"> <i class="fas fa-comments"></i> </button> </div> <div id="chat-window" class="chat-window"> <div class="chat-header"> <h5 class="mb-0">Talk to my AI</h5> <button id="close-chat" class="btn-close"> <i class="fas fa-times"></i> </button> </div> <div id="chat-messages" class="chat-messages"></div> <div class="chat-input-container"> <input type="text" id="chat-input" class="form-control" placeholder="Type a message..."> <button id="send-btn" class="btn btn-primary"> <i class="fas fa-paper-plane"></i> </button> </div> </div> </body> </html>